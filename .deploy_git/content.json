{"meta":{"title":154051,"subtitle":"","description":"","author":154051,"url":"https://a154051.gitee.io","root":"/"},"pages":[{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2021-09-01T12:40:49.000Z","comments":false,"path":"about/index.html","permalink":"https://a154051.gitee.io/about/index.html","excerpt":"","text":"[さくら荘のhojun] 与&nbsp; Mashiro&nbsp; （ 真（ま）白（しろ） ） 对话中... bot_ui_ini()"},{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2021-09-01T12:40:49.000Z","comments":false,"path":"bangumi/index.html","permalink":"https://a154051.gitee.io/bangumi/index.html","excerpt":"","text":""},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2021-09-01T12:40:49.000Z","comments":true,"path":"comment/index.html","permalink":"https://a154051.gitee.io/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》"},{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2021-09-01T12:40:49.000Z","comments":false,"path":"client/index.html","permalink":"https://a154051.gitee.io/client/index.html","excerpt":"","text":"直接下载 or 扫码下载："},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2021-09-01T12:40:49.000Z","comments":false,"path":"donate/index.html","permalink":"https://a154051.gitee.io/donate/index.html","excerpt":"","text":""},{"title":"游戏","date":"2021-03-09T09:00:00.000Z","updated":"2021-09-01T12:40:49.000Z","comments":false,"path":"games/index.html","permalink":"https://a154051.gitee.io/games/index.html","excerpt":"","text":"颓废区 请自行保存存档 2048 小黑屋 flappy bird 进化 生命游戏 生命游戏介绍好东西"},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2021-09-01T12:40:49.000Z","comments":false,"path":"lab/index.html","permalink":"https://a154051.gitee.io/lab/index.html","excerpt":"","text":"sakura主题balabala"},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2021-09-01T12:40:49.000Z","comments":true,"path":"links/index.html","permalink":"https://a154051.gitee.io/links/index.html","excerpt":"","text":""},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2021-09-01T12:40:49.000Z","comments":false,"path":"music/index.html","permalink":"https://a154051.gitee.io/music/index.html","excerpt":"","text":""},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2021-09-01T12:40:49.000Z","comments":true,"path":"rss/index.html","permalink":"https://a154051.gitee.io/rss/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2021-09-01T12:40:49.000Z","comments":true,"path":"tags/index.html","permalink":"https://a154051.gitee.io/tags/index.html","excerpt":"","text":""},{"title":"Hexo 主题 Sakura 🌸","date":"2019-01-04T14:53:25.000Z","updated":"2021-09-01T12:40:49.000Z","comments":true,"path":"theme-sakura/index.html","permalink":"https://a154051.gitee.io/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro Hexo-Sakura主题 感谢ctz大佬写的教程，解决了很多问题。如果早点看到也不至于一开始费那么大力气瞎搞"},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2021-09-01T12:40:49.000Z","comments":false,"path":"video/index.html","permalink":"https://a154051.gitee.io/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }"}],"posts":[{"title":"【题解】P4331 [BalticOI 2004]Sequence","slug":"solution-P4331-sequence","date":"2021-09-25T08:35:02.000Z","updated":"2021-09-25T09:42:17.488Z","comments":true,"path":"2021/09/25/solution-P4331-sequence/","link":"","permalink":"https://a154051.gitee.io/2021/09/25/solution-P4331-sequence/","excerpt":"","text":"P4331 [BalticOI 2004]Sequence 数字序列 好多题解都是用的中位数做法，其实贪心就可以直接做。 题意给定一个长度为 $n$ 的整数序列 $a$，求出一个严格递增整数序列 $b$，使得 $\\sum^n_{i=1}\\left\\vert a_i-b_i\\right\\vert$ 最小。 做法首先给 $b$ 赋一个初值，使得 $b_i\\le a_i(i\\in n)$ 并且 $b_i=b_{i-1}+1(i\\in [2,n])$。 在这种情况下，要想使答案更优只能增大 $b$ 序列或不变。 因为 $b$ 严格递增，并且 $b_i=b_{i-1}+1$，所以要想使 $b_i$ 增加 $x$，就要对 $[i,n]$ 整个区间加上 $x$。 定义 $val_i=\\begin{cases}1&amp;a_i&gt;b_i \\\\ -1&amp;a_i\\le b_i\\end{cases}$，$sum_i=\\sum\\limits_{j=i}^n val_j$。 然后重复执行下列操作： 在 $[1,n]$ 中找到最大的 $sum$ 的位置 $k$，可以发现 $b_i=b_{i-1}+1(i\\in[k+1,n])$，证明在下面。 设 $x=\\min\\{a_i-b_i \\}(i\\in[k,n],a_i-b_i&gt;0)$，令 $b_i+x(i\\in[k,n])$。 更新 $val$ 和 $sum$。 直到所有的 $sum$ 都小于等于 $0$。 正确性证明： 对初始序列 $b$ 执行一遍该操作显然正确。 记 $last$ 为上一次操作中最大的 $sum$ 的位置，$k$ 为这次操作中最大的 $sum$ 的位置。 可以得到，对于任意的 $i\\in [1,last-1]$，都有 $sum_i\\le sum_{last}$。 在上一次操作中，$[last,n]$ 中至少会有一个位置的 $val$ 变为 $-1$，则 $sum_i(i\\in[1,last-1])$ 只会变得更小，所以 $k$ 不可能在 $[1,last-1]$ 中，$k$ 只会越来越靠右，因此 $b_i=b_{i-1}+1(i\\in[k+1,n])$，所以对 $b_i(i\\in [k,n])$ 执行该操作显然也正确。 证毕。 用线段树维护 $sum$，$set$ 维护 $[k,n]$ 中 $a_i-b_i(i\\in[k,n])$ 大于 $0$ 的元素。 每次操作用线段树求出 $[1,n]$ 中最大的 $sum$ 的位置 $k$，将 $set$ 中位置在 $[1,k-1]$ 的元素删除，在 $set$ 中查询此时 $a_i-b_i$ 的最小值，将等于该值的元素删除，并在线段树上将区间 $[1,\\text{该元素位置}]$ 中所有 $sum$ 减 $1$。 由于不会添加元素，所以 $set$ 至多有 $n$ 次删除操作，线段树至多有 $n$ 次修改操作。 时间复杂度为 $O(n\\log n)$。 复杂度虽然正确，但常数有点大，时间卡得很紧，要开 $O2$ 才能过。 代码#include &lt;bits/stdc++.h&gt; #define mk(x,y) make_pair(x,y) #define ls now&lt;&lt;1 #define rs now&lt;&lt;1|1 using namespace std; typedef long long ll; const int mn=1e6+7; struct tree &#123; int ans,mx,tag; &#125;tr[mn&lt;&lt;2]; int a[mn],sum[mn],val[mn]; ll b[mn]; set&lt;pair&lt;ll,int&gt; &gt; st; int in() &#123; int x=0; char c=getchar(); while(!isdigit(c)) c=getchar(); while(isdigit(c)) &#123; x=x*10+c-&#39;0&#39;; c=getchar(); &#125; return x; &#125; void upd(int now) &#123; if(tr[rs].mx&gt;=tr[ls].mx) tr[now].mx=tr[rs].mx,tr[now].ans=tr[rs].ans; else tr[now].mx=tr[ls].mx,tr[now].ans=tr[ls].ans; &#125; void build(int now,int l,int r) &#123; if(l==r) &#123; tr[now].mx=sum[l]; tr[now].ans=l; return ; &#125; int mid=(l+r)&gt;&gt;1; build(now&lt;&lt;1,l,mid); build(now&lt;&lt;1|1,mid+1,r); upd(now); &#125; void push(int now) &#123; if(!tr[now].tag) return ; tr[now&lt;&lt;1].mx+=tr[now].tag; tr[now&lt;&lt;1].tag+=tr[now].tag; tr[now&lt;&lt;1|1].mx+=tr[now].tag; tr[now&lt;&lt;1|1].tag+=tr[now].tag; tr[now].tag=0; &#125; void add(int now,int l,int r,int x,int v) &#123; if(r&lt;=x) &#123; tr[now].mx+=v; tr[now].tag+=v; return ; &#125; push(now); int mid=(l+r)&gt;&gt;1; if(x&gt;mid) add(now&lt;&lt;1|1,mid+1,r,x,v); add(now&lt;&lt;1,l,mid,x,v); upd(now); &#125; int main() &#123; int n,mi=1; n=in(); ll ans=0; for(int i=1;i&lt;=n;++i) &#123; a[i]=in(); mi=min(mi,a[i]-i+1); &#125; for(int i=1;i&lt;=n;++i) &#123; b[i]=mi+i-1; ans+=abs(b[i]-a[i]); if(b[i]&lt;a[i]) val[i]=1,st.insert(mk(a[i]-b[i],i)); else val[i]=-1; &#125; sum[n]=val[n]; for(int i=n-1;i&gt;=1;--i) sum[i]=sum[i+1]+val[i]; build(1,1,n); int last=1,cnt=0; while(1) &#123; if(tr[1].mx&lt;=0)&#123; //终止条件 for(int i=last;i&lt;=n;++i) b[i]+=cnt; break; &#125; int now=tr[1].ans; //最大的 sum 的位置 for(int i=last;i&lt;now;++i)&#123; //删除 set 中多余的元素 b[i]+=cnt; if(a[i]-b[i]-cnt&gt;0) st.erase(mk(a[i]-b[i],i)); &#125; last=now; ans-=tr[1].mx*((*st.begin()).first-cnt); cnt=(*st.begin()).first; while(st.size()) //删除 a-b 等于 0 的元素 &#123; pair&lt;ll,int&gt; it=*st.begin(); if(it.first!=cnt) break; add(1,1,n,it.second,-2); //维护 sum st.erase(st.begin()); &#125; &#125; printf(&quot;%lld\\n&quot;,ans); for(int i=1;i&lt;=n;++i) printf(&quot;%lld &quot;,b[i]); return 0; &#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://a154051.gitee.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"https://a154051.gitee.io/tags/%E8%B4%AA%E5%BF%83/"}],"author":154051},{"title":"【题解】P3291 [SCOI2016]妖怪","slug":"solution-P3291-yao-guai","date":"2021-09-01T12:11:16.000Z","updated":"2021-09-01T12:40:49.000Z","comments":true,"path":"2021/09/01/solution-P3291-yao-guai/","link":"","permalink":"https://a154051.gitee.io/2021/09/01/solution-P3291-yao-guai/","excerpt":"","text":"蒟蒻不会凸包，于是用模拟退火过了这道题。 如果你还不会模拟退火，可以看看我之前写的学习笔记。 题意来自辰星凌的题解： 给出 $n$ 个点 $(x_i,y_i)$，设 $f_i(a,b)=x_i+y_i+\\frac{bx_i}{a}+\\frac{ay_i}{b}$，求出一组 $(a,b)$，使得 $\\max\\{f_{i\\in[1,n]}(a,b)\\}$ 最小，输出这个最小值。 做法正常模拟退火流程，每次随机生成两个数 $(a,b)$，暴力遍历一遍所有点计算出当前的答案，与上一次的答案比较。 蒟蒻一开始只是想骗点分，没想到拿了 $80$ 分，于是就进入了痛苦的调参过程。（注：没有在洛谷提交，洛谷数据不全。） 最初提交时总是第 $7$ 个点错，后来有一次分比较低，但是第 $7$ 个点对了，我比较了一下认为是初始温度的问题，初始温度低会导致生成出来的数的范围小，而那个点最优情况下的 $(a,b)$ 大于这个范围，所以就一直错。 于是稍微修改一下参数就 $A$ 了，最后一共提交了 $172$ 次… 不开 $O2$ 会 $T$，时间复杂度 $O(\\text{玄学})$。 代码#include &lt;bits/stdc++.h&gt; #define rd t*(rand()*2-RAND_MAX) #define max(x,y) (x&lt;y?y:x) //这里是个小优化，会快一点 using namespace std; typedef long long ll; const double eps=1e-6,down=0.89; const int mn=1e6+7; int n; double x[mn],y[mn]; double sol(double a,double b) &#123; double rs=0; for(int i=1;i&lt;=n;++i) &#123; double tmp=x[i]+y[i]+x[i]/a*b+y[i]/b*a; rs=max(rs,tmp); &#125; return rs; &#125; int main() &#123; srand(154051); scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;++i) scanf(&quot;%lf%lf&quot;,&amp;x[i],&amp;y[i]); ll a=1,b=1; double ans,minn; minn=ans=sol(1,1); for(double t=1100000;t&gt;eps;t*=down) &#123; ll aa=a+rd,bb=b+rd; if(aa==0) aa++; if(bb==0) bb++; if(aa&lt;0) aa=-aa; if(bb&lt;0) bb=-bb; double rs=sol(aa,bb); if(minn&gt;rs) minn=rs; if(rs&lt;ans||exp((ans-rs)/t)*RAND_MAX&gt;rand()) &#123; ans=rs; a=aa;b=bb; &#125; &#125; printf(&quot;%.4f&quot;,minn); return 0; &#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://a154051.gitee.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"模拟退火","slug":"模拟退火","permalink":"https://a154051.gitee.io/tags/%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB/"}],"author":154051},{"title":"【题解】P3761 [TJOI2017]城市","slug":"solution-P3761-city","date":"2021-08-08T12:31:36.000Z","updated":"2021-09-01T12:40:49.000Z","comments":true,"path":"2021/08/08/solution-P3761-city/","link":"","permalink":"https://a154051.gitee.io/2021/08/08/solution-P3761-city/","excerpt":"","text":"P3761 [TJOI2017]城市 前排提醒：本文着重证明了 $O(n)$ 的做法，$O(n^2)$ 的做法讲得不是很明白。 题意给一颗有边权的树，删去一条边并加上一条权值相同的边（要求操作后还是一颗树），求树的直径最小是多少。 $n\\le 5000$。 题解很妙的一道题，主要难点在于结论的寻找和证明。 最朴素的做法是枚举每条要删除的边，整棵树被分为了两颗子树，再枚举两颗子树上选的点，计算直径。时间复杂度 $O(n^4)$。 $O(n^2)$ 做法新加入一条边后，新树的直径有两种情况： 直径在分出来的两颗树中的一个。 直径经过了新加入的边。 对于第一种情况，新加入的边不会产生影响。 对于第二种情况，要想办法连边使得新树的直径最小。可以发现两棵树要连的点都是树的中心（即该点到其他节点的最远距离最小）。 考虑 $DP$，第一遍 $\\text{dfs}$ 求出在该节点子树内从它出发的最远和次远距离。 第二遍 $\\text{dfs}$ 根据父亲的信息求出在整棵树中从该节点出发的最远和次远距离，在这个过程中找出树的中心。 所以优化后的做法为枚举每条要删除的边，求出分出来的两颗树的直径和中心，比较这三个值，取最大。时间复杂度 $O(n^2)$。 这个复杂度已经可以通过这道题了，但是还能继续优化到 $O(n)$。 $O(n)$ 做法时间复杂度的瓶颈主要在 $DP$，考虑优化。 结论一：树的中心是树的直径的（带权）中点。 证明： 对于直径上任意一点 $u$，显然从 $u$ 出发的最远路径一定在直径上，若要求直径中心则只需比较 $u$ 到直径两端的最远距离，所以直径中点 $mid$ 是该直径的中心。 对于不在直径上的点 $v$，从 $v$ 出发到 $mid$，再到直径较远一端的所走路程，必然比直接从 $mid$ 出发的所走路程远。根据定义，树的中心要到其他点的最远距离最小，所以 $v$ 不是树的中心。 综上，$mid$ 是树的中心。证毕。 问题就转化为了如何求树的直径的中点。 对于删边操作，可以发现只有删原树直径上的边才有意义，因为删其他边直径没有变。 所以从直径一端出发到另一端依次删除边。但是每次都要遍历整棵树求直径中点，时间复杂度还是没有变，考虑优化。 以下只针对删边后的两颗树中的一个分析，另一个同理。 结论二：对于一颗分割出来的树，它直径的一端一定是原树直径的一端。 证明： 反证法，如图， 删边后得到了以 $C$ 为根的子树，假设 $EF$ 该树的直径，说明 $\\text{dis}(E,F)&gt;\\text{dis}(A,B)$，$\\text{dis}(E,F)+\\text{dis}(B,E)&gt;\\text{dis}(A,B)$，则 $FD$ 比 $AD$ 更长，与 $AD$ 是原树直径矛盾，该假设不成立，所以 $A$ 一定是删边后树的直径的一端。证毕。 考虑如何快速维护删边后树的直径： （图片来自getchar123的题解） （橙色为截掉的边，绿色为直径，右图紫色的点为重复遍历的点，红色为新遍历的点） 在遍历删边的过程中，如果每次都遍历整棵树，会有大量重复节点（紫色点），根据结论二，我们只需要考虑经过新加进来的 原树直径上的点 能否得到更长的路径。 即从 $10$ 号点出发遍历红色点，找到最长路径，加上 $\\text{dis}(1,10)$，与原来的直径比较。 这样每次都只需要遍历新加进来的节点，维护直径的总时间复杂度优化到了 $O(n)$。 但是每次维护直径中点都要遍历一遍直径，时间复杂度还是 $O(n^2)$，继续优化。 结论三：对于分割出来的树，它的直径中点一定在原树直径上。 证明： 如图，删边后的树的直径一定是形如这个样子， 分割出来的树的直径和原树的直径的重叠部分一定大于非重叠部分，即 $\\text{dis}(A,B)&gt;\\text{dis}(E,B)$，如果不是，则路径 $ED$ 就会比原树直径还长。 根据直径中点的定义，中点一定在路径 $AB$ 上。证毕。 可以发现删边过程中，分割出来的树的直径是不下降的，新树和原树的重叠部分也是不下降的。 所以每次只需要从上一次的中点开始，在原树直径上向后遍历，直到当前点比上一个点劣时停止（再往后只会更劣）。维护中点的总时间复杂度为 $O(n)$。 综上，该算法的时间复杂度为 $O(n)$。 这里只维护了分割出来的其中一棵树，对于另一棵树可以倒过来重复这些操作。 代码#include &lt;bits/stdc++.h&gt; using namespace std; const int mn=5e3+7; struct node &#123; int mid,len_L,len_R; //分别是中点，直径，半径（中点到其他点的最远距离） &#125;ans[3][mn]; int tt=0,fr[mn],nx[mn*2],to[mn*2],w[mn*2]; int rt=1,rt2=1,maxlen=0,d[mn],mx=0; int q[mn],top=0; //存直径上所有点 bool vis[mn]; void add(int x,int y,int v) &#123; ++tt; nx[tt]=fr[x]; fr[x]=tt; to[tt]=y; w[tt]=v; &#125; void findrt(int x,int fa,int dis) &#123; if(dis&gt;maxlen) maxlen=dis,rt=x; for(int i=fr[x];i;i=nx[i]) if(to[i]!=fa) findrt(to[i],x,dis+w[i]); &#125; void findrt2(int x,int fa,int dis) &#123; d[x]=dis; if(dis&gt;maxlen) maxlen=dis,rt2=x; for(int i=fr[x];i;i=nx[i]) if(to[i]!=fa) findrt2(to[i],x,dis+w[i]); &#125; void deep(int x,int fa,int dis) &#123; d[x]=dis; for(int i=fr[x];i;i=nx[i]) if(to[i]!=fa) deep(to[i],x,dis+w[i]); &#125; bool dfs(int x,int fa,int dis) &#123; q[++top]=x; if(x==rt2) return 1; for(int i=fr[x];i;i=nx[i]) &#123; int y=to[i]; if(y==fa) continue; bool flag=dfs(y,x,dis+w[i]); if(flag) return 1; &#125; --top; return 0; &#125; void dfs2(int x,int dis) &#123; vis[x]=1; mx=max(mx,dis); for(int i=fr[x];i;i=nx[i]) &#123; int y=to[i]; if(vis[y]) continue; dfs2(y,dis+w[i]); &#125; &#125; void sol(int k) &#123; memset(vis,0,sizeof(vis)); for(int i=1;i&lt;=top;++i) vis[q[i]]=1; int mid=1,len_L=0,len_R=0; ans[k][1]=(node)&#123;mid,len_L,len_R&#125;; for(int i=2;i&lt;top;++i) &#123; mx=0; dfs2(q[i],0); //遍历新加进来的节点 if(d[q[i]]-d[q[1]]+mx&lt;=len_L) ans[k][i]=(node)&#123;mid,len_L,len_R&#125;; else &#123; len_L=d[q[i]]-d[q[1]]+mx; len_R=max(d[q[mid]]-d[q[1]],len_L-d[q[mid]]-d[q[1]]); for(int j=mid+1;j&lt;=i;++j) &#123; int dis=max(d[q[j]]-d[q[1]],len_L-d[q[j]]-d[q[1]]); if(dis&gt;len_R) break; //这里就直接跳出，后面只会更劣 len_R=dis;mid=j; &#125; ans[k][i]=(node)&#123;mid,len_L,len_R&#125;; &#125; &#125; &#125; int main() &#123; int n; cin&gt;&gt;n; for(int i=1;i&lt;n;++i) &#123; int x,y,v; scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;v); add(x,y,v); add(y,x,v); &#125; findrt(1,0,0); //找直径一端 maxlen=0; findrt2(rt,0,0); //找另一端 maxlen=0; dfs(rt,0,0); //存直径 sol(1); /***************以下为倒过来处理另一棵树***************/ memset(d,0,sizeof(d)); top=0; swap(rt,rt2); deep(rt,0,0); //根变了，深度也要重新求 dfs(rt,0,0); sol(2); int ANS=1e9; for(int i=1;i&lt;top;++i) ANS=min(ANS,max(d[q[i+1]]-d[q[i]]+ans[2][i].len_R+ans[1][top-i].len_R,max(ans[2][i].len_L,ans[1][top-i].len_L))); cout&lt;&lt;ANS; return 0; &#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://a154051.gitee.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"树","slug":"树","permalink":"https://a154051.gitee.io/tags/%E6%A0%91/"}],"author":154051},{"title":"【题解】P4248 [AHOI2013]差异","slug":"solution-P4248-cha-yi","date":"2021-07-17T11:49:52.000Z","updated":"2021-09-25T08:40:26.108Z","comments":true,"path":"2021/07/17/solution-P4248-cha-yi/","link":"","permalink":"https://a154051.gitee.io/2021/07/17/solution-P4248-cha-yi/","excerpt":"","text":"题意给一个长度为 $n$ 的字符串，求 \\sum\\limits_{1\\le i","categories":[{"name":"题解","slug":"题解","permalink":"https://a154051.gitee.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"https://a154051.gitee.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"后缀自动机,SAM","slug":"后缀自动机-SAM","permalink":"https://a154051.gitee.io/tags/%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA-SAM/"}],"author":154051},{"title":"焦作一中集训记","slug":"ji-xun-ji","date":"2021-05-15T08:49:31.000Z","updated":"2021-09-01T12:40:49.000Z","comments":true,"path":"2021/05/15/ji-xun-ji/","link":"","permalink":"https://a154051.gitee.io/2021/05/15/ji-xun-ji/","excerpt":"","text":"Day -14月23，老师打来电话说明天让我们三个高一的（另外两个是 zyz，wyd）去焦作一中集训两周。又可以逃两周文化课了 Day 04.24 中午到焦作，吃完饭就直接去学校了。 学校里有一个很大的湖，但是没有水，不知道干啥的。 一到机房就感受到了一股大佬气息，不仅有河南的，还有山西的，而且都是省队大佬，只有我们三个高一的没进队。 下午去吃饭，有两个食堂，一号食堂比较远，二号食堂近，但是去二号食堂就要横穿湖底（幸好没有水），不然就要绕一段路。 到食堂真把我惊了，有蒸饺，灌汤包，胡辣汤，油条（这里点名批评XCGZ，胡辣汤没有油条就失去了灵魂），最离谱的是这里居然有奶茶店，而且这里的汉堡和外面卖的汉堡基本一样（再次点名XCGZ）。 吃完饭去一号食堂买东西（中途迷路了，瞎转了半天），这里和二号食堂差不多，但多了个商店，还有个面包店。 吃完饭回机房。晚上8点打了场AtCoder的比赛，这还是我第一次打AT的比赛。 晚上9点40打完了，前3道是送分题，都A了，然后就做不动了，但是和我一起来的 wyd 大佬把第4题也切了，Orz 晚上回酒店睡觉。 Day 1 ~ 54.25 ~ 4.29 上午打模拟赛。除了27号，那天要学毒瘤的块状链表，调这道毒瘤题调了一下午。 下午就是刷题，写总结，瞎搞博客。 29号晚上打了cf(Codeforces)的比赛，从 22:35 到 0:35，阴间比赛名不虚传。 晚上回酒店 看番/玩死亡细胞。 Day 64.30 今天没有模拟赛，上午没写题，水了一上午。 下午写线段树二分，这时老师过来说今天下午 4:00 放学，明天上午放假。我直接原地起飞，没想到居然有假期，这要是在XCGZ上竞赛，连1秒钟的假期都不会有。 回到酒店开始玩死亡细胞，在我炉火纯青的SL大法下，成功无伤收藏家，拿到了白王皮肤。 Day 75.1 上午睡到8点，起来后看番，中午吃完饭就去学校了。 下午写题。晚上打AtCoder，先切了前两题，第三题用模拟退火乱搞过去了，第四题快打完了但时间到了，这次打得还不错。 Day 85.2 上午和他们这的高一打noip模拟赛，难度比之前低不少，结果我直接当场爆零，详细请看这篇文章 晚上又打cf的阴间比赛，这次直接打到了1:35。第一次在学校待这么晚，回酒店已经2点了。 Day 9 ~ 115.3 ~ 5.5 上午模拟赛，下午 刷题/优化博客。 晚上回去拉着 wyd 重温命运石之门。 Day 125.6 金牌神仙 ${\\color{black} l}{\\color{red} c}{\\color{red} h}$ 来讲课，全程懵逼 这是给人写的题？？？我还是太菜了 {\\color{black} l}{\\color{red} c}{\\color{red} h} \\ yyds!!!晚上看完了命运石之门，果然是神作，不管多少遍都那么好看。 Day 135.8 上午还是讲课。下午头晕，发烧了，5点就先回去了。然后睡到9点多，烧退了，但还是反胃，老师过来说明天回去。 Day 145.9 上午起来好多了，收拾了一下东西。中午坐火车回去，明天就要回班上课了。 停课近3个月，6月份还要期末考试，《论如何1个月赶完4个月的课程》，我太难了，不想上文化课。 后记这次集训真是各种被吊打，让我见识到了省队大佬原来是这么强。我还是太菜了，还有很长的路要走。 总的来说，就一句话","categories":[{"name":"游记","slug":"游记","permalink":"https://a154051.gitee.io/categories/%E6%B8%B8%E8%AE%B0/"}],"tags":[{"name":"集训","slug":"集训","permalink":"https://a154051.gitee.io/tags/%E9%9B%86%E8%AE%AD/"}],"author":154051},{"title":"5.2模拟赛总结","slug":"5-2-mo-ni-sai-zong-jie","date":"2021-05-02T10:33:00.000Z","updated":"2021-09-01T12:40:49.000Z","comments":true,"path":"2021/05/02/5-2-mo-ni-sai-zong-jie/","link":"","permalink":"https://a154051.gitee.io/2021/05/02/5-2-mo-ni-sai-zong-jie/","excerpt":"","text":"T1看完题手算了几组样例，找了找规律，先写了前4档，想到了树状数组，但没写，先写后面了。 T2先打了暴力，想了想似乎可以存每个字符出现的次数然后转移到下个状态，但是打起来比较麻烦，就暂时放弃。 T3推了一遍样例，想到一个贪心，打完过了样例，就不管了。 T4第一眼看上去不太可做，再想想发现能推出来第一档分的公式，但时间不够了，最后没写出来。 赛后T1判断区间长度是奇数还是偶数的时候我写了 if((r-l+1)&amp;1==0)，但是 &amp; 的优先级比 == 低，所以用这个式子判断的长度永远是奇数，但是样例里区间长度都是奇数，而且我也没有造其他数据，于是就拿到了0分的好成绩。 T2暴力打错了，T3贪心写假了。 全 部 木 大 这个故事告诉我们考试时一定要对拍，就算不对拍也要造几组数据，不然会有爆蛋的风险。","categories":[{"name":"总结","slug":"总结","permalink":"https://a154051.gitee.io/categories/%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"模拟赛","slug":"模拟赛","permalink":"https://a154051.gitee.io/tags/%E6%A8%A1%E6%8B%9F%E8%B5%9B/"}],"author":154051},{"title":"4.29模拟赛总结","slug":"4-29-mo-ni-sai-zong-jie","date":"2021-04-29T12:25:48.000Z","updated":"2021-09-01T12:40:49.000Z","comments":true,"path":"2021/04/29/4-29-mo-ni-sai-zong-jie/","link":"","permalink":"https://a154051.gitee.io/2021/04/29/4-29-mo-ni-sai-zong-jie/","excerpt":"","text":"T1读完题后发现整张图是个 DAG，可以拓扑排序+DP，应该能过6个点。 T2一开始想到了容斥，推了半天没推出来，就放弃了，打了个 $O(m^n)$ 的暴力，能拿 30分。 T3先打了个暴力，然而只有10分。 有20分是一条链，想到了分块的做法。修改操作整块打标记，散块暴力修改，查询就整块跳，如果整个块都是可行就累加上，有不可行的就停止直接暴力扫。虽然想出来了但是细节巨多，最后没有调出来。 总结最后20分没拿到有点亏。算法能力有待提升，比如线段树二分之前就不知道。","categories":[{"name":"总结","slug":"总结","permalink":"https://a154051.gitee.io/categories/%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"模拟赛","slug":"模拟赛","permalink":"https://a154051.gitee.io/tags/%E6%A8%A1%E6%8B%9F%E8%B5%9B/"}],"author":154051},{"title":"4.28模拟赛总结","slug":"4-28-mo-ni-sai-zong-jie","date":"2021-04-28T08:32:48.000Z","updated":"2021-09-01T12:40:49.000Z","comments":true,"path":"2021/04/28/4-28-mo-ni-sai-zong-jie/","link":"","permalink":"https://a154051.gitee.io/2021/04/28/4-28-mo-ni-sai-zong-jie/","excerpt":"","text":"T1先看题，眼瞎没看见“间接”，先打了个（自以为）30分的暴力。写完其他题后，又回来打了个莫队。调完拍完后以为能 A，然后赛后就完美地爆零了。 T2看完题后想了个DP，推的时候发现假了，然后没思路了，就先看下一题。 赛后才发现还能枚举所有情况，这种最暴力的方法居然没想到。 T3看到题，打了个20分暴力，然后想到了40分的做法，但先回去打 T1 了，后来没时间就放弃了。 总结一定要仔细看题！！！ T1 看错题结果浪费了很多时间，其他题能拿的分也没拿到，亏死。","categories":[{"name":"总结","slug":"总结","permalink":"https://a154051.gitee.io/categories/%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"模拟赛","slug":"模拟赛","permalink":"https://a154051.gitee.io/tags/%E6%A8%A1%E6%8B%9F%E8%B5%9B/"}],"author":154051},{"title":"4.26模拟赛总结","slug":"4-26-mo-ni-sai-zong-jie","date":"2021-04-26T05:54:44.000Z","updated":"2021-09-01T12:40:49.000Z","comments":true,"path":"2021/04/26/4-26-mo-ni-sai-zong-jie/","link":"","permalink":"https://a154051.gitee.io/2021/04/26/4-26-mo-ni-sai-zong-jie/","excerpt":"","text":"T1第一眼看像个DP，看了看数据范围，发现前5个点都能DP无脑写，就先打了个DP。 又想了想觉得与组合数有关，$m$ 和 $w$ 都很小，可以分成有限制和没有限制两部分算，有限制的DP，没限制的可以用隔板法组合数算。 但推到这发现我居然不知道组合数的公式，试着推了一下但没推出来，就弃疗了。 T2先打了个暴力把前3个点过了，看数据范围发现有3个点 $c$ 是从小到大给的，想了一会觉得莫队加LCT应该能过这3个点，但是码量太大就先扔这了。 T3看一会没啥思路，就打了个模拟，先过了前3个点，还有三个特殊的点应该能拿，然后想了个假做法（当时不知道），写完调完后考试快结束了，就放弃T2，检查一下交了。 总结这次真是吃了数学的亏，知道组合数公式的话T1就A了。 写得要再快一点，这样就能把T2的另外30分也拿了。","categories":[{"name":"总结","slug":"总结","permalink":"https://a154051.gitee.io/categories/%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"模拟赛","slug":"模拟赛","permalink":"https://a154051.gitee.io/tags/%E6%A8%A1%E6%8B%9F%E8%B5%9B/"}],"author":154051},{"title":"4.25模拟赛总结","slug":"4-25-mo-ni-sai-zong-jie","date":"2021-04-25T13:20:14.000Z","updated":"2021-09-01T12:40:49.000Z","comments":true,"path":"2021/04/25/4-25-mo-ni-sai-zong-jie/","link":"","permalink":"https://a154051.gitee.io/2021/04/25/4-25-mo-ni-sai-zong-jie/","excerpt":"","text":"T1开题看到期望有点慌，因为期望的题我做的不多。 读完题后直接懵逼，没搞懂那个正面朝上的概率 $p$ 为什么那么大，样例也算不出来，就弃了。 T2看了一会想到一个贪心，就先打了出来，过了前3个点，剩下的想不出来了，就先扔这。 T3没啥思路，就打了个暴搜，也不知道能不能过前两个点。然后把每道题又想了一遍，还是没啥思路。 总结T1没拿到分就很亏，做的题还是太少了，期望要多写写，思维题也要多练。","categories":[{"name":"总结","slug":"总结","permalink":"https://a154051.gitee.io/categories/%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"模拟赛","slug":"模拟赛","permalink":"https://a154051.gitee.io/tags/%E6%A8%A1%E6%8B%9F%E8%B5%9B/"}],"author":154051},{"title":"【题解】P2472 [SCOI2007]蜥蜴","slug":"solution-P2472-xi-yi","date":"2021-03-05T08:36:55.000Z","updated":"2021-09-01T12:40:49.000Z","comments":true,"path":"2021/03/05/solution-P2472-xi-yi/","link":"","permalink":"https://a154051.gitee.io/2021/03/05/solution-P2472-xi-yi/","excerpt":"","text":"P2472 [SCOI2007]蜥蜴 网络瘤，毒瘤的瘤。 蒟蒻第一次不看题解写出来网络瘤（然而还是逃不过debug半天的命运）。 题意在 $r\\times c$ 的网格中，每个格子都有高度，高度为 $0$ 则不存在，一些格子上有蜥蜴，蜥蜴可以跳到直线距离不超过 $d$ 的格子上，每跳一次，原来的格子高度就会减一，求最少有几只蜥蜴不能逃离。 分析显然，每个格子跳了一定次数后就不能再跳了，那么如何在网络流中加入这个限制呢？ 假设原来的点编号为 $i$，高度为 $h$，总共 $n$ 个点，我们可以把这个点拆成两个，编号为 $i$ 和 $i+n$，$i$ 负责原来这个点的入边，$i+n$ 负责出边，再连一条从 $i$ 到 $i+n$ 容量为 $h$ 的边，如图： 这个思想类似于最小割点问题。 建图注：以下说的点都是高度大于 $0$ 的点，高度为 $0$ 的点直接忽略。 对于每个点都将其拆为入点和出点，容量为格子高度。 对于能跳出网格的点，从它的出点到汇点连一条容量无穷大的边。 对于有蜥蜴的点，从源点到它的入点连一条容量为 $1$ 的边（因为每个点上最多有 $1$ 个蜥蜴）。 其中，源点和汇点都是原图中不存在的，需要另外新建。 最后跑最大流，得到最多能逃离的蜥蜴数，用蜥蜴总数减去最大流即为所求答案。 代码#include &lt;bits/stdc++.h&gt; using namespace std; const int mn=407,inf=1e7; struct node&#123; int x,y; &#125;; vector&lt;node&gt; p; int n,m,d,tot=0,num[27][27],q[2*mn],dep[2*mn]; int fr[2*mn],fr2[2*mn],nx[100*mn],to[100*mn],val[100*mn],tt=1; void add(int x,int y,int w) &#123; ++tt; nx[tt]=fr[x]; fr[x]=tt; to[tt]=y; val[tt]=w; &#125; bool bfs() &#123; for(int i=0;i&lt;=n*m*2+1;++i) dep[i]=0,fr2[i]=fr[i]; //0 为源点，2*n*m+1 为汇点 int h=1,t=1; q[1]=0;dep[0]=1; while(h&lt;=t) &#123; int u=q[h]; for(int i=fr[u];i;i=nx[i]) &#123; int v=to[i]; if(dep[v]||!val[i]) continue; q[++t]=v; dep[v]=dep[u]+1; if(v==n*m*2+1) return 1; &#125; ++h; &#125; return 0; &#125; int dfs(int u,int in) &#123; if(u==n*m*2+1) return in; int out=0; for(int &amp;i=fr2[u];i;i=nx[i]) //当前弧优化，i 是引用，当 i 变化时 fr2 也会跟着变化 &#123; int v=to[i]; if(dep[u]==dep[v]-1&amp;&amp;val[i]) &#123; int rs=dfs(v,val[i]&lt;in?val[i]:in); val[i]-=rs;val[i^1]+=rs; out+=rs;in-=rs; if(!in) break; &#125; &#125; if(out==0) dep[u]=0; return out; &#125; inline int dist(node v0,node v1)&#123;return (v0.x-v1.x)*(v0.x-v1.x)+(v0.y-v1.y)*(v0.y-v1.y);&#125; //求两点的直线距离 int main() &#123; scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;d); for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=m;++j) &#123; num[i][j]=++tot; int x; scanf(&quot;%1d&quot;,&amp;x); if(x==0) continue; add(num[i][j],num[i][j]+n*m,x); //拆点 add(num[i][j]+n*m,num[i][j],0); p.push_back((node)&#123;i,j&#125;); if(i-d&lt;1||j-d&lt;1||i+d&gt;n||j+d&gt;m) add(num[i][j]+n*m,2*n*m+1,inf),add(2*n*m+1,num[i][j]+n*m,0); //连汇点 &#125; for(int i=0;i&lt;p.size()-1;++i) //建图 for(int j=i+1;j&lt;p.size();++j) &#123; if(dist(p[i],p[j])&gt;d*d) continue; node v0=p[i],v1=p[j]; add(num[v0.x][v0.y]+n*m,num[v1.x][v1.y],inf); add(num[v1.x][v1.y],num[v0.x][v0.y]+n*m,0); add(num[v1.x][v1.y]+n*m,num[v0.x][v0.y],inf); add(num[v0.x][v0.y],num[v1.x][v1.y]+n*m,0); &#125; int cnt=0; for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=m;++j) &#123; char ch=getchar(); while(ch!=&#39;.&#39;&amp;&amp;ch!=&#39;L&#39;) ch=getchar(); if(ch==&#39;L&#39;) ++cnt,add(0,num[i][j],1),add(num[i][j],0,0); //连源点 &#125; int ans=0; while(bfs()) ans+=dfs(0,inf); cout&lt;&lt;cnt-ans; return 0; &#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://a154051.gitee.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"洛谷","slug":"洛谷","permalink":"https://a154051.gitee.io/tags/%E6%B4%9B%E8%B0%B7/"},{"name":"网络流","slug":"网络流","permalink":"https://a154051.gitee.io/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"}],"author":154051},{"title":"【题解】P2467 [SDOI2010]地精部落","slug":"solution-P2467-bu-luo","date":"2021-03-03T13:40:32.000Z","updated":"2021-09-01T12:40:49.000Z","comments":true,"path":"2021/03/03/solution-P2467-bu-luo/","link":"","permalink":"https://a154051.gitee.io/2021/03/03/solution-P2467-bu-luo/","excerpt":"","text":"P2467 [SDOI2010]地精部落 题意给 $n$ 座高度连续的山脉，即高度为 $1,2,3,···,n$，求有几种方案使得山脉的高度一高一低或一低一高（即波动数列）。答案对 $p$ 取模。 分析显然，若要求 $k$ 座山脉的波动数列，无论它们的高度是否连续，只要高度互不相同，方案数都是一样的。 举个例子：求 $3$ 座山脉的波动数列，$(1,2,3)$ 和 $(1,3,5)$ 和 $(15,40,51)$的方案数都是一样的。 定义 $f(i,j,0)$ 表示前 $i$ 座山脉中，排名为 $j$ 的山脉放在最后面并且是山谷的方案数（$1$ 表示是山峰）。则最后答案为 $\\sum_{j=1}^{n} f(n,j,0)+f(n,j,1)$。 若 $j$ 是山谷，则方案为剩下的 $i-1$ 座山脉中排名从 $j$ 到 $i-1$ 的山脉放后面并且做山峰的方案之和。$j$ 是山峰也同理。 所以有状态转移方程： f(i,j,1)=\\sum\\limits_{k=1}^{j-1}f(i-1,k,0)f(i,j,0)=\\sum\\limits_{k=j}^{i-1}f(i-1,k,1)时间复杂度为 $O(n^3)$，会超时。 可以发现最里面一层循环可以用前缀和优化。 定义 $sum0(i,j)=\\sum\\limits_{x=1}^{j}f(i,x,0)$，$sum1(i,j)$ 同理，则原转移方程可化为： f(i,j,1)=sum0(i-1,j-1)f(i,j,0)=sum1(i-1,i-1)-sum1(i-1,j-1)时间复杂度为 $O(n^2)$。 因为 $f$ 和 $sum$ 只用到了当前一层和上一层，所以只存这两层就好，空间复杂度为 $O(n)$。 代码#include &lt;bits/stdc++.h&gt; using namespace std; const int mn=4207; long long f[mn][2],sum0[2][mn],sum1[2][mn]; int main() &#123; int n,p; scanf(&quot;%d%d&quot;,&amp;n,&amp;p); f[1][1]=f[1][0]=sum0[1][1]=sum1[1][1]=1; for(int i=2;i&lt;=n;++i) &#123; int now=i&amp;1; //now为当前层，now^1为上一层。这里相当于 now=i%2 for(int j=1;j&lt;=i;++j) &#123; f[j][1]=sum0[now^1][j-1]; f[j][0]=(sum1[now^1][i-1]-sum1[now^1][j-1])%p; while(f[j][0]&lt;0) f[j][0]+=p; //避免取模后相减变为负数 sum0[now][j]=(sum0[now][j-1]+f[j][0])%p; sum1[now][j]=(sum1[now][j-1]+f[j][1])%p; &#125; &#125; long long ans=0; for(int i=1;i&lt;=n;++i) ans=((ans+f[i][0])%p+f[i][1])%p; cout&lt;&lt;ans; &#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://a154051.gitee.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"洛谷","slug":"洛谷","permalink":"https://a154051.gitee.io/tags/%E6%B4%9B%E8%B0%B7/"},{"name":"DP","slug":"DP","permalink":"https://a154051.gitee.io/tags/DP/"}],"author":154051},{"title":"【题解】P6394樱花，还有你","slug":"solution-P6394-ying-hua","date":"2021-02-27T03:14:00.000Z","updated":"2021-09-01T12:40:49.000Z","comments":true,"path":"2021/02/27/solution-P6394-ying-hua/","link":"","permalink":"https://a154051.gitee.io/2021/02/27/solution-P6394-ying-hua/","excerpt":"","text":"P6394 樱花，还有你 题面好浪漫，可惜我是11月11日写的这题。 题意有 $k$ 棵树，每棵树上有 $s_i$ 朵花，有几种方案能恰好取 $n$ 朵花，若收集不到 $n$ 朵花，输出impossible。 注意：用 $(a_1,a_2,⋯)$ 表示一种方案，则 $(1,1,1)$ 和 $(1,1,1,0)$ 是两种不同的方案。 分析Subtask 1$\\sum s_i&lt;n$ 白给，直接输出impossible即可。 Subtask 2&amp;3$n,k \\le 5\\times10^2$ 定义 $f(i,j)$ 表示前 $i$ 棵树收集 $j$ 朵花的方案数。 显然有状态转移方程： f(i,j)=\\sum\\limits_{x=0}^{\\min(j,s_i)}f(i-1,j-x)最终答案为 $\\sum_{i=1}^{k}f(i,n)$。 时间复杂度：$O(n^2k)$，空间复杂度：$O(nk)$。 Subtask 4$n,k \\le 5\\times10^3$ $O(n^2k)$ 的复杂度会超时，需要优化。 发现可以用前缀和优化掉最里面一层循环。 定义 $sum(i,j)=\\sum_{x=0}^j f(i,x)$。 所以 f(i,j)=sum(i-1,j)-sum(i-1,j-\\min(j,s_i)-1)为了避免数组下标为负数，应改为 f(i,j)=sum(i-1,j)-sum(i-1,j-\\min(j,s_i))+f(i-1,j-\\min(j,s_i)时间复杂度：$O(nk)$。 这时候发现无耻出题人只给了 $64MB$，内存会炸。 观察上述转移方程，发现 $f$ 数组和 $sum$ 数组只用到了这一层和上一层，所以只存这两层就好。 空间复杂度：$O(n)$。 代码#include &lt;bits/stdc++.h&gt; using namespace std; const int mn=5e3+7,mod=10086001; int s[mn],f[2][mn],sum[2][mn]; int now; //now为当前这一层，now^1为上一层 int min1(int x,int y) &#123; return x&lt;y?x:y; &#125; int main() &#123; int n,k,cnt=0; cin&gt;&gt;n&gt;&gt;k; f[0][0]=sum[0][0]=f[1][0]=sum[1][0]=1; for(int i=1;i&lt;=k;++i) scanf(&quot;%d&quot;,&amp;s[i]),cnt+=s[i]; if(cnt&lt;n) &#123; cout&lt;&lt;&quot;impossible&quot;; return 0; &#125; int ans=0; for(int i=1;i&lt;=k;++i) &#123; now=i&amp;1; //相当于now=i%2 for(int j=1;j&lt;=n;++j) &#123; sum[now^1][j]=(sum[now^1][j-1]+f[now^1][j])%mod; f[now][j]=(sum[now^1][j]-sum[now^1][j-min1(j,s[i])]+f[now^1][j-min1(j,s[i])])%mod; while(f[now][j]&lt;0) f[now][j]+=mod; //取模后相减有可能出现负数 &#125; ans=(ans+f[now][n])%mod; &#125; cout&lt;&lt;ans; return 0; &#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://a154051.gitee.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"洛谷","slug":"洛谷","permalink":"https://a154051.gitee.io/tags/%E6%B4%9B%E8%B0%B7/"},{"name":"DP","slug":"DP","permalink":"https://a154051.gitee.io/tags/DP/"}],"author":154051},{"title":"【学习笔记】模拟退火算法","slug":"mo-ni-tui-huo-bi-ji","date":"2021-02-08T11:40:00.000Z","updated":"2021-09-01T12:40:49.000Z","comments":true,"path":"2021/02/08/mo-ni-tui-huo-bi-ji/","link":"","permalink":"https://a154051.gitee.io/2021/02/08/mo-ni-tui-huo-bi-ji/","excerpt":"","text":"简介模拟退火(Simulated Annealing，SA)是一种随机化算法。它适用于解决方案量极大的问题，如旅行商问题，求解多峰函数极值等问题。 原理 模拟退火算法来源于固体退火原理，是一种基于概率的算法，将固体加温至充分高，再让其徐徐冷却，加温时，固体内部粒子随温升变为无序状，内能增大，而徐徐冷却时粒子渐趋有序，在每个温度都达到平衡态，最后在常温时达到基态，内能减为最小。 ——百度百科 把问题看作固体内部粒子，把最优解看作平衡态，用程序模拟退火的过程，就是模拟退火算法。 过程模拟退火中有三个参数，分别是初始温度 $T_0$、降温系数 $\\Delta$。其中，$\\Delta$ 是一个略小于 $1$ 的数。 令温度 $T=T_0$，然后每次降温时 $T=T*\\Delta$，直到 $T=0$。 在每次降温过程中，都要用当前解产生一个新解，即 $x_1=x_0+\\Delta x$。其中，$\\Delta x \\in R$ 并且 $\\left\\vert \\Delta x\\right\\vert \\propto T$，表示解的变动值，温度越低，它的变化幅度越小，产生的新解也会越来越趋近于最优解，如图， 这时候我们需要考虑是否用新解替换当前解，定义当前温度为 $T$，某个解 $x$ 的贡献为 $f(x)$（这里的贡献不是指大小，而是这个解的优劣），则修改当前解的概率为 P=\\begin{cases}1&f(x_1)\\geqslant f(x_0)\\\\e^\\frac{-\\left\\vert f(x_1)-f(x_0)\\right\\vert}{T}&f(x_1)","categories":[{"name":"笔记","slug":"笔记","permalink":"https://a154051.gitee.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"模拟退火","slug":"模拟退火","permalink":"https://a154051.gitee.io/tags/%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB/"}],"author":154051},{"title":"test","slug":"test","date":"2020-12-20T08:40:00.000Z","updated":"2021-09-01T12:40:49.000Z","comments":true,"path":"2020/12/20/test/","link":"","permalink":"https://a154051.gitee.io/2020/12/20/test/","excerpt":"","text":"隐藏内容的标题 表情示例（喝水）&lt;img class=&quot;emoji-coda&quot; src=&quot;https://cdn.jsdelivr.net/gh/TomoriCoda/hexo-tag-emojis-bycoda/emojis/2233/heshui.png&quot;&gt; 表情示例（喝水） lim_{1\\to+\\infty}P(|\\frac{1}{n}\\sum_i^nX_i-\\mu|","categories":[{"name":"测试","slug":"测试","permalink":"https://a154051.gitee.io/categories/%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"code","slug":"code","permalink":"https://a154051.gitee.io/tags/code/"},{"name":"latex","slug":"latex","permalink":"https://a154051.gitee.io/tags/latex/"}],"author":154051},{"title":"Hello World","slug":"hello-world","date":"2020-12-06T14:12:00.000Z","updated":"2021-09-01T12:40:49.000Z","comments":true,"path":"2020/12/06/hello-world/","link":"","permalink":"https://a154051.gitee.io/2020/12/06/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new &quot;My New Post&quot; More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","categories":[],"tags":[],"author":154051}],"categories":[{"name":"题解","slug":"题解","permalink":"https://a154051.gitee.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"游记","slug":"游记","permalink":"https://a154051.gitee.io/categories/%E6%B8%B8%E8%AE%B0/"},{"name":"总结","slug":"总结","permalink":"https://a154051.gitee.io/categories/%E6%80%BB%E7%BB%93/"},{"name":"笔记","slug":"笔记","permalink":"https://a154051.gitee.io/categories/%E7%AC%94%E8%AE%B0/"},{"name":"测试","slug":"测试","permalink":"https://a154051.gitee.io/categories/%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"https://a154051.gitee.io/tags/%E8%B4%AA%E5%BF%83/"},{"name":"模拟退火","slug":"模拟退火","permalink":"https://a154051.gitee.io/tags/%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB/"},{"name":"树","slug":"树","permalink":"https://a154051.gitee.io/tags/%E6%A0%91/"},{"name":"字符串","slug":"字符串","permalink":"https://a154051.gitee.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"后缀自动机,SAM","slug":"后缀自动机-SAM","permalink":"https://a154051.gitee.io/tags/%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA-SAM/"},{"name":"集训","slug":"集训","permalink":"https://a154051.gitee.io/tags/%E9%9B%86%E8%AE%AD/"},{"name":"模拟赛","slug":"模拟赛","permalink":"https://a154051.gitee.io/tags/%E6%A8%A1%E6%8B%9F%E8%B5%9B/"},{"name":"洛谷","slug":"洛谷","permalink":"https://a154051.gitee.io/tags/%E6%B4%9B%E8%B0%B7/"},{"name":"网络流","slug":"网络流","permalink":"https://a154051.gitee.io/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"},{"name":"DP","slug":"DP","permalink":"https://a154051.gitee.io/tags/DP/"},{"name":"code","slug":"code","permalink":"https://a154051.gitee.io/tags/code/"},{"name":"latex","slug":"latex","permalink":"https://a154051.gitee.io/tags/latex/"}]}