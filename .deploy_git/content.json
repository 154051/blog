{"meta":{"title":"a154051","subtitle":"","description":"","author":"a154051","url":"https://a154051.gitee.io","root":"/"},"pages":[{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2021-09-29T13:40:23.000Z","comments":false,"path":"about/index.html","permalink":"https://a154051.gitee.io/about/index.html","excerpt":"","text":"[さくら荘のhojun] 与&nbsp; Mashiro&nbsp; （ 真（ま）白（しろ） ） 对话中... bot_ui_ini()"},{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2021-09-29T13:40:23.000Z","comments":false,"path":"bangumi/index.html","permalink":"https://a154051.gitee.io/bangumi/index.html","excerpt":"","text":""},{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2023-10-13T10:42:06.497Z","comments":false,"path":"client/index.html","permalink":"https://a154051.gitee.io/client/index.html","excerpt":"","text":"直接下载 or 扫码下载："},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2023-10-13T10:42:06.497Z","comments":true,"path":"comment/index.html","permalink":"https://a154051.gitee.io/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》"},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2021-09-29T13:40:23.000Z","comments":false,"path":"donate/index.html","permalink":"https://a154051.gitee.io/donate/index.html","excerpt":"","text":""},{"title":"游戏","date":"2021-03-09T09:00:00.000Z","updated":"2023-10-13T10:42:06.490Z","comments":false,"path":"games/index.html","permalink":"https://a154051.gitee.io/games/index.html","excerpt":"","text":"颓废区 请自行保存存档 2048 小黑屋 flappy bird 进化 生命游戏 生命游戏介绍好东西"},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2023-10-13T10:42:06.496Z","comments":false,"path":"lab/index.html","permalink":"https://a154051.gitee.io/lab/index.html","excerpt":"","text":"sakura主题balabala"},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2023-10-13T10:42:06.495Z","comments":true,"path":"links/index.html","permalink":"https://a154051.gitee.io/links/index.html","excerpt":"","text":""},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2023-10-13T10:42:06.495Z","comments":false,"path":"music/index.html","permalink":"https://a154051.gitee.io/music/index.html","excerpt":"","text":""},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2021-09-29T13:40:23.000Z","comments":true,"path":"rss/index.html","permalink":"https://a154051.gitee.io/rss/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-12-12T14:14:16.000Z","updated":"2023-11-09T02:59:24.215Z","comments":false,"path":"tags/index.html","permalink":"https://a154051.gitee.io/tags/index.html","excerpt":"","text":""},{"title":"关于","date":"2019-01-04T14:53:25.000Z","updated":"2023-12-11T09:29:37.872Z","comments":true,"path":"theme-sakura/index.html","permalink":"https://a154051.gitee.io/theme-sakura/index.html","excerpt":"","text":"退役OI人，随便写点东西。 QQ：2279162137 微信：m2279162137 Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro Hexo-Sakura主题 感谢ctz大佬写的教程，解决了很多问题。"},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2021-09-29T13:40:23.000Z","comments":false,"path":"video/index.html","permalink":"https://a154051.gitee.io/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }"}],"posts":[{"title":"【笔记】博弈论","slug":"note-bo-yi-lun","date":"2023-12-20T14:30:00.000Z","updated":"2023-12-21T16:10:35.940Z","comments":true,"path":"2023/12/20/note-bo-yi-lun/","link":"","permalink":"https://a154051.gitee.io/2023/12/20/note-bo-yi-lun/","excerpt":"","text":"「 我正是来访者，六轩岛上的第 18 个人类！！！」 「不好意思，就算迎来了汝，也是 17 人。」 —— 海猫鸣泣之时 博弈论主要分为公平组合游戏、非公平组合游戏、反常游戏。本文将讲解公平组合游戏。 公平组合游戏公平组合游戏（Impartial Game）的定义如下： 游戏有两个人参与，二者轮流做出决策，双方均知道游戏的完整信息； 任意一个游戏者在某一确定状态可以作出的决策集合只与当前的状态有关，而与游戏者无关； 游戏中的同一个状态不可能多次抵达，游戏以玩家无法行动为结束，且游戏一定会在有限步后以非平局结束。 有向图游戏是一个经典的公平组合游戏，它的定义如下： 在一个有向无环图中，只有一个起点，上面有一个棋子，两个玩家轮流沿着有向边推动棋子，不能走的玩家判负。 事实上，大部分公平组合游戏都可以转化为有向图游戏，将每一个游戏状态作为一个节点，若一个状态 $A$ 能够通过一次决策变为状态 $B$，则连边 $A\\to B$，称 $B$ 为 $A$ 的后继状态。下面都在有向图游戏的基础上讨论，以下的讨论都假设先后手都采取最优策略。 定义 必胜状态 为 先手在该状态下能够通过一系列决策获得胜利（即先手必胜）；必败状态 为 在该状态下无论先手怎么决策，后手都能够通过一系列决策获得胜利（即后手必胜）。 通过推理，我们可以得出下面三条定理： 定理 1：没有后继状态的状态是必败状态。 定理 2：一个状态是必胜状态当且仅当存在至少一个必败状态为它的后继状态。 定理 3：一个状态是必败状态当且仅当它的所有后继状态均为必胜状态。 SG 函数为了更准确地描述胜败状态，我们引入 SG 函数。 定义 $\\operatorname{mex}$ 函数为不属于集合 $S$ 的最小非负整数： \\operatorname{mex}\\{S\\}=\\min\\{x\\}\\quad (x\\notin S,x\\in N)例如 $\\operatorname{mex}\\{ 0,1,2,5,7 \\}=3$。 设状态 $x$ 有 $k$ 个后继状态 $y_1,y_2,\\dots,y_k$，则有： SG(x)=\\operatorname{mex}\\{SG(y_1),SG(y_2),\\dots,SG(y_k)\\}显然，一个状态为必败状态的充要条件为该状态的 SG 值为 $0$，必胜状态的充要条件为 SG 值不为 $0$。 假如只有一个游戏，SG 函数好像没什么用，因为我们只需要知道 SG 值是否为 $0$，而不需要知道具体数值，但如果有多个游戏，情况就不一样了。 考虑由两个有向图游戏组成的组合游戏，其中，这两个游戏相互独立，即其中任意一个游戏的任意决策都不会影响其他游戏。这个组合游戏的规则是每次要选择一个有向图游戏进行一次移动，最终无法移动的玩家失败。 定义一个有向图游戏的 SG 值为起点的 SG 值。设这两个游戏的起点分别为 $A,B$。下面我们先假设 SG 值只能降低，详细解释稍后再说。 显然当这两个游戏的 SG 值都为 $0$ 时为必败状态。 若 $SG(A)=0,SG(B)\\ne 0$，先手可以将 $B$ 移动到 SG 值为 $0$ 的后继状态（因为根据 SG 函数的定义，$B$ 的所有后继状态的 SG 集合包含所有比 $SG(B)$ 小的非负整数），此时为必败状态，因此原状态为必胜状态。 若 $SG(A)=SG(B)\\ne 0$，先手降低任意一个游戏的 SG 值，后手总是可以将另一个游戏的 SG 值降低到与之相等，直到两个游戏的 SG 值为 $0$，此时这个状态由先手拿到，因此后手必胜，原状态为必败状态。 若 $SG(A)\\ne SG(B),SG(A)\\ne 0,SG(B)\\ne 0$，先手只需将 SG 值较大的游戏降低到与另一个游戏相等，就回到了上面的状态，因此原状态为必胜状态。 在上面的讨论中，我们总是让 SG 值降低，事实上，一个状态还可能转移到 SG 值比它大的后继状态，如果一个玩家这样做，那么另一个玩家只需将该状态降回原来即可（SG 值大的总是可以降低为 SG 值小的），因此升高 SG 值是无用的。 SG 定理设 $A+B$ 表示两个相互独立的游戏组合而成的游戏，$\\oplus$ 表示异或。基于上面的讨论，我们发现当 $SG(A)\\oplus SG(B)=0$ 时，组合游戏为必败状态，即 $SG(A+B)=0$；当 $SG(A)\\oplus SG(B)\\ne 0$ 时，组合游戏为必胜状态，即 $SG(A+B)\\ne 0$。我们猜测 $SG(A+B)=SG(A)\\oplus SG(B)$，证明如下。 设 $C,D$ 分别表示 $A,B$ 的任意后继状态，即 $A\\to C,B\\to D$。则 $A+B$ 的局面要么移动 $A$，要么移动 $B$，即 $(A+B)\\to\\{C+B\\}\\cup \\{A+D\\}$。 由定义可得，$SG(A+B)=\\operatorname{mex}\\big\\{\\{SG(C+B)\\}\\cup \\{SG(A+D)\\}\\big\\}$。 考虑数学归纳法，对两个有向图进行拓扑排序，拓扑序最大的点为出度为 $0$ 的点。当 $A,B$ 都为拓扑序最大的点时，$SG(A+B)=SG(A)\\oplus SG(B)$ 显然成立。假设拓扑序比 $A,B$ 大的点都满足定理，则有 $SG(C+B)=SG(C)\\oplus SG(B),SG(A+D)=SG(A)\\oplus SG(D)$。 于是有 $SG(A+B)=\\operatorname{mex}\\big\\{\\{SG(C)\\oplus SG(B)\\}\\cup \\{SG(A)\\oplus SG(D)\\}\\big\\}$。下面将证明 $SG(A)\\oplus SG(B)$ 不属于右边两个集合的任何一个，但比它小的非负整数都属于右边两个集合的某一个。 因为 $A\\to C,B\\to D$，所以 $SG(A)\\ne SG(C),SG(B)\\ne SG(D)$，则 $SG(A)\\oplus SG(B)$ 不等于 $SG(C)\\oplus SG(B)$ 和 $SG(A)\\oplus SG(D)$。 设 $e$ 是比 $SG(A)\\oplus SG(B)$ 小的任意非负整数，$k=SG(A)\\oplus SG(B)\\oplus e$。令 $SG(A),SG(B),e$ 三者分别与 $k$ 异或，则至少有一者异或后会减小（因为 $k$ 的二进制最高位的 $1$ 一定来自这三者之一），但 $e\\oplus k=SG(A)\\oplus SG(B)&gt;e$，因此这一者不会是 $e$。不妨设这一者为 $SG(A)$，即 $SG(A)\\oplus k=SG(B)\\oplus e&lt;SG(A)$。由 $SG$ 函数的定义可知，$A$ 一定存在一个后继状态 $C^{‘}$，满足 $SG(C^{‘})=SG(B)\\oplus e$，则此时有 $SG(C^{‘})\\oplus SG(B)=e$，因此 $e$ 属于右边两个集合的某一个。原命题得证。 显然这个定理可以推广至多个游戏，设 $X$ 为 $n$ 个独立的有向图游戏的组合游戏，它们的起点分别为 $s_1,s_2,\\dots,s_n$，则有 $SG(X)=SG(s_1)\\oplus SG(s_2)\\oplus \\dots \\oplus SG(s_n)$。 经典模型博弈论中有很多经典的游戏，很多博弈都可以转化为这些游戏。 巴什博弈有一堆石子，数量为 $n$，两个人轮流拿石子，每个人每次至少拿 $1$ 个，至多拿 $m$ 个，最终拿完石子的人获胜。 设 $SG(k)$ 表示 $k$ 个石子的 SG 值，显然有 $SG(0)=0$， 当 $k\\le m$ 时，$k$ 可以转移到 $0$ 到 $k-1$ 任意一个局面，因此 $SG(k)=k,(k\\le m)$； 当 $k=m+1$ 时，可以转移到 $1$ 到 $m$ 任意一个局面，则 $SG(m+1)=0$； 当 $k=m+2$ 时，可以转移到 $2$ 到 $m+1$ 任意一个局面，则 $SG(m+2)=1\\dots\\dots$ 以此类推，可以得到 $SG(n)=n\\bmod (m+1)$。当且仅当 $(m+1) \\mid n$ 时先手必败，否则先手必胜。 Nim 游戏有 $n$ 堆石子，第 $i$ 堆有 $a_i$ 个石子，两个玩家轮流取走任意一堆的任意个石子，但不能不取，拿完石子的人获胜。 这 $n$ 堆石子相互独立，因此可以看作 $n$ 个独立的游戏。对于一堆有 $k$ 个石子的游戏，显然有 $SG(k)=k$。因此 Nim 游戏的 SG 值为 $a_i\\oplus a_2\\oplus \\dots \\oplus a_n$，称其为 Nim 和。 考虑先手必胜时要如何操作，当 Nim 和为 $k(k&gt;0)$ 时，设 $k$ 的二进制最高位的 $1$ 在第 $d$ 位，则一定存在 $a_i$ 满足其二进制第 $d$ 位为 $1$，于是 $a_i\\oplus k &lt;a_i$，因此只需将 $a_i$ 取到 $a_i\\oplus k$ 即可。 阶梯 Nim有 $n$ 堆石子，第 $i(i&gt;0)$ 堆有 $a_i$ 个石子，两人轮流操作，每人每次可以任选一个 $k(k&gt;0)$，将第 $k$ 堆石子中的任意个石子移动到第 $k-1$ 堆，第 $0$ 堆的石子无法移动，最后无法操作的人输。 结论：先手必败当且仅当奇数堆中的石子数异或和为 $0$。 证明：当奇数堆异或和为 $0$ 时，无论怎么移动都会使奇数堆的异或和大于 $0$。如果先手移动偶数堆的石子到奇数堆，后手可以将移动到奇数堆的石子再往下移动到偶数堆，异或和就变回了 $0$；如果先手移动奇数堆，可以看作两人在奇数堆上玩 Nim 游戏，所以后手可以通过移动奇数堆的石子使异或和变回 $0$。 综上，奇数堆异或和为 $0$ 的局面都由先手拿到，异或和不为 $0$ 的局面都由后手拿到。无法移动的局面为所有石子都在第 $0$ 堆，此时奇数堆的异或和为 $0$，因此该局面由先手拿到，故先手必败。 k-Nim有 $n$ 堆石子，第 $i$ 堆有 $a_i$ 个石子，每次可以从不超过 $k$ 堆中各取走任意个石子，不能操作的人输。 结论：设 $s_i$ 表示 $a_1,a_2\\dots ,a_n$ 二进制下第 $i$ 位 $1$ 的个数。则先手必败当且仅当对所有的 $s_i$，都有 $s_i\\equiv 0 \\pmod{(k+1)}$。 证明： 设 $s_i^{‘}=s_i\\bmod (k+1)$。 $a_i$ 全为 $0$ 时为必败状态，此时满足条件。 若所有的 $s_i^{‘}$ 为 $0$，由于最多选择 $k$ 堆，因此 $s_i$ 的变化量的绝对值不会超过 $k$，并且至少有一个 $s_i$ 产生变化，所以该操作结束后一定会使得某些 $s_i^{‘}$ 不为 $0$。 若 $s_i^{‘}$ 不全为 $0$，下面将证明一定存在一种合法的方案使得所有的 $s_i^{‘}$ 变回 $0$。 考虑数学归纳法，假设当前在二进制下的第 $i$ 位，满足对所有的 $j&gt;i$，$s_j^{‘}$ 都已经变为了 $0$，并且已经改变了 $m(m\\le k)$ 堆石子。 显然对于已经改变的 $m$ 堆石子，我们任意改变其二进制下第 $i$ 位的值都是合法的。设这 $m$ 堆石子的第 $i$ 位上有 $a$ 个 $1$ 和 $b$ 个 $0$。 下面分情况讨论， $a\\ge s_i^{‘}$，只需要从这 $a$ 个中选择 $s_i^{‘}$ 个将其变为 $0$ 即可。 $b\\ge (k+1)-s_i^{‘}$，只需要从这 $b$ 个中选择 $(k+1)-s_i^{‘}$ 个将其变为 $1$ 即可。 上述两种情况都不满足，即 $a&lt;s_i^{‘}$ 且 $b&lt;(k+1)-s_i^{‘}$。那么先将这 $a$ 个 $1$ 变为 $0$，然后再从这 $m$ 堆之外选 $s_i^{‘}-a$ 堆第 $i$ 位为 $1$ 的，并将其变为 $0$ 即可，此时选择的总堆数变为了 $m+s_i^{‘}-a=b+s_i^{‘}$，由于 $b&lt;(k+1)-s_i^{‘}$，所以 $b+s_i^{‘}&lt;k+1$，这种取法是合法的。 综上，一定存在一种合法的方案使得所有的 $s_i^{‘}$ 变回 $0$。 故 $s_i^{‘}$ 全为 $0$ 为必败状态，$s_i^{‘}$ 不全为 $0$ 为必胜状态，结论得证。 威佐夫博弈有两堆石子，数量任意，可以不同。游戏开始由两个人轮流取石子。游戏规定，每次有两种不同的取法：一是可以在任意的一堆中取走任意多的石子；二是可以在两堆中同时取走相同数量的石子。最后把石子全部取完者为胜者。 结论：设石子数量为 $a,b(a&lt;b)$，当且仅当 $a=\\lfloor \\frac{\\sqrt{5}+1}{2} \\rfloor\\times (b-a)$ 时先手必败。 证明太抽象了，自己看题解吧。 例题博弈论常用解题方法有：转化为经典模型；手算几个寻找结论；打表 SG 找规律；通过一些方法维护 SG 函数；将原游戏转化为一个新的游戏。 【模板】Nim 游戏题目链接 模板题。 代码 #include &lt;bits/stdc++.h&gt; typedef long long ll; using namespace std; const int N=1e3+7; int main() { int T; cin&gt;&gt;T; while(T--) { int n,ans=0; scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;++i) { int x; scanf(&quot;%d&quot;,&amp;x); ans^=x; } if(ans!=0) puts(&quot;Yes&quot;); else puts(&quot;No&quot;); } return 0; } 【模板】威佐夫博弈题目链接 模板题。 代码 #include &lt;bits/stdc++.h&gt; typedef long long ll; using namespace std; const int N=5e5+7; int main() { double k=(sqrt(5.0)+1)/2.0; int a,b; cin&gt;&gt;a&gt;&gt;b; if(a&gt;b) swap(a,b); if(a==int((b-a)*k)) puts(&quot;0&quot;); else puts(&quot;1&quot;); return 0; } CF388C Fox and Card Game题目链接 桌子上有 $n(n\\le 100)$ 堆牌，每堆有 $s_i(s_i\\le 100)$ 张牌。每张牌上都有一个正整数。C 可以从任何非空牌堆的顶部取出一张牌，J 可以从任何非空牌堆的底部取出一张牌。C 先取，当所有的牌堆都变空时游戏结束。他们都想最大化他所拿牌的分数（即每张牌上正整数的和）。问他们所拿牌的分数分别是多少？ 题解 先考虑所有牌堆都为偶数的情况，结论为对于每堆牌，先手会取走顶部的一半，后手会取走底部的一半，将这个局面记为稳定局面，设此时先手有 $a$ 分，后手有 $b$ 分。 证明：设先后手最终分别获得 $x,y$ 分。无论一方怎么拿牌，另一方都可以与对方对照着拿牌来迫使最终达到稳定局面，因此他们获得的分数一定不会低于稳定局面，即 $x\\ge a,y\\ge b$，又因为两人拿到的分数之和不变，即 $x+y=a+b$，因此 $x=a,y=b$。 接下来考虑奇数牌堆，对于某一个奇数牌堆，某一方取走一张牌后，这个牌堆就变为了偶数堆，两人各分一半，因此，谁先取了奇数牌堆，谁就多拿走了中间那张牌。所以先手会取中间牌最大的奇数牌堆，后手会取第二大的，先手再取第三大的，就这样一直取下去，直到没有奇数牌堆。剩下就一人一半就行了。 用大根堆将奇数牌堆按中间牌从大到小排序，依次取出即可。时间复杂度 $O(n\\log n)$。 代码 #include &lt;bits/stdc++.h&gt; typedef long long ll; using namespace std; const int N=1e2+7; int a[N][N],b[N][N]; priority_queue&lt;int&gt; q; int main() { int n,ans1=0,ans2=0; cin&gt;&gt;n; for(int i=1;i&lt;=n;++i) { int m; scanf(&quot;%d&quot;,&amp;m); for(int j=1;j&lt;=m;++j) { scanf(&quot;%d&quot;,&amp;a[i][j]); b[i][j]=b[i][j-1]+a[i][j]; } ans1+=b[i][m/2];ans2+=b[i][m]-b[i][(m+1)/2]; if(m&amp;1) q.push(a[i][(m+1)/2]); } bool flag=0; while(!q.empty()) { if(!flag) ans1+=q.top(); else ans2+=q.top(); flag^=1;q.pop(); } cout&lt;&lt;ans1&lt;&lt;&quot; &quot;&lt;&lt;ans2; return 0; } CF794E Choosing Carrot题目链接 有一排 $n(n\\le 3\\times 10^5)$ 个数，甲乙轮流取，每次可以选择两端中的一端取走一个数，直到剩下一个数，甲希望剩下的数最大，乙希望最小。同时，在游戏开始前，甲可以提前操作 $k(0\\le k\\le n-1)$ 次（操作规则和上面一样），游戏开始后甲是先手。问对于每一个 $k$，最后剩下来的数是几。 题解 先考虑 $k=0$ 的情况，如果 $n$ 是偶数，设 $mid=\\frac{n}{2}$，与上题类似，无论先手怎么取，后手都可以与先手相对着取，则可以保证最后留下来的数不大于 $\\max\\{ a_{mid},a_{mid+1}\\}$。而对于先手，如果 $a_{mid}&gt;a_{mid+1}$，先手就先取右端，之后无论后手怎么取，先手都和对方相对着取，这样就留下了 $a_{mid}$，当 $a_{mid}&lt;a_{mid+1}$ 时也同理，因此先手可以保证最后留下来的数不小于 $\\max\\{ a_{mid},a_{mid+1}\\}$。综上，最后留下来的数一定为 $\\max\\{ a_{mid},a_{mid+1}\\}$。 如果 $n$ 是奇数，设 $mid=\\frac{n+1}{2}$先手任取一端后就变为了偶数的情况，但此时是后手拿到偶数的情况，因此后手会留下中间两个中较小的一个，而先手希望最后留下来的最大，因此答案为 $\\max\\left\\{ \\min\\{ a_{mid-1},a_{mid}\\},\\min\\{ a_{mid},a_{mid+1}\\} \\right\\}$。 接下来考虑 $k&gt;0$ 的情况，当留下的区间确定后该情况的答案也确定了，先手会选择所有情况中最大的答案。假设 $n$ 为偶数，设 $mid=\\frac{n}{2}$，当 $k=0$ 时答案为 $\\max\\{ a_{mid},a_{mid+1}\\}$； 当 $k=2$ 时答案为 $\\max\\left\\{ \\max\\{ a_{mid-1},a_{mid}\\},\\max\\{ a_{mid},a_{mid+1}\\},\\max\\{ a_{mid+1},a_{mid+2}\\} \\right\\}$； 当 $k=4$ 时答案为 $\\max\\left\\{ \\max\\{ a_{mid-2},a_{mid-1}\\},\\dots,\\max\\{ a_{mid+2},a_{mid+3}\\} \\right\\}$。 可以发现当 $n$ 为偶数时，$k+2$ 相当于在 $k$ 的答案的基础上左右扩展一个。同理可以推得 $n$ 为奇数时也符合这个结论。注意要特判 $k=n-1$ 的情况。 时间复杂度为 $O(n)$。 代码 #include &lt;bits/stdc++.h&gt; typedef long long ll; using namespace std; const int N=3e5+7,inf=1e9+7; int a[N],b[N]; int main() { int n; cin&gt;&gt;n; for(int i=1;i&lt;=n;++i) scanf(&quot;%d&quot;,&amp;a[i]); if(n==1) {cout&lt;&lt;a[1];return 0;} for(int i=2;i&lt;n;++i) b[i]=max(min(a[i-1],a[i]),min(a[i],a[i+1])); int max0=-inf,max1=-inf,h=n/2,t; if(n&amp;1) t=h+2,max1=b[h+1],printf(&quot;%d &quot;,max1),max0=a[h+1]; else t=h+1,max0=max(a[h],a[t]),printf(&quot;%d &quot;,max0); for(int i=n-1;i&gt;=2;--i) { if(i&amp;1) max1=max(max1,max(b[h],b[t])),--h,++t,printf(&quot;%d &quot;,max1); else max0=max(max0,max(a[h],a[t])),printf(&quot;%d &quot;,max0); } printf(&quot;%d &quot;,max0); return 0; } [AGC002E] Candy Piles题目链接 桌上有 $n(n\\le 10^5)$ 堆糖果，第 $i$ 堆糖果有 $a_i$ 个糖。两人在玩游戏，轮流进行，每次可以将当前最大的那堆糖果全部吃完，或者将每堆糖果吃掉一个。吃完的人输，假设两人足够聪明，问谁有必胜策略？ 题解 将这 $n$ 堆糖果按数量从多到少依次排序，每堆糖果排成一排，设左上角为 $(1,1)$，如图， 如果将当前最大的那堆糖果全部吃完（操作一），就会变成 $(2,1)$， 如果将每堆糖果吃掉一个（操作二），就会变成 $(1,2)$， 于是发现，设当前在 $(i,j)$，则执行一次操作一会变成 $(i+1,j)$，相当于向右走一步；执行一次操作二会变成 $(i,j+1)$，相当于向下走一步。 显然如果一个点的右边和下边都没有点，那该点为必败点。一个点为必胜点当且仅当它的右边和下边至少有一个必败点，一个点为必败点当且仅当它的右边和下边都为必胜点。 则有结论：$(i,j)$ 和 $(i+1,j+1)$ 的胜败状态相同。 证明：设 $0$ 表示必败，$1$ 表示必胜。若 $(i,j)$ 为 $1$，则 $(i+1,j)$ 和 $(i,j+1)$ 中至少有一个为 $0$，因此 $(i+1,j+1)$ 一定为 $1$。 若 $(i,j)$ 为 $0$，则 $(i+1,j)$ 和 $(i,j+1)$ 都为 $1$。考虑反证法，假设 $(i+1,j+1)$ 为 $1$，则 $(i+2,j)$ 和 $(i,j+2)$ 必须为 $0$，进而有 $(i+2,j+1)$ 和 $(i+1,j+2)$ 都为 $1$，由此可推出 $(i+1,j+1)$ 为 $0$，与假设矛盾，因此 $(i+1,j+1)$ 为 $0$。 综上，$(i,j)$ 和 $(i+1,j+1)$ 的胜败状态相同。 因此只需从 $(1,1)$ 一直往右下方走，直到右下方没有点，此时只能一直向右走或者一直向下走，则只需判断右边和下边剩余点的奇偶即可。 时间复杂度 $O(n)$。 代码 #include &lt;bits/stdc++.h&gt; typedef long long ll; using namespace std; const int N=1e5+7; int a[N]; bool cmp(int x,int y) {return x&gt;y;} int main() { int n; cin&gt;&gt;n; for(int i=1;i&lt;=n;++i) scanf(&quot;%d&quot;,&amp;a[i]); sort(a+1,a+1+n,cmp); int mx=0; for(int i=1;i&lt;=n;++i) if(a[i]&gt;=i) mx=i; if((a[mx]-mx)&amp;1) puts(&quot;First&quot;); else { int cnt=0; for(int i=mx+1;i&lt;=n;++i) { if(a[i]&lt;mx) break; ++cnt; } if(cnt&amp;1) puts(&quot;First&quot;); else puts(&quot;Second&quot;); } return 0; } SP11414 COT3 - Combat on a tree题目链接 两人在一棵 $n(n\\le 10^5)$ 个节点的树上玩游戏，根节点为 $1$，每个节点最初都是黑色或白色，他们轮流执行以下操作：从当前树中选择一个白色节点 $v$，将路径 $(1,v)$ 上的所有白色节点都变为黑色。无法操作的玩家失败，问先手是否能够必胜，并求出第一步的方案。 题解 考虑维护每个点的 SG 值，设 $SG(i)$ 表示以 $i$ 为根的子树的 SG 值，$SG(i)(k)$ 表示在 $i$ 子树内选择点 $k$ 进行操作后的 SG 值，$son_i$ 表示 $i$ 的儿子数量，$i_j$ 表示 $i$ 的第 $j$ 个儿子。 如果 $i$ 是黑点，可以发现 $i$ 的儿子间都是独立的，因此 $SG(i)=SG(i_1)\\oplus SG(i_2)\\oplus \\dots \\oplus SG(i_{son_i})$，但只求 SG 值是不够的，因为题目要求第一步选哪些点可以必胜，也就是从 $i$ 的所有后继状态中找出 SG 值为 $0$ 的状态，因此我们还需要维护 $i$ 的所有后继状态，考虑到每个点都至多有 $n$ 个后继状态，因此这是可行的。 设 $s_i=SG(i_1)\\oplus SG(i_2)\\oplus \\dots \\oplus SG(i_{son_i})$，若任选 $i$ 子树中的一点 $k$，设 $k$ 在 $i_j$ 子树内，则当前局面的 SG 值为 $SG(i)(k)=SG(i_1)\\oplus \\dots \\oplus SG(i_{j-1})\\oplus SG(i_j)(k)\\oplus SG(i_{j+1})\\oplus \\dots \\oplus SG(i_{son_i})$，即 $SG(i)(k)=s_i\\oplus SG(i_j)\\oplus SG(i_j)(k)$，这是 $i$ 的一个后继状态。我们发现 $SG(i_j)(k)$ 是 $i_j$ 的一个后继状态，由于 $i_j$ 能选的点，$i$ 也可以选，因此 $i_j$ 的任意一个后继状态异或上 $s_i\\oplus SG(i_j)$ 就变成了 $i$ 的后继状态。 这样就得到了一种解法，但一个个异或复杂度太高，我们需要一个能够区间异或的数据结构，自然想到了 01Trie，对每个节点都建一个 01Trie 来保存该子树的所有后继状态的 SG 值，要求 $i$ 的 01Trie，只需将 $i$ 的每一个儿子 $i_j$ 的 01Trie 整体异或上 $s_i\\oplus SG(i_j)$，然后将所有儿子的 01Trie 合并就得到了 $i$ 的 01Trie，合并时可以用启发式合并或者线段树合并。需要注意由于要求第一步的方案，因此还要维护每个 SG 值是由哪些点产生的，合并时用启发式合并。 上面是 $i$ 为黑点的情况，而当 $i$ 为白点时，任选一点后，$i$ 就变成了黑点，就和上面一样了，唯一不同的是多了一个选择点 $i$ 的状态。因此白点就是在黑点的 01Trie 上再插入一个 $s_i$。 如果使用线段树合并，时间复杂度为 $O(n\\log n)$；使用启发式合并为 $O(n\\log^2 n)$。 代码 //线段树合并 #include &lt;bits/stdc++.h&gt; typedef long long ll; using namespace std; const int N=1e5+7,LEN=17; struct node { int ch[2],tag,id,siz; }tr[N*18]; int c[N],tot=0,rt[N],sg[N],tot_id=0,ANS[N]; vector&lt;int&gt; nx[N],num[N]; void push(int x,int k) { if(k==0) return ; if((tr[x].tag)&amp;(1&lt;&lt;(k-1))) swap(tr[x].ch[0],tr[x].ch[1]); if(tr[x].ch[0]) tr[tr[x].ch[0]].tag^=tr[x].tag; if(tr[x].ch[1]) tr[tr[x].ch[1]].tag^=tr[x].tag; tr[x].tag=0; } void merge(int &amp;now,int re,int k) { if(!now||!re) {now=now+re;return ;} if(k==0) { tr[now].tag=0; int x=tr[now].id,y=tr[re].id; if(!x||!y) tr[now].id+=tr[re].id; else { if(num[x].size()&lt;num[y].size()) swap(x,y),swap(tr[now].id,tr[re].id); for(int i=0;i&lt;num[y].size();++i) num[x].push_back(num[y][i]); } return ; } if(tr[now].tag!=0) push(now,k); if(tr[re].tag!=0) push(re,k); merge(tr[now].ch[0],tr[re].ch[0],k-1); merge(tr[now].ch[1],tr[re].ch[1],k-1); tr[now].siz=tr[tr[now].ch[0]].siz+tr[tr[now].ch[1]].siz+1; } void ins(int &amp;now,int v,int k,int ID) { now=++tot; if(k==0) { tr[now].id=++tot_id; num[tot_id].push_back(ID); tr[now].siz=1; return ; } int tmp=(v&gt;&gt;(k-1))&amp;1; ins(tr[now].ch[tmp],v,k-1,ID); tr[now].siz=tr[tr[now].ch[tmp]].siz+1; } int mex(int now,int k) { if(!now) return 0; int ans=0; while(1) { if(!now) return ans; if(tr[now].tag!=0) push(now,k); if(tr[now].siz==(1&lt;&lt;(k+1))-1) return ans+(1&lt;&lt;k); if(tr[tr[now].ch[0]].siz==(1&lt;&lt;k)-1) ans+=(1&lt;&lt;(k-1)),now=tr[now].ch[1]; else now=tr[now].ch[0]; --k; } return ans; } void dfs(int x,int fa) { int tmp=0; for(int i=0;i&lt;nx[x].size();++i) { int y=nx[x][i]; if(y==fa) continue; dfs(y,x); tmp^=sg[y]; } if(!c[x]) ins(rt[x],tmp,LEN,x); for(int i=0;i&lt;nx[x].size();++i) { int y=nx[x][i]; if(y==fa) continue; if(rt[y]) tr[rt[y]].tag^=tmp^sg[y]; merge(rt[x],rt[y],LEN); } sg[x]=mex(rt[x],LEN); } int main() { int n; cin&gt;&gt;n; for(int i=1;i&lt;=n;++i) scanf(&quot;%d&quot;,&amp;c[i]); for(int i=1;i&lt;n;++i) { int x,y; scanf(&quot;%d%d&quot;,&amp;x,&amp;y); nx[x].push_back(y); nx[y].push_back(x); } dfs(1,0); if(sg[1]==0) puts(&quot;-1&quot;); else { int now=rt[1]; for(int i=LEN;i&gt;0;--i) { if(tr[now].tag!=0) push(now,i); now=tr[now].ch[0]; } int cnt=num[tr[now].id].size(); for(int i=0;i&lt;cnt;++i) ANS[i]=num[tr[now].id][i]; sort(ANS,ANS+cnt); for(int i=0;i&lt;cnt;++i) printf(&quot;%d &quot;,ANS[i]); } return 0; } CF1451F Nullify The Matrix题目链接 有一个 $n\\times m$ 的棋盘，每个格子有一个非负整数的权值。 两个人轮流操作，每次操作选择两个权值非 $0$ 的格子，左上的点为起点，右下的为终点，每次移动只能向右走一格或者向下走一格，首先给起点的权值减一个正整数，然后从起点移动到终点，路径上每个点的权值随意加减（也可以不改变），但是都不能改成负数。 不能操作（全变成 $0$）的人就输了，问谁必胜。 题解 设当前在 $(i,j)$，则每走一步都会使 $i+j$ 加上 $1$。将 $i+j$ 相同的分为一组，记为第 $i+j$ 组，也就是将每一斜行分为一组，设 $s_{i}$ 表示 $i$ 组内所有格子权值的异或和，则有结论：当且仅当所有的 $s_i$ 都为 $0$ 时先手必败。 证明：当所有的 $s_i$ 都为 $0$ 时，由于起点的权值只能减小，因此起点所在的组的异或和在操作后一定不为 $0$。 当存在 $s_i$ 不为 $0$ 时，则找到最小的 $i$ 使得 $s_i\\ne 0$，将第 $i$ 组看作一个 Nim 游戏，则一定存在一种合法方案能够降低某个格子的值并使得 $s_i$ 变为 $0$，然后从该点出发，以 $(n,m)$ 为结尾，就可以从 $s_{i+1}$ 遍历到 $s_{n+m}$。对于每一个 $s_j (i+1\\le j \\le n+m)$，若 $s_j=0$ 则保持不变；若 $s_j\\ne 0$，则修改其中任意一个格子的权值使得 $s_j=0$ 即可。 时间复杂度 $O(nm)$。 代码 #include &lt;bits/stdc++.h&gt; typedef long long ll; using namespace std; const int N=1e2+7; int a[N][N]; int main() { int T; cin&gt;&gt;T; while(T--) { int n,m; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=m;++j) scanf(&quot;%d&quot;,&amp;a[i][j]); bool flag=0; for(int i=2;i&lt;=n+m;++i) { int sum=0; for(int j=1,k=i-1;j&lt;=n&amp;&amp;k&gt;=1;++j,--k) if(k&lt;=m) sum^=a[j][k]; if(sum) {flag=1;break;} } if(flag) puts(&quot;Ashish&quot;); else puts(&quot;Jeel&quot;); } return 0; } CF1149E Election Promises题目链接 给定一张有向无环图，每个点有一个非负整数点权。两人轮流操作，每次操作为选择一个权值为不为 $0$ 的点，并将它的值降低为一个非负整数，对于它的出点（即走一步能到达的点），可以将其值任意修改为一个非负整数（可以保持不变）。最终无法操作的人输，问先手能否必胜，如果必胜请输出第一步的方案。 题解 和上题类似，我们可以将每个点分组，使得它们满足：任意操作都会使必败状态变为必胜状态，必胜状态一定能够通过合法的操作变为必败状态。 我们令每个点和它的所有出点都不在同一组，设每个组的权值 $s_i$ 为组内所有点权值的异或和，当且仅当所有组都为 $0$ 时为必败状态，这样就满足了任意操作都会使其变为必胜状态。接下来考虑如何分组才能使得必胜状态能够转移到必败状态。 在上题中选择一个点后可以修改其后的所有组，类似地，我们希望对于每一组，选择其中任意一点后可以修改该组前面的所有组。也就是该组前面的每一组都有该点的出点，又因为当前组没有出点，自然想到了 $\\operatorname{mex}$ 操作，一个点所在的组为：对其所有出点所在的组的编号进行 $\\operatorname{mex}$ 操作所得到的数。于是对原图进行拓扑排序，按拓扑序的逆序进行分组即可。 这样对于必胜状态，只需找到编号最大的权值不为 $0$ 的组，该组的点的出点所在的组一定包含了前面所有组，就和上一题一样修改就行了，输出方案也比较简单。 时间复杂度 $O(n)$。 代码 #include &lt;bits/stdc++.h&gt; typedef long long ll; using namespace std; const int N=2e5+7; vector&lt;int&gt; nx[N],last[N],num[N]; ll a[N],sum[N]; int deg[N],col[N]; deque&lt;int&gt; q; bool vis[N]; int main() { int n,m; cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;++i) scanf(&quot;%lld&quot;,&amp;a[i]); for(int i=1;i&lt;=m;++i) { int x,y; scanf(&quot;%d%d&quot;,&amp;x,&amp;y); nx[x].push_back(y); last[y].push_back(x); ++deg[x]; } for(int i=1;i&lt;=n;++i) if(!deg[i]) { q.push_back(i); col[i]=1; sum[1]^=a[i]; num[1].push_back(i); } int mx=1; while(!q.empty()) { int x=q.front(); q.pop_front(); for(int i=0;i&lt;last[x].size();++i) { int y=last[x][i]; --deg[y]; if(!deg[y]) { q.push_back(y); for(int j=0;j&lt;nx[y].size();++j) vis[col[nx[y][j]]]=1; int mex=1; while(vis[mex]) ++mex; col[y]=mex;sum[mex]^=a[y]; mx=max(mx,mex); num[mex].push_back(y); for(int j=0;j&lt;nx[y].size();++j) vis[col[nx[y][j]]]=0; } } } int flag=0; for(int i=mx;i;--i) { if(!sum[i]) continue; int cnt=1; while(sum[i]&gt;&gt;cnt) ++cnt; for(int j=0;j&lt;num[i].size();++j) { int x=num[i][j]; if(a[x]&amp;(1&lt;&lt;(cnt-1))) {a[x]^=sum[i];flag=x;break;} } for(int j=0;j&lt;nx[flag].size();++j) { int x=nx[flag][j]; if(sum[col[x]]) a[x]^=sum[col[x]],sum[col[x]]=0; } } if(!flag) puts(&quot;LOSE&quot;); else { puts(&quot;WIN&quot;); for(int i=1;i&lt;=n;++i) printf(&quot;%lld &quot;,a[i]); } return 0; } P3235 [HNOI2014] 江南乐题目链接 写过题解了 参考资料公平组合游戏 - OI Wiki 10170 Sprague-Grundy定理是怎么想出来的 - 王赟 Maigo","categories":[{"name":"笔记","slug":"笔记","permalink":"https://a154051.gitee.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"博弈论","slug":"博弈论","permalink":"https://a154051.gitee.io/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/"}],"author":"a154051"},{"title":"【题解】P3235 [HNOI2014] 江南乐","slug":"sol-P3235-jiang-nan-le","date":"2023-12-06T09:30:38.000Z","updated":"2023-12-11T09:27:54.402Z","comments":true,"path":"2023/12/06/sol-P3235-jiang-nan-le/","link":"","permalink":"https://a154051.gitee.io/2023/12/06/sol-P3235-jiang-nan-le/","excerpt":"","text":"P3235 [HNOI2014] 江南乐 蒟蒻居然不看题解写出来了黑题。 题意首先给定一个数 $F$，有 $T$ 组数据，每组数据有 $n$ 堆石子，两个人进行博弈，每次从现有的石子堆中（包含分出来的石子堆）选择一堆石子数量不小于 $F$ 的石子堆，然后任选一个正整数 $M(M \\ge 2)$，将其分为 $M$ 堆石子，并且这 $M$ 堆石子中石子数最多的一堆至多比石子数最少的一堆多 $1$（即分得尽量平均，事实上按照这样的分石子方法，选定 $M$ 和一堆石子后，它分出来的状态是固定的）。当一个玩家不能操作的时候，也就是当每一堆石子的数量都严格小于 $F$ 时，他就输掉。 所有数都是正整数，$1 \\le T,N \\le 100$，$1 \\le F,\\text{每堆石子数量} \\le 10^5$。 题解比较显然的是 $n$ 堆石子互不干扰，所以可以把每堆石子看作一个独立的游戏，最后把 $n$ 堆石子的 SG 值异或起来。 考虑求解一堆有 $i$ 个石子的 SG 值，记为 $SG_i$。显然 $\\forall i&lt;F,SG_i=0$。当 $i \\ge F$ 时，朴素做法是枚举分出来的堆数 $k(2\\le k \\le i)$，对于每一个 $k$，令 $x \\gets \\lfloor \\frac{i}{k} \\rfloor,y \\gets i \\bmod k$，表示分出来的石子堆中，有 $y$ 堆包含 $x+1$ 个石子，$k-y$ 堆包含 $x$ 个石子，设这个局面的 SG 值为 $SG_{i_k} = \\underbrace{SG_{x+1} \\oplus \\dots \\oplus SG_{x+1}}_{\\text{y个}} \\oplus \\underbrace{SG_{x} \\oplus \\dots \\oplus SG_{x}}_{\\text{k-y个}}$，则 $SG_i = \\mathop{\\operatorname{mex}}\\limits_{j=2}^{i} SG_{i_j}$。 这样做的复杂度太高，注意到 $\\lfloor \\frac{i}{k} \\rfloor$ 可以用整除分块，于是 $x$ 只有 $O(\\sqrt{i})$ 种取值。对于每种取值，每多分出来一堆（如果可行的话），就相当于从 $y$ 中取 $x$ 个石子单独成一堆，该局面的 SG 值为 $y-x$ 个 $SG_{x+1}$ 与 $k-y+x+1$ 个 $SG_x$ 异或，也相当于将上一个局面的 SG 值与 $x$ 个 $SG_{x+1}$ 和 $x+1$ 个 $SG_x$ 异或，注意到后面两个的异或和只与 $x$ 的奇偶有关，如果 $x$ 是奇数则异或和是 $SG_{x+1}$，否则是 $SG_x$，由于 $x$ 不变，所以每个 $x$ 至多会产生两个 SG 值。 于是可以预处理出所有 SG 值，设最大的一堆有 $v$ 个石子，则时间复杂度为 $O(v\\sqrt v)$ 代码#include &lt;bits/stdc++.h&gt; typedef long long ll; using namespace std; const int N=1e5; int sg[N+7]; deque&lt;int&gt; q; bool vis[N+7]; int main() &#123; int T,f; cin&gt;&gt;T&gt;&gt;f; for(int i=max(2,f);i&lt;=N;++i) &#123; //注意这里至少要从2开始 int l=2; vis[0]=1;q.push_back(0); while(1) &#123; int x=i/l; if(!x) break; int r=i/x,y=i-x*l; //l是分出来的堆数，x是每堆至少多少石子，y是余下来的石子 if(x&lt;f-1) break; int sum=0,tmp=0; if(y&amp;1) sum=sg[x+1]; if((l-y)&amp;1) sum^=sg[x]; if(!vis[sum]) vis[sum]=1,q.push_back(sum); if(x&amp;1) tmp=sg[x+1]; else tmp=sg[x]; if(r-l+1&gt;1) &#123; sum^=tmp; if(!vis[tmp]) vis[sum]=1,q.push_back(sum); &#125; l=r+1; &#125; for(int j=0;;++j) if(!vis[j]) &#123;sg[i]=j;break;&#125; for(int j=0;j&lt;q.size();++j) vis[q[j]]=0; q.clear(); &#125; while(T--) &#123; int n; int ans=0; scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;++i) &#123; int x; scanf(&quot;%d&quot;,&amp;x); ans^=sg[x]; &#125; ans=(ans!=0); printf(&quot;%d &quot;,ans); &#125; return 0; &#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://a154051.gitee.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"博弈论","slug":"博弈论","permalink":"https://a154051.gitee.io/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/"},{"name":"整除分块","slug":"整除分块","permalink":"https://a154051.gitee.io/tags/%E6%95%B4%E9%99%A4%E5%88%86%E5%9D%97/"}],"author":"a154051"},{"title":"十月做题记录","slug":"shi-yue-zuo-ti-ji-lu","date":"2023-10-24T08:10:00.000Z","updated":"2023-10-24T10:01:10.273Z","comments":true,"path":"2023/10/24/shi-yue-zuo-ti-ji-lu/","link":"","permalink":"https://a154051.gitee.io/2023/10/24/shi-yue-zuo-ti-ji-lu/","excerpt":"","text":"加星号表示看了题解。 摆烂的十月份。 P1709 [USACO5.5] 隐藏口令 Hidden Password ＊ 题目链接 最小表示法模板题，设当前比较以 $i$ 和 $j$ 开头的字符串，则对两字符串一位一位向后比较，即每次比较 $i+k$ 和 $j+k$，直到遇到不同的字符，假设 $i$ 开头的字符串更小，则令 $j$ 直接跳到 $j+k+1$，因为对于以 $j$ 到 $j+k$ 开头的字符串，都有对应的以 $i$ 到 $i+k$ 开头的字符串必它小。时间复杂度 $O( n)$。 代码 #include &lt;bits/stdc++.h&gt; using namespace std; const int N=5e6+7; char a[N]; int main() { int n; cin&gt;&gt;n; for(int i=0;i&lt;n;++i) { char ch=getchar(); while(ch&lt;&#39;a&#39;||ch&gt;&#39;z&#39;) ch=getchar(); a[i]=ch; } int i=0,j=1,k=0; while(k&lt;n&amp;&amp;i&lt;n&amp;&amp;j&lt;n) { if(a[(i+k)%n]==a[(j+k)%n]) ++k; else { a[(i+k)%n]&gt;a[(j+k)%n]?i=i+k+1:j=j+k+1; if(i==j) ++i; k=0; } } cout&lt;&lt;min(i,j); return 0; } P6310 「Wdsr-1」仓库建设题目链接 写过题解了，【题解】P6310 [Wdsr-1]仓库建设 武汉大学2023年新生程序设计竞赛（同步赛）A. 教科书般的亵渎题目链接 将 $a$ 从大到小排序，若第一项为 $0$ 或 $1$ 且后面每一项与前一项的差小于等于 $1$ 则为 $YES$，否则为 $NO$。 代码 #include &lt;bits/stdc++.h&gt; using namespace std; const int N=1e6; int a[N]; int main() { int n; cin&gt;&gt;n; for(int i=1;i&lt;=n;++i) scanf(&quot;%d&quot;,&amp;a[i]); sort(a+1,a+1+n); int last=0; for(int i=1;i&lt;=n;++i) { if(a[i]==last||a[i]==last+1) {last=a[i];continue;} cout&lt;&lt;&quot;NO&quot;; return 0; } cout&lt;&lt;&quot;YES&quot;; return 0; } C. 覆叶之交题目链接 给定三个矩形，求它们的面积并。 用容斥写，难点在代码实现。 代码 #include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; struct squ { bool flag; ll x1,x2,y1,y2; }a[20]; int tot=3,tmp[10]; void sol(squ A,squ B) { ++tot; if(A.flag||B.flag) {a[tot].flag=1;return ;} if(A.x2&lt;=B.x1||B.x2&lt;=A.x1||A.y2&lt;=B.y1||B.y2&lt;=A.y1) {a[tot].flag=1;return ;} tmp[1]=A.x1;tmp[2]=A.x2;tmp[3]=B.x1;tmp[4]=B.x2; sort(tmp+1,tmp+5); a[tot].x2=tmp[3];a[tot].x1=tmp[2]; tmp[1]=A.y1;tmp[2]=A.y2;tmp[3]=B.y1;tmp[4]=B.y2; sort(tmp+1,tmp+5); a[tot].y1=tmp[2];a[tot].y2=tmp[3]; } int main() { ll ans=0; for(int i=1;i&lt;=3;++i) { cin&gt;&gt;a[i].x1&gt;&gt;a[i].y1&gt;&gt;a[i].x2&gt;&gt;a[i].y2; ans+=abs((a[i].x1-a[i].x2)*(a[i].y1-a[i].y2)); } for(int i=1;i&lt;=3;++i) for(int j=i+1;j&lt;=3;++j) { sol(a[i],a[j]); if(a[tot].flag==0) ans-=abs((a[tot].x1-a[tot].x2)*(a[tot].y1-a[tot].y2)); } sol(a[4],a[5]);sol(a[6],a[7]); if(a[tot].flag==0) ans+=abs((a[tot].x1-a[tot].x2)*(a[tot].y1-a[tot].y2)); cout&lt;&lt;ans; return 0; } E. 不是n皇后问题题目链接 看着挺麻烦，实际上就是把 $1$ 到 $n^2$ 按顺序填进格子就行了。 代码 #include &lt;bits/stdc++.h&gt; using namespace std; const int N=1e6; int main() { int n,cnt=0; cin&gt;&gt;n; for(int i=1;i&lt;=n;++i) { for(int j=1;j&lt;=n;++j) printf(&quot;%d &quot;,++cnt); printf(&quot;\\n&quot;); } return 0; } J. 放棋子题目链接 行和列可以分开计算，对于同一行，要使分数最大，则每次落子需要相连的旗子尽可能多，因此可以从左至右依次落子，这样就可以得到这一行的最大分数。可以证明，如果从第一行到最后一行操作也可以得到列的最大分数。时间复杂度 $O(n\\times m)$。 代码 #include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int N=1e5+7; vector&lt;int&gt; a[N]; int main() { int n,m; ll ans=0; cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;++i) { a[i].push_back(0); ll now=0; for(int j=1;j&lt;=m;++j) { char ch=getchar(); while(ch!=&#39;#&#39;&amp;&amp;ch!=&#39;.&#39;) ch=getchar(); a[i].push_back(0); if(ch==&#39;#&#39;) { a[i][j]=1; ++now; ans+=now*now; } else now=0; } } for(int i=1;i&lt;=m;++i) { ll now=0; for(int j=1;j&lt;=n;++j) { if(a[j][i]) ++now,ans+=now*now; else now=0; } } cout&lt;&lt;ans; return 0; } K. 矩形分割题目链接 显然我们想要分割出来的正方形边长尽可能大，所以以矩形的短边为正方形边长进行分割直到无法分割，如果还剩下来一个小矩形，就再对这个矩形进行上述操作，直到分割完全。 代码 #include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; int sol(int n,int m) { if(n==0||m==0) return 0; if(n==m) return n; if(n&lt;m) swap(n,m); return m*(n/m)+sol(m,n%m); } int main() { int n,m; cin&gt;&gt;n&gt;&gt;m; cout&lt;&lt;sol(n,m); return 0; } L. 小镜的数学题题目链接 从 $x$ 向后暴力找，最坏也不会超过 $2x$，数据比较水就过了。 代码 #include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; int main() { ll n; cin&gt;&gt;n; for(ll i=n+1;;++i) { if((n&amp;i)==0) { cout&lt;&lt;i; return 0; } n=(n&amp;i); } return 0; } P2017 [USACO09DEC] Dizzy Cows G题目链接 给定一个图，有无向边和有向边，给每条无向边指定一个方向，并且不出现环。 考虑拓扑排序判定有向无环图的过程，每次删去出度为 $0$ 的点，若最终能删完则为有向无环图，可以发现，每条边都是由拓扑序大的指向拓扑序小的。因此在本题中先无视无向边对原图进行拓扑排序，再让无向边由拓扑序大的点指向拓扑序小的点，就得到了有向无环图。 代码 #include &lt;bits/stdc++.h&gt; using namespace std; const int N=1e5+7; vector&lt;int&gt; last[N]; int deg[N],dep[N],cnt=0; deque&lt;int&gt; q; int main() { int n,m1,m2; cin&gt;&gt;n&gt;&gt;m1&gt;&gt;m2; for(int i=1;i&lt;=m1;++i) { int x,y; scanf(&quot;%d%d&quot;,&amp;x,&amp;y); ++deg[x]; last[y].push_back(x); } for(int i=1;i&lt;=n;++i) if(!deg[i]) q.push_back(i); while(q.size()) { int x=q.front(); q.pop_front(); dep[x]=++cnt; for(int i=0;i&lt;last[x].size();++i) if((--deg[last[x][i]])==0) q.push_back(last[x][i]); } while(m2--) { int x,y; scanf(&quot;%d%d&quot;,&amp;x,&amp;y); if(dep[x]&lt;dep[y]) swap(x,y); printf(&quot;%d %d\\n&quot;,x,y); } return 0; } 2023 年华中科技大学程序设计竞赛新生赛（线上同步赛）几乎每道题都会犯sb错误，我是超级罚时王。 P9769 [HUSTFC 2023] 简单的加法乘法计算题题目链接 设 $f_i$ 表示从 $0$ 到 $i$ 的最小操作次数，考虑最后一次操作，要么是加上 $A$ 中的一个数，要么是乘上 $B$ 中的一个数，所以 $f_i=\\min\\{ \\min\\limits_{j=1}^n f_{i-A_j},\\min\\limits_{k=1}^m f_{i/B_k}\\}$，加法用堆来维护，乘法一个个枚举，时间复杂度 $O(ym\\log n)$，如果用单调队列可以降到 $O(ym)$。 代码 #include &lt;bits/stdc++.h&gt; #define mp(x,y) make_pair(x,y) typedef long long ll; using namespace std; const int N=5e6+7; int f[N],b[20]; priority_queue&lt;pair&lt;int,int&gt; &gt; q; bool vis[N]; int main() { int x,n,m; cin&gt;&gt;x&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=m;++i) scanf(&quot;%d&quot;,&amp;b[i]); vis[0]=1;q.push(mp(0,0)); for(int i=1;i&lt;=x;++i) { int tmp=q.top().second; while(!vis[tmp]) q.pop(),tmp=q.top().second; f[i]=f[tmp]+1; for(int j=1;j&lt;=m;++j) if(i%b[j]==0) f[i]=min(f[i],f[i/b[j]]+1); q.push(mp(-f[i],i)); vis[i]=1; if(i-n-1&gt;=0) vis[i-n-1]=0; } cout&lt;&lt;f[x]; return 0; } P9771 [HUSTFC 2023] 排列排序问题题目链接 显然切割出来的序列是单调的，并且相邻的两个数相差 $1$，按这个方法切割使每个切出来的序列尽可能大就行了。时间复杂度 $O(n)$。 代码 #include &lt;bits/stdc++.h&gt; typedef long long ll; using namespace std; const int N=1e6+7; int a[N]; int main() { int n; cin&gt;&gt;n; for(int i=1;i&lt;=n;++i) scanf(&quot;%d&quot;,&amp;a[i]); int flag=-1,last=a[1],ans=0; for(int i=2;i&lt;=n;++i) { if(flag==-1) { if(a[i]==last+1) flag=1,last=a[i]; else if(a[i]==last-1) flag=0,last=a[i]; else last=a[i],++ans; continue; } if(a[i]==last+1&amp;&amp;flag==1) {last=a[i];continue;} if(a[i]==last-1&amp;&amp;flag==0) {last=a[i];continue;} last=a[i];++ans; flag=-1; } cout&lt;&lt;ans; return 0; } P9774[HUSTFC 2023] 新取模运算题目链接 显然新定义的运算符满足分配律，于是对于 $n$ 到 $1$ 这 $n$ 个数，可以分为是 $p$ 的倍数和不是 $p$ 的倍数分别计算，最后再相乘。 对于不是 $p$ 的倍数的数，它们对 $p$ 进行新定义运算等价于直接对 $p$ 取模，这一部分可以通过预处理 $1$ 到 $p$ 的阶乘来求解。 对于是 $p$ 的倍数的数，例如 $p,2p,3p…kp$，它们对 $p$ 进行新定义运算需要先除以 $p$，变为 $1,2,3…k$，这就成了原问题的子问题，于是可以递归求解，边界是 $ k&lt;p$。时间复杂度 $O(\\log_p n \\times \\log n)$。 代码 #include &lt;bits/stdc++.h&gt; typedef long long ll; using namespace std; const int N=1e6+7; int p; ll jc[N]; ll qpow(ll x,ll k) {; ll ans=1,tmp=x; while(k) { if(k&amp;1) ans=ans*tmp%p; tmp=tmp*tmp%p; k&gt;&gt;=1; } return ans; } ll sol(ll n) { ll tmp=n/p; ll ans=qpow(jc[p-1],tmp)*jc[n%p]%p; if(tmp) ans=ans*sol(tmp)%p; return ans; } int main() { int T; cin&gt;&gt;T&gt;&gt;p; jc[0]=1; for(int i=1;i&lt;=p;++i) jc[i]=jc[i-1]*i%p; while(T--) { ll n; scanf(&quot;%lld&quot;,&amp;n); printf(&quot;%lld\\n&quot;,sol(n)); } return 0; } P9775 [HUSTFC 2023] 广义线段树题目链接 给定一棵 $2n-1$ 个节点的树，$1$ 是根节点，$n$ 到 $2n-1$ 是叶子节点，给定叶子节点的点权，其他节点的点权是以它为子树的所有叶子节点的乘积。令每个叶子节点乘上一个数，求最后所有节点的和。 对叶子节点乘上一个数，则从叶子节点到根节点路径上所有节点都要乘上这个数。所以原问题转化为对树上的一条链乘上一个数，可以用树链剖分，时间复杂度 $O(n\\log^2 n)$。比赛时没细想，但实际上可以先对所有叶子节点做修改，再在 dfs 返回时向上传就可以了，时间复杂度 $O(n)$。 代码 #include &lt;bits/stdc++.h&gt; typedef long long ll; using namespace std; const int N=2e6+7,mod=998244353; struct tree { ll tag,val; }tr[N&lt;&lt;1]; ll a[N],b[N]; int nx[N][2],fa[N],dep[N],siz[N],top[N],pos[N],son[N],tot=0,rev[N]; void push(int now,ll k) { tr[now].val=tr[now].val*k%mod; tr[now].tag=tr[now].tag*k%mod; return ; } void build(int now,int l,int r) { tr[now].tag=1; if(l==r) {tr[now].val=a[rev[l]];return ;} int mid=(l+r)&gt;&gt;1; build(now&lt;&lt;1,l,mid); build(now&lt;&lt;1|1,mid+1,r); tr[now].val=(tr[now&lt;&lt;1].val+tr[now&lt;&lt;1|1].val)%mod; } void mul(int now,int l,int r,int x,int y,ll k) { if(l&gt;=x&amp;&amp;r&lt;=y) { tr[now].val=tr[now].val*k%mod; tr[now].tag=tr[now].tag*k%mod; return ; } if(tr[now].tag!=1) { push(now&lt;&lt;1,tr[now].tag); push(now&lt;&lt;1|1,tr[now].tag); tr[now].tag=1; } int mid=(l+r)&gt;&gt;1; if(x&lt;=mid) mul(now&lt;&lt;1,l,mid,x,y,k); if(y&gt;mid) mul(now&lt;&lt;1|1,mid+1,r,x,y,k); tr[now].val=(tr[now&lt;&lt;1].val+tr[now&lt;&lt;1|1].val)%mod; } void dfs1(int x,int FA) { fa[x]=FA;dep[x]=dep[FA]+1;siz[x]=1; if(nx[x][0]) { dfs1(nx[x][0],x);dfs1(nx[x][1],x); siz[x]+=siz[nx[x][0]]+siz[nx[x][1]]; son[x]=siz[nx[x][0]]&gt;siz[nx[x][1]]?nx[x][0]:nx[x][1]; a[x]=a[nx[x][0]]*a[nx[x][1]]%mod; } } void dfs2(int x,int tp) { top[x]=tp;pos[x]=++tot;rev[tot]=x; if(!son[x]) return ; dfs2(son[x],tp); int tmp=nx[x][0]; if(tmp==son[x]) tmp=nx[x][1]; dfs2(tmp,tmp); } void chg(int x,ll k) { if(k==1) return ; while(x) { mul(1,1,tot,pos[top[x]],pos[x],k); x=fa[top[x]]; } } int main() { int n; cin&gt;&gt;n; for(int i=n;i&lt;=n*2-1;++i) scanf(&quot;%lld&quot;,&amp;a[i]); for(int i=1;i&lt;=n;++i) scanf(&quot;%lld&quot;,&amp;b[i]); for(int i=1;i&lt;n;++i) scanf(&quot;%d%d&quot;,&amp;nx[i][0],&amp;nx[i][1]); dfs1(1,0); dfs2(1,1); build(1,1,tot); for(int i=1;i&lt;=n;++i) { chg(i+n-1,b[i]); printf(&quot;%lld &quot;,tr[1].val); } return 0; } P9777 [HUSTFC 2023] Fujisaki 讨厌数学题目链接 已知 $x^1+x^{-1}=k$，求 $x^n+x^{-n}$。 可以发现 $(x^a+x^{-a})(x^b+x^{-b})=x^{a+b}+x^{-(a+b)}+x^{(a-b)}+x^{-(a-b)}$。设 $f_n=x^n+x^{-n}$，可以得到 $f_{(a+b)}=f_a \\times f_b-f_{(a-b)}$。因此，若 $n$ 是偶数，有 $f_n=f_{n/2}^2-f_0$，若 $n$ 是奇数，有 $f_n=f_{n/2}\\times f_{n/2+1}-f_1$。 设 $n$ 在第一层，向下拆分得到第二层，第二层要么有一个数要么有两个数，考虑两个数的情况，这两个数一定相差 $1$，将它们向下拆分，第三层仍然是两个数，并且也是相差 $1$，可以证明每一层都至多两个数。每次拆分都除以 $2$，因此有 $\\log n$ 层。可以用记忆化搜索，但是 $n$ 太大了，要用 $map$ 存，时间复杂度 $O(\\log^2 n)$。 代码 #include &lt;bits/stdc++.h&gt; typedef long long ll; using namespace std; map&lt;ll,ll&gt; mp; const int N=1e6+7; int mod; ll k; ll sol(ll n) { if(n==1) return k; if(mp.find(n)!=mp.end()) return mp[n]; ll ans=1; if(n&amp;1) ans=sol(n/2)*sol(n/2+1)%mod-k; else ans=sol(n/2),ans=ans*ans%mod-2; while(ans&lt;0) ans+=mod; mp[n]=ans; return ans; } int main() { ll n; cin&gt;&gt;mod&gt;&gt;k&gt;&gt;n; if(n==0) cout&lt;&lt;&quot;2&quot;; else printf(&quot;%lld&quot;,sol(n)); return 0; } P9779 [HUSTFC 2023] 不定项选择题题目链接 $n$ 道题一共有 $2^n$ 种情况，除去全都不选的情况，最坏情况是最后一次才试出来，即要试 $2^n-1$ 次。其实我是看样例猜出来的结论 代码 #include &lt;bits/stdc++.h&gt; typedef long long ll; using namespace std; const int N=2e5+7; int main() { int n,ans=1; cin&gt;&gt;n; for(int i=1;i&lt;=n;++i) ans*=2; cout&lt;&lt;ans-1; return 0; } P9780 [HUSTFC 2023] Azur Lane题目链接 先考虑怎样使天数最小，一天内放置的喵箱等级是一个不上升序列，因此将序列划分为多个不上升序列，使每个序列尽可能大，就得到了天数最小的情况。 之后天数每增加一，就需要从已划分的序列中再划分出一个序列，同时使花费最少，显然天数靠前的喵箱越多花费就越多，因此我们希望喵箱尽可能放在后面，于是可以从第一天开始向后找到第一个序列长度大于 $1$ 的序列，将它划分出一个数，最后将答案加上天数增加导致前面喵箱增加的花费。时间复杂度 $O(n)$。 代码 #include &lt;bits/stdc++.h&gt; typedef long long ll; using namespace std; const int N=1e6+7; int a[N]; ll b[N]; int main() { int m,k,tot=1; ll ans=0; cin&gt;&gt;m&gt;&gt;k; for(int i=1;i&lt;=m;++i) scanf(&quot;%d&quot;,&amp;a[i]); b[1]=1; for(int i=2;i&lt;=m;++i) { if(a[i]&lt;=a[i-1]) ++b[tot]; else b[++tot]=1; } for(int i=1;i&lt;=tot;++i) ans+=b[i]*(tot-i+1); int now=1,totlast=0; for(int i=1;i&lt;=m;++i) { if(i&lt;tot) {printf(&quot;-1 &quot;);continue;} if(i==tot) {printf(&quot;%lld &quot;,ans);continue;} while(b[now]==1) ++totlast,++now; --b[now];++totlast; ans+=totlast; printf(&quot;%lld &quot;,ans); } return 0; } P9782 [HUSTFC 2023] A+B problem题目链接 签到题，$26$ 进制加法。 代码 #include &lt;bits/stdc++.h&gt; typedef long long ll; using namespace std; const int N=2e5+7; int main() { char ch1,tmp,ch2; scanf(&quot;%c%c%c&quot;,&amp;ch1,&amp;tmp,&amp;ch2); int k=ch1-&#39;A&#39;+ch2-&#39;A&#39;; if(k&gt;=26) { k-=26;cout&lt;&lt;&#39;B&#39;; } cout&lt;&lt;char(k+&#39;A&#39;); return 0; }","categories":[{"name":"题解","slug":"题解","permalink":"https://a154051.gitee.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"做题记录","slug":"做题记录","permalink":"https://a154051.gitee.io/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"}],"author":"a154051"},{"title":"【题解】P6310 [Wdsr-1]仓库建设","slug":"solution-P6310-cang-ku-jian-she","date":"2023-09-25T15:17:51.000Z","updated":"2023-10-13T12:58:30.089Z","comments":true,"path":"2023/09/25/solution-P6310-cang-ku-jian-she/","link":"","permalink":"https://a154051.gitee.io/2023/09/25/solution-P6310-cang-ku-jian-she/","excerpt":"","text":"P6310 「Wdsr-1」仓库建设 两年没写题解了，本来想找个蓝题练练手，结果被狠狠薄纱了，硬刚了半天才写出来。变量名极为抽象，写到后面我自己都搞混了。 题意给定一张无向联通图，边有边权，可以选择一些城市发出粮车，第 $i$ 座城市的粮车的油量可以行驶的路程为 $x_i$，每到一个城市都会加满油，第一问为求最少选择几个城市可以覆盖所有城市，第二问为当第 $i$ 个城市无法选择时最少选择多少城市才能满足条件，如果不能则输出 $-1$。 题解显然我们希望路径中最大的边权最小，自然想到了 Kruskal 重构树，重构树的叶子节点为原图的 $n$ 个节点，其他节点代表原图的一条边，点权即是边权，深度越浅的点点权越大。 设 $val$ 表示点权，从某个叶子节点 $i$ 向上找到最浅的节点 $j$ 满足 $val_j \\le x_i$，记为 $fa_i$，如果选择了 $i$，则以 $fa_i$ 为根的子树的叶子节点都可以被覆盖。显然如果某条路径上有多个 $fa_i$ 我们要选择深度最浅的那个，则该子树内的其他点都不用选。 所以第一问只需要从根节点向下遍历，遇到 $fa$ 节点就将计数器加一，并直接返回，不用遍历该子树。 对于第二问，假设当前无法选择的节点为 $i$，如果 $fa_i$ 不是第一问选择的节点，则答案不变。 如果从 $i$ 到根的路径上只有 $fa_i$，若 $\\exists j \\neq i,fa_j = fa_i$ 则答案不变，若这样的 $j$ 不存在，则无法到达 $i$，答案为 $-1$。 如果 $fa_i$ 是第一问选择的节点且从 $i$ 到根的路径上还有其他的 $fa$，则只需要在 $fa_i$ 子树内选择深度最浅的几个 $fa$ 节点就能覆盖所有点，像第一问一样在 $fa_i$ 的子树内遍历，遇到 $fa$ 节点就将计数器加一，并直接返回，不用遍历该子树，最后将第一问的答案减一再加上计数器就是最终答案。 向上找 $fa$ 用倍增实现，其他值都可以一次 dfs 求出来，总时间复杂度为 $O(n \\log n)$。 代码#include &lt;bits/stdc++.h&gt; using namespace std; const int N=3e5+7; struct edge &#123; int u,v,w; &#125;e[N]; int a[N],fa[N],val[N&lt;&lt;1],f[N&lt;&lt;1][21],dep[N&lt;&lt;1],cnt[N&lt;&lt;1],num[N],leaf[N&lt;&lt;1],up[N&lt;&lt;1]; //cnt是统计某个fa节点的子树内有多少个深度最浅的fa节点，num是从叶子节点到根有多少fa节点 //leaf是某个fa节点对应的叶子节点有几个，up是距离fa节点最近的祖先fa节点 bool vis[N&lt;&lt;1]; vector&lt;int&gt; son[N&lt;&lt;1]; bool cmp(edge x,edge y)&#123;return x.w&lt;y.w;&#125; int fd(int x) &#123; if(!fa[x]) return x; return fa[x]=fd(fa[x]); &#125; void dfs1(int x,int FA) &#123; dep[x]=dep[FA]+1;f[x][0]=FA; for(int i=0;i&lt;son[x].size();++i) dfs1(son[x][i],x); &#125; void dfs2(int x,int FA,int CNT) &#123; if(vis[x]) ++cnt[FA],++CNT,up[x]=FA; for(int i=0;i&lt;son[x].size();++i) &#123; if(vis[x]) dfs2(son[x][i],x,CNT); else dfs2(son[x][i],FA,CNT); &#125; if(!son[x].size()) num[x]=CNT; &#125; int main() &#123; int n,m; cin&gt;&gt;n&gt;&gt;m; int tot=n; for(int i=1;i&lt;=m;++i) scanf(&quot;%d%d%d&quot;,&amp;e[i].u,&amp;e[i].v,&amp;e[i].w); sort(e+1,e+1+m,cmp); for(int i=1;i&lt;=m;++i) &#123; int x=fd(e[i].u),y=fd(e[i].v); if(x!=y) &#123; fa[x]=fa[y]=++tot; son[tot].push_back(x); son[tot].push_back(y); val[tot]=e[i].w; &#125; &#125; for(int i=1;i&lt;=n;++i) scanf(&quot;%d&quot;,&amp;a[i]); dfs1(tot,0); for(int j=1;j&lt;=20;++j) for(int i=1;i&lt;=tot;++i) f[i][j]=f[f[i][j-1]][j-1]; for(int i=1;i&lt;=n;++i) &#123; int now=i; for(int j=20;j&gt;=0;--j) if(f[now][j]&amp;&amp;a[i]&gt;=val[f[now][j]]) now=f[now][j]; vis[now]=1; fa[i]=now; ++leaf[now]; &#125; dfs2(tot,0,0); printf(&quot;%d &quot;,cnt[0]); for(int i=1;i&lt;=n;++i) &#123; if(num[i]==1&amp;&amp;leaf[fa[i]]&lt;=1) printf(&quot;-1 &quot;); else if(up[fa[i]]||leaf[fa[i]]&gt;1) printf(&quot;%d &quot;,cnt[0]); else printf(&quot;%d &quot;,cnt[0]-1+cnt[fa[i]]); &#125; return 0; &#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://a154051.gitee.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"Kruskal重构树","slug":"Kruskal重构树","permalink":"https://a154051.gitee.io/tags/Kruskal%E9%87%8D%E6%9E%84%E6%A0%91/"}],"author":"a154051"},{"title":"【题解】P4331 [BalticOI 2004]Sequence","slug":"solution-P4331-sequence","date":"2021-09-25T08:35:02.000Z","updated":"2023-10-13T10:42:06.491Z","comments":true,"path":"2021/09/25/solution-P4331-sequence/","link":"","permalink":"https://a154051.gitee.io/2021/09/25/solution-P4331-sequence/","excerpt":"","text":"P4331 [BalticOI 2004]Sequence 数字序列 好多题解都是用的中位数做法，其实贪心就可以直接做。 题意给定一个长度为 $n$ 的整数序列 $a$，求出一个严格递增整数序列 $b$，使得 $\\sum^n_{i=1}\\left\\vert a_i-b_i\\right\\vert$ 最小。 做法首先给 $b$ 赋一个初值，使得 $b_i\\le a_i(i\\in n)$ 并且 $b_i=b_{i-1}+1(i\\in [2,n])$。 在这种情况下，要想使答案更优只能增大 $b$ 序列或不变。 因为 $b$ 严格递增，并且 $b_i=b_{i-1}+1$，所以要想使 $b_i$ 增加 $x$，就要对 $[i,n]$ 整个区间加上 $x$。 定义 $val_i=\\begin{cases}1&amp;a_i&gt;b_i \\\\ -1&amp;a_i\\le b_i\\end{cases}$，$sum_i=\\sum\\limits_{j=i}^n val_j$。 然后重复执行下列操作： 在 $[1,n]$ 中找到最大的 $sum$ 的位置 $k$，可以发现 $b_i=b_{i-1}+1(i\\in[k+1,n])$，证明在下面。 设 $x=\\min\\{a_i-b_i \\}(i\\in[k,n],a_i-b_i&gt;0)$，令 $b_i+x(i\\in[k,n])$。 更新 $val$ 和 $sum$。 直到所有的 $sum$ 都小于等于 $0$。 正确性证明： 对初始序列 $b$ 执行一遍该操作显然正确。 记 $last$ 为上一次操作中最大的 $sum$ 的位置，$k$ 为这次操作中最大的 $sum$ 的位置。 可以得到，对于任意的 $i\\in [1,last-1]$，都有 $sum_i\\le sum_{last}$。 在上一次操作中，$[last,n]$ 中至少会有一个位置的 $val$ 变为 $-1$，则 $sum_i(i\\in[1,last-1])$ 只会变得更小，所以 $k$ 不可能在 $[1,last-1]$ 中，$k$ 只会越来越靠右，因此 $b_i=b_{i-1}+1(i\\in[k+1,n])$，所以对 $b_i(i\\in [k,n])$ 执行该操作显然也正确。 证毕。 用线段树维护 $sum$，$set$ 维护 $[k,n]$ 中 $a_i-b_i(i\\in[k,n])$ 大于 $0$ 的元素。 每次操作用线段树求出 $[1,n]$ 中最大的 $sum$ 的位置 $k$，将 $set$ 中位置在 $[1,k-1]$ 的元素删除，在 $set$ 中查询此时 $a_i-b_i$ 的最小值，将等于该值的元素删除，并在线段树上将区间 $[1,\\text{该元素位置}]$ 中所有 $sum$ 减 $1$。 由于不会添加元素，所以 $set$ 至多有 $n$ 次删除操作，线段树至多有 $n$ 次修改操作。 时间复杂度为 $O(n\\log n)$。 复杂度虽然正确，但常数有点大，时间卡得很紧，要开 $O2$ 才能过。 代码#include &lt;bits/stdc++.h&gt; #define mk(x,y) make_pair(x,y) #define ls now&lt;&lt;1 #define rs now&lt;&lt;1|1 using namespace std; typedef long long ll; const int mn=1e6+7; struct tree &#123; int ans,mx,tag; &#125;tr[mn&lt;&lt;2]; int a[mn],sum[mn],val[mn]; ll b[mn]; set&lt;pair&lt;ll,int&gt; &gt; st; int in() &#123; int x=0; char c=getchar(); while(!isdigit(c)) c=getchar(); while(isdigit(c)) &#123; x=x*10+c-&#39;0&#39;; c=getchar(); &#125; return x; &#125; void upd(int now) &#123; if(tr[rs].mx&gt;=tr[ls].mx) tr[now].mx=tr[rs].mx,tr[now].ans=tr[rs].ans; else tr[now].mx=tr[ls].mx,tr[now].ans=tr[ls].ans; &#125; void build(int now,int l,int r) &#123; if(l==r) &#123; tr[now].mx=sum[l]; tr[now].ans=l; return ; &#125; int mid=(l+r)&gt;&gt;1; build(now&lt;&lt;1,l,mid); build(now&lt;&lt;1|1,mid+1,r); upd(now); &#125; void push(int now) &#123; if(!tr[now].tag) return ; tr[now&lt;&lt;1].mx+=tr[now].tag; tr[now&lt;&lt;1].tag+=tr[now].tag; tr[now&lt;&lt;1|1].mx+=tr[now].tag; tr[now&lt;&lt;1|1].tag+=tr[now].tag; tr[now].tag=0; &#125; void add(int now,int l,int r,int x,int v) &#123; if(r&lt;=x) &#123; tr[now].mx+=v; tr[now].tag+=v; return ; &#125; push(now); int mid=(l+r)&gt;&gt;1; if(x&gt;mid) add(now&lt;&lt;1|1,mid+1,r,x,v); add(now&lt;&lt;1,l,mid,x,v); upd(now); &#125; int main() &#123; int n,mi=1; n=in(); ll ans=0; for(int i=1;i&lt;=n;++i) &#123; a[i]=in(); mi=min(mi,a[i]-i+1); &#125; for(int i=1;i&lt;=n;++i) &#123; b[i]=mi+i-1; ans+=abs(b[i]-a[i]); if(b[i]&lt;a[i]) val[i]=1,st.insert(mk(a[i]-b[i],i)); else val[i]=-1; &#125; sum[n]=val[n]; for(int i=n-1;i&gt;=1;--i) sum[i]=sum[i+1]+val[i]; build(1,1,n); int last=1,cnt=0; while(1) &#123; if(tr[1].mx&lt;=0)&#123; //终止条件 for(int i=last;i&lt;=n;++i) b[i]+=cnt; break; &#125; int now=tr[1].ans; //最大的 sum 的位置 for(int i=last;i&lt;now;++i)&#123; //删除 set 中多余的元素 b[i]+=cnt; if(a[i]-b[i]-cnt&gt;0) st.erase(mk(a[i]-b[i],i)); &#125; last=now; ans-=tr[1].mx*((*st.begin()).first-cnt); cnt=(*st.begin()).first; while(st.size()) //删除 a-b 等于 0 的元素 &#123; pair&lt;ll,int&gt; it=*st.begin(); if(it.first!=cnt) break; add(1,1,n,it.second,-2); //维护 sum st.erase(st.begin()); &#125; &#125; printf(&quot;%lld\\n&quot;,ans); for(int i=1;i&lt;=n;++i) printf(&quot;%lld &quot;,b[i]); return 0; &#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://a154051.gitee.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"https://a154051.gitee.io/tags/%E8%B4%AA%E5%BF%83/"}],"author":"a154051"},{"title":"【题解】P3291 [SCOI2016]妖怪","slug":"solution-P3291-yao-guai","date":"2021-09-01T12:11:16.000Z","updated":"2023-10-13T10:42:06.494Z","comments":true,"path":"2021/09/01/solution-P3291-yao-guai/","link":"","permalink":"https://a154051.gitee.io/2021/09/01/solution-P3291-yao-guai/","excerpt":"","text":"蒟蒻不会凸包，于是用模拟退火过了这道题。 如果你还不会模拟退火，可以看看我之前写的学习笔记。 题意来自辰星凌的题解： 给出 $n$ 个点 $(x_i,y_i)$，设 $f_i(a,b)=x_i+y_i+\\frac{bx_i}{a}+\\frac{ay_i}{b}$，求出一组 $(a,b)$，使得 $\\max\\{f_{i\\in[1,n]}(a,b)\\}$ 最小，输出这个最小值。 做法正常模拟退火流程，每次随机生成两个数 $(a,b)$，暴力遍历一遍所有点计算出当前的答案，与上一次的答案比较。 蒟蒻一开始只是想骗点分，没想到拿了 $80$ 分，于是就进入了痛苦的调参过程。（注：没有在洛谷提交，洛谷数据不全。） 最初提交时总是第 $7$ 个点错，后来有一次分比较低，但是第 $7$ 个点对了，我比较了一下认为是初始温度的问题，初始温度低会导致生成出来的数的范围小，而那个点最优情况下的 $(a,b)$ 大于这个范围，所以就一直错。 于是稍微修改一下参数就 $A$ 了，最后一共提交了 $172$ 次… 不开 $O2$ 会 $T$，时间复杂度 $O(\\text{玄学})$。 代码#include &lt;bits/stdc++.h&gt; #define rd t*(rand()*2-RAND_MAX) #define max(x,y) (x&lt;y?y:x) //这里是个小优化，会快一点 using namespace std; typedef long long ll; const double eps=1e-6,down=0.89; const int mn=1e6+7; int n; double x[mn],y[mn]; double sol(double a,double b) &#123; double rs=0; for(int i=1;i&lt;=n;++i) &#123; double tmp=x[i]+y[i]+x[i]/a*b+y[i]/b*a; rs=max(rs,tmp); &#125; return rs; &#125; int main() &#123; srand(154051); scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;++i) scanf(&quot;%lf%lf&quot;,&amp;x[i],&amp;y[i]); ll a=1,b=1; double ans,minn; minn=ans=sol(1,1); for(double t=1100000;t&gt;eps;t*=down) &#123; ll aa=a+rd,bb=b+rd; if(aa==0) aa++; if(bb==0) bb++; if(aa&lt;0) aa=-aa; if(bb&lt;0) bb=-bb; double rs=sol(aa,bb); if(minn&gt;rs) minn=rs; if(rs&lt;ans||exp((ans-rs)/t)*RAND_MAX&gt;rand()) &#123; ans=rs; a=aa;b=bb; &#125; &#125; printf(&quot;%.4f&quot;,minn); return 0; &#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://a154051.gitee.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"模拟退火","slug":"模拟退火","permalink":"https://a154051.gitee.io/tags/%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB/"}],"author":"a154051"},{"title":"【题解】P3761 [TJOI2017]城市","slug":"solution-P3761-city","date":"2021-08-08T12:31:36.000Z","updated":"2023-10-13T10:42:06.491Z","comments":true,"path":"2021/08/08/solution-P3761-city/","link":"","permalink":"https://a154051.gitee.io/2021/08/08/solution-P3761-city/","excerpt":"","text":"P3761 [TJOI2017]城市 前排提醒：本文着重证明了 $O(n)$ 的做法，$O(n^2)$ 的做法讲得不是很明白。 题意给一颗有边权的树，删去一条边并加上一条权值相同的边（要求操作后还是一颗树），求树的直径最小是多少。 $n\\le 5000$。 题解很妙的一道题，主要难点在于结论的寻找和证明。 最朴素的做法是枚举每条要删除的边，整棵树被分为了两颗子树，再枚举两颗子树上选的点，计算直径。时间复杂度 $O(n^4)$。 $O(n^2)$ 做法新加入一条边后，新树的直径有两种情况： 直径在分出来的两颗树中的一个。 直径经过了新加入的边。 对于第一种情况，新加入的边不会产生影响。 对于第二种情况，要想办法连边使得新树的直径最小。可以发现两棵树要连的点都是树的中心（即该点到其他节点的最远距离最小）。 考虑 $DP$，第一遍 $\\text{dfs}$ 求出在该节点子树内从它出发的最远和次远距离。 第二遍 $\\text{dfs}$ 根据父亲的信息求出在整棵树中从该节点出发的最远和次远距离，在这个过程中找出树的中心。 所以优化后的做法为枚举每条要删除的边，求出分出来的两颗树的直径和中心，比较这三个值，取最大。时间复杂度 $O(n^2)$。 这个复杂度已经可以通过这道题了，但是还能继续优化到 $O(n)$。 $O(n)$ 做法时间复杂度的瓶颈主要在 $DP$，考虑优化。 结论一：树的中心是树的直径的（带权）中点。 证明： 对于直径上任意一点 $u$，显然从 $u$ 出发的最远路径一定在直径上，若要求直径中心则只需比较 $u$ 到直径两端的最远距离，所以直径中点 $mid$ 是该直径的中心。 对于不在直径上的点 $v$，从 $v$ 出发到 $mid$，再到直径较远一端的所走路程，必然比直接从 $mid$ 出发的所走路程远。根据定义，树的中心要到其他点的最远距离最小，所以 $v$ 不是树的中心。 综上，$mid$ 是树的中心。证毕。 问题就转化为了如何求树的直径的中点。 对于删边操作，可以发现只有删原树直径上的边才有意义，因为删其他边直径没有变。 所以从直径一端出发到另一端依次删除边。但是每次都要遍历整棵树求直径中点，时间复杂度还是没有变，考虑优化。 以下只针对删边后的两颗树中的一个分析，另一个同理。 结论二：对于一颗分割出来的树，它直径的一端一定是原树直径的一端。 证明： 反证法，如图， 删边后得到了以 $C$ 为根的子树，假设 $EF$ 该树的直径，说明 $\\text{dis}(E,F)&gt;\\text{dis}(A,B)$，$\\text{dis}(E,F)+\\text{dis}(B,E)&gt;\\text{dis}(A,B)$，则 $FD$ 比 $AD$ 更长，与 $AD$ 是原树直径矛盾，该假设不成立，所以 $A$ 一定是删边后树的直径的一端。证毕。 考虑如何快速维护删边后树的直径： （图片来自getchar123的题解） （橙色为截掉的边，绿色为直径，右图紫色的点为重复遍历的点，红色为新遍历的点） 在遍历删边的过程中，如果每次都遍历整棵树，会有大量重复节点（紫色点），根据结论二，我们只需要考虑经过新加进来的 原树直径上的点 能否得到更长的路径。 即从 $10$ 号点出发遍历红色点，找到最长路径，加上 $\\text{dis}(1,10)$，与原来的直径比较。 这样每次都只需要遍历新加进来的节点，维护直径的总时间复杂度优化到了 $O(n)$。 但是每次维护直径中点都要遍历一遍直径，时间复杂度还是 $O(n^2)$，继续优化。 结论三：对于分割出来的树，它的直径中点一定在原树直径上。 证明： 如图，删边后的树的直径一定是形如这个样子， 分割出来的树的直径和原树的直径的重叠部分一定大于非重叠部分，即 $\\text{dis}(A,B)&gt;\\text{dis}(E,B)$，如果不是，则路径 $ED$ 就会比原树直径还长。 根据直径中点的定义，中点一定在路径 $AB$ 上。证毕。 可以发现删边过程中，分割出来的树的直径是不下降的，新树和原树的重叠部分也是不下降的。 所以每次只需要从上一次的中点开始，在原树直径上向后遍历，直到当前点比上一个点劣时停止（再往后只会更劣）。维护中点的总时间复杂度为 $O(n)$。 综上，该算法的时间复杂度为 $O(n)$。 这里只维护了分割出来的其中一棵树，对于另一棵树可以倒过来重复这些操作。 代码#include &lt;bits/stdc++.h&gt; using namespace std; const int mn=5e3+7; struct node &#123; int mid,len_L,len_R; //分别是中点，直径，半径（中点到其他点的最远距离） &#125;ans[3][mn]; int tt=0,fr[mn],nx[mn*2],to[mn*2],w[mn*2]; int rt=1,rt2=1,maxlen=0,d[mn],mx=0; int q[mn],top=0; //存直径上所有点 bool vis[mn]; void add(int x,int y,int v) &#123; ++tt; nx[tt]=fr[x]; fr[x]=tt; to[tt]=y; w[tt]=v; &#125; void findrt(int x,int fa,int dis) &#123; if(dis&gt;maxlen) maxlen=dis,rt=x; for(int i=fr[x];i;i=nx[i]) if(to[i]!=fa) findrt(to[i],x,dis+w[i]); &#125; void findrt2(int x,int fa,int dis) &#123; d[x]=dis; if(dis&gt;maxlen) maxlen=dis,rt2=x; for(int i=fr[x];i;i=nx[i]) if(to[i]!=fa) findrt2(to[i],x,dis+w[i]); &#125; void deep(int x,int fa,int dis) &#123; d[x]=dis; for(int i=fr[x];i;i=nx[i]) if(to[i]!=fa) deep(to[i],x,dis+w[i]); &#125; bool dfs(int x,int fa,int dis) &#123; q[++top]=x; if(x==rt2) return 1; for(int i=fr[x];i;i=nx[i]) &#123; int y=to[i]; if(y==fa) continue; bool flag=dfs(y,x,dis+w[i]); if(flag) return 1; &#125; --top; return 0; &#125; void dfs2(int x,int dis) &#123; vis[x]=1; mx=max(mx,dis); for(int i=fr[x];i;i=nx[i]) &#123; int y=to[i]; if(vis[y]) continue; dfs2(y,dis+w[i]); &#125; &#125; void sol(int k) &#123; memset(vis,0,sizeof(vis)); for(int i=1;i&lt;=top;++i) vis[q[i]]=1; int mid=1,len_L=0,len_R=0; ans[k][1]=(node)&#123;mid,len_L,len_R&#125;; for(int i=2;i&lt;top;++i) &#123; mx=0; dfs2(q[i],0); //遍历新加进来的节点 if(d[q[i]]-d[q[1]]+mx&lt;=len_L) ans[k][i]=(node)&#123;mid,len_L,len_R&#125;; else &#123; len_L=d[q[i]]-d[q[1]]+mx; len_R=max(d[q[mid]]-d[q[1]],len_L-d[q[mid]]-d[q[1]]); for(int j=mid+1;j&lt;=i;++j) &#123; int dis=max(d[q[j]]-d[q[1]],len_L-d[q[j]]-d[q[1]]); if(dis&gt;len_R) break; //这里就直接跳出，后面只会更劣 len_R=dis;mid=j; &#125; ans[k][i]=(node)&#123;mid,len_L,len_R&#125;; &#125; &#125; &#125; int main() &#123; int n; cin&gt;&gt;n; for(int i=1;i&lt;n;++i) &#123; int x,y,v; scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;v); add(x,y,v); add(y,x,v); &#125; findrt(1,0,0); //找直径一端 maxlen=0; findrt2(rt,0,0); //找另一端 maxlen=0; dfs(rt,0,0); //存直径 sol(1); /***************以下为倒过来处理另一棵树***************/ memset(d,0,sizeof(d)); top=0; swap(rt,rt2); deep(rt,0,0); //根变了，深度也要重新求 dfs(rt,0,0); sol(2); int ANS=1e9; for(int i=1;i&lt;top;++i) ANS=min(ANS,max(d[q[i+1]]-d[q[i]]+ans[2][i].len_R+ans[1][top-i].len_R,max(ans[2][i].len_L,ans[1][top-i].len_L))); cout&lt;&lt;ANS; return 0; &#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://a154051.gitee.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"树","slug":"树","permalink":"https://a154051.gitee.io/tags/%E6%A0%91/"}],"author":"a154051"},{"title":"【题解】P4248 [AHOI2013]差异","slug":"solution-P4248-cha-yi","date":"2021-07-17T11:49:52.000Z","updated":"2023-10-13T10:42:06.493Z","comments":true,"path":"2021/07/17/solution-P4248-cha-yi/","link":"","permalink":"https://a154051.gitee.io/2021/07/17/solution-P4248-cha-yi/","excerpt":"","text":"题意给一个长度为 $n$ 的字符串，求 \\sum\\limits_{1\\le i","categories":[{"name":"题解","slug":"题解","permalink":"https://a154051.gitee.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"https://a154051.gitee.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"后缀自动机-SAM","slug":"后缀自动机-SAM","permalink":"https://a154051.gitee.io/tags/%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA-SAM/"}],"author":"a154051"},{"title":"【题解】P2472 [SCOI2007]蜥蜴","slug":"solution-P2472-xi-yi","date":"2021-03-05T08:36:55.000Z","updated":"2023-10-13T10:42:06.491Z","comments":true,"path":"2021/03/05/solution-P2472-xi-yi/","link":"","permalink":"https://a154051.gitee.io/2021/03/05/solution-P2472-xi-yi/","excerpt":"","text":"P2472 [SCOI2007]蜥蜴 网络瘤，毒瘤的瘤。 蒟蒻第一次不看题解写出来网络瘤（然而还是逃不过debug半天的命运）。 题意在 $r\\times c$ 的网格中，每个格子都有高度，高度为 $0$ 则不存在，一些格子上有蜥蜴，蜥蜴可以跳到直线距离不超过 $d$ 的格子上，每跳一次，原来的格子高度就会减一，求最少有几只蜥蜴不能逃离。 分析显然，每个格子跳了一定次数后就不能再跳了，那么如何在网络流中加入这个限制呢？ 假设原来的点编号为 $i$，高度为 $h$，总共 $n$ 个点，我们可以把这个点拆成两个，编号为 $i$ 和 $i+n$，$i$ 负责原来这个点的入边，$i+n$ 负责出边，再连一条从 $i$ 到 $i+n$ 容量为 $h$ 的边，如图： 这个思想类似于最小割点问题。 建图注：以下说的点都是高度大于 $0$ 的点，高度为 $0$ 的点直接忽略。 对于每个点都将其拆为入点和出点，容量为格子高度。 对于能跳出网格的点，从它的出点到汇点连一条容量无穷大的边。 对于有蜥蜴的点，从源点到它的入点连一条容量为 $1$ 的边（因为每个点上最多有 $1$ 个蜥蜴）。 其中，源点和汇点都是原图中不存在的，需要另外新建。 最后跑最大流，得到最多能逃离的蜥蜴数，用蜥蜴总数减去最大流即为所求答案。 代码#include &lt;bits/stdc++.h&gt; using namespace std; const int mn=407,inf=1e7; struct node&#123; int x,y; &#125;; vector&lt;node&gt; p; int n,m,d,tot=0,num[27][27],q[2*mn],dep[2*mn]; int fr[2*mn],fr2[2*mn],nx[100*mn],to[100*mn],val[100*mn],tt=1; void add(int x,int y,int w) &#123; ++tt; nx[tt]=fr[x]; fr[x]=tt; to[tt]=y; val[tt]=w; &#125; bool bfs() &#123; for(int i=0;i&lt;=n*m*2+1;++i) dep[i]=0,fr2[i]=fr[i]; //0 为源点，2*n*m+1 为汇点 int h=1,t=1; q[1]=0;dep[0]=1; while(h&lt;=t) &#123; int u=q[h]; for(int i=fr[u];i;i=nx[i]) &#123; int v=to[i]; if(dep[v]||!val[i]) continue; q[++t]=v; dep[v]=dep[u]+1; if(v==n*m*2+1) return 1; &#125; ++h; &#125; return 0; &#125; int dfs(int u,int in) &#123; if(u==n*m*2+1) return in; int out=0; for(int &amp;i=fr2[u];i;i=nx[i]) //当前弧优化，i 是引用，当 i 变化时 fr2 也会跟着变化 &#123; int v=to[i]; if(dep[u]==dep[v]-1&amp;&amp;val[i]) &#123; int rs=dfs(v,val[i]&lt;in?val[i]:in); val[i]-=rs;val[i^1]+=rs; out+=rs;in-=rs; if(!in) break; &#125; &#125; if(out==0) dep[u]=0; return out; &#125; inline int dist(node v0,node v1)&#123;return (v0.x-v1.x)*(v0.x-v1.x)+(v0.y-v1.y)*(v0.y-v1.y);&#125; //求两点的直线距离 int main() &#123; scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;d); for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=m;++j) &#123; num[i][j]=++tot; int x; scanf(&quot;%1d&quot;,&amp;x); if(x==0) continue; add(num[i][j],num[i][j]+n*m,x); //拆点 add(num[i][j]+n*m,num[i][j],0); p.push_back((node)&#123;i,j&#125;); if(i-d&lt;1||j-d&lt;1||i+d&gt;n||j+d&gt;m) add(num[i][j]+n*m,2*n*m+1,inf),add(2*n*m+1,num[i][j]+n*m,0); //连汇点 &#125; for(int i=0;i&lt;p.size()-1;++i) //建图 for(int j=i+1;j&lt;p.size();++j) &#123; if(dist(p[i],p[j])&gt;d*d) continue; node v0=p[i],v1=p[j]; add(num[v0.x][v0.y]+n*m,num[v1.x][v1.y],inf); add(num[v1.x][v1.y],num[v0.x][v0.y]+n*m,0); add(num[v1.x][v1.y]+n*m,num[v0.x][v0.y],inf); add(num[v0.x][v0.y],num[v1.x][v1.y]+n*m,0); &#125; int cnt=0; for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=m;++j) &#123; char ch=getchar(); while(ch!=&#39;.&#39;&amp;&amp;ch!=&#39;L&#39;) ch=getchar(); if(ch==&#39;L&#39;) ++cnt,add(0,num[i][j],1),add(num[i][j],0,0); //连源点 &#125; int ans=0; while(bfs()) ans+=dfs(0,inf); cout&lt;&lt;cnt-ans; return 0; &#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://a154051.gitee.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"网络流","slug":"网络流","permalink":"https://a154051.gitee.io/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"}],"author":"a154051"},{"title":"【题解】P2467 [SDOI2010]地精部落","slug":"solution-P2467-bu-luo","date":"2021-03-03T13:40:32.000Z","updated":"2023-10-13T10:42:06.491Z","comments":true,"path":"2021/03/03/solution-P2467-bu-luo/","link":"","permalink":"https://a154051.gitee.io/2021/03/03/solution-P2467-bu-luo/","excerpt":"","text":"P2467 [SDOI2010]地精部落 题意给 $n$ 座高度连续的山脉，即高度为 $1,2,3,···,n$，求有几种方案使得山脉的高度一高一低或一低一高（即波动数列）。答案对 $p$ 取模。 分析显然，若要求 $k$ 座山脉的波动数列，无论它们的高度是否连续，只要高度互不相同，方案数都是一样的。 举个例子：求 $3$ 座山脉的波动数列，$(1,2,3)$ 和 $(1,3,5)$ 和 $(15,40,51)$的方案数都是一样的。 定义 $f(i,j,0)$ 表示前 $i$ 座山脉中，排名为 $j$ 的山脉放在最后面并且是山谷的方案数（$1$ 表示是山峰）。则最后答案为 $\\sum_{j=1}^{n} f(n,j,0)+f(n,j,1)$。 若 $j$ 是山谷，则方案为剩下的 $i-1$ 座山脉中排名从 $j$ 到 $i-1$ 的山脉放后面并且做山峰的方案之和。$j$ 是山峰也同理。 所以有状态转移方程： f(i,j,1)=\\sum\\limits_{k=1}^{j-1}f(i-1,k,0)f(i,j,0)=\\sum\\limits_{k=j}^{i-1}f(i-1,k,1)时间复杂度为 $O(n^3)$，会超时。 可以发现最里面一层循环可以用前缀和优化。 定义 $sum0(i,j)=\\sum\\limits_{x=1}^{j}f(i,x,0)$，$sum1(i,j)$ 同理，则原转移方程可化为： f(i,j,1)=sum0(i-1,j-1)f(i,j,0)=sum1(i-1,i-1)-sum1(i-1,j-1)时间复杂度为 $O(n^2)$。 因为 $f$ 和 $sum$ 只用到了当前一层和上一层，所以只存这两层就好，空间复杂度为 $O(n)$。 代码#include &lt;bits/stdc++.h&gt; using namespace std; const int mn=4207; long long f[mn][2],sum0[2][mn],sum1[2][mn]; int main() &#123; int n,p; scanf(&quot;%d%d&quot;,&amp;n,&amp;p); f[1][1]=f[1][0]=sum0[1][1]=sum1[1][1]=1; for(int i=2;i&lt;=n;++i) &#123; int now=i&amp;1; //now为当前层，now^1为上一层。这里相当于 now=i%2 for(int j=1;j&lt;=i;++j) &#123; f[j][1]=sum0[now^1][j-1]; f[j][0]=(sum1[now^1][i-1]-sum1[now^1][j-1])%p; while(f[j][0]&lt;0) f[j][0]+=p; //避免取模后相减变为负数 sum0[now][j]=(sum0[now][j-1]+f[j][0])%p; sum1[now][j]=(sum1[now][j-1]+f[j][1])%p; &#125; &#125; long long ans=0; for(int i=1;i&lt;=n;++i) ans=((ans+f[i][0])%p+f[i][1])%p; cout&lt;&lt;ans; &#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://a154051.gitee.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"DP","slug":"DP","permalink":"https://a154051.gitee.io/tags/DP/"}],"author":"a154051"},{"title":"【题解】P6394樱花，还有你","slug":"solution-P6394-ying-hua","date":"2021-02-27T03:14:00.000Z","updated":"2023-10-13T10:42:06.493Z","comments":true,"path":"2021/02/27/solution-P6394-ying-hua/","link":"","permalink":"https://a154051.gitee.io/2021/02/27/solution-P6394-ying-hua/","excerpt":"","text":"P6394 樱花，还有你 题面好浪漫，可惜我是11月11日写的这题。 题意有 $k$ 棵树，每棵树上有 $s_i$ 朵花，有几种方案能恰好取 $n$ 朵花，若收集不到 $n$ 朵花，输出impossible。 注意：用 $(a_1,a_2,⋯)$ 表示一种方案，则 $(1,1,1)$ 和 $(1,1,1,0)$ 是两种不同的方案。 分析Subtask 1$\\sum s_i&lt;n$ 白给，直接输出impossible即可。 Subtask 2&amp;3$n,k \\le 5\\times10^2$ 定义 $f(i,j)$ 表示前 $i$ 棵树收集 $j$ 朵花的方案数。 显然有状态转移方程： f(i,j)=\\sum\\limits_{x=0}^{\\min(j,s_i)}f(i-1,j-x)最终答案为 $\\sum_{i=1}^{k}f(i,n)$。 时间复杂度：$O(n^2k)$，空间复杂度：$O(nk)$。 Subtask 4$n,k \\le 5\\times10^3$ $O(n^2k)$ 的复杂度会超时，需要优化。 发现可以用前缀和优化掉最里面一层循环。 定义 $sum(i,j)=\\sum_{x=0}^j f(i,x)$。 所以 f(i,j)=sum(i-1,j)-sum(i-1,j-\\min(j,s_i)-1)为了避免数组下标为负数，应改为 f(i,j)=sum(i-1,j)-sum(i-1,j-\\min(j,s_i))+f(i-1,j-\\min(j,s_i)时间复杂度：$O(nk)$。 这时候发现无耻出题人只给了 $64MB$，内存会炸。 观察上述转移方程，发现 $f$ 数组和 $sum$ 数组只用到了这一层和上一层，所以只存这两层就好。 空间复杂度：$O(n)$。 代码#include &lt;bits/stdc++.h&gt; using namespace std; const int mn=5e3+7,mod=10086001; int s[mn],f[2][mn],sum[2][mn]; int now; //now为当前这一层，now^1为上一层 int min1(int x,int y) &#123; return x&lt;y?x:y; &#125; int main() &#123; int n,k,cnt=0; cin&gt;&gt;n&gt;&gt;k; f[0][0]=sum[0][0]=f[1][0]=sum[1][0]=1; for(int i=1;i&lt;=k;++i) scanf(&quot;%d&quot;,&amp;s[i]),cnt+=s[i]; if(cnt&lt;n) &#123; cout&lt;&lt;&quot;impossible&quot;; return 0; &#125; int ans=0; for(int i=1;i&lt;=k;++i) &#123; now=i&amp;1; //相当于now=i%2 for(int j=1;j&lt;=n;++j) &#123; sum[now^1][j]=(sum[now^1][j-1]+f[now^1][j])%mod; f[now][j]=(sum[now^1][j]-sum[now^1][j-min1(j,s[i])]+f[now^1][j-min1(j,s[i])])%mod; while(f[now][j]&lt;0) f[now][j]+=mod; //取模后相减有可能出现负数 &#125; ans=(ans+f[now][n])%mod; &#125; cout&lt;&lt;ans; return 0; &#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://a154051.gitee.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"DP","slug":"DP","permalink":"https://a154051.gitee.io/tags/DP/"}],"author":"a154051"},{"title":"【笔记】模拟退火算法","slug":"mo-ni-tui-huo-bi-ji","date":"2021-02-08T11:40:00.000Z","updated":"2023-12-11T09:33:45.655Z","comments":true,"path":"2021/02/08/mo-ni-tui-huo-bi-ji/","link":"","permalink":"https://a154051.gitee.io/2021/02/08/mo-ni-tui-huo-bi-ji/","excerpt":"","text":"简介模拟退火(Simulated Annealing，SA)是一种随机化算法。它适用于解决方案量极大的问题，如旅行商问题，求解多峰函数极值等问题。 原理 模拟退火算法来源于固体退火原理，是一种基于概率的算法，将固体加温至充分高，再让其徐徐冷却，加温时，固体内部粒子随温升变为无序状，内能增大，而徐徐冷却时粒子渐趋有序，在每个温度都达到平衡态，最后在常温时达到基态，内能减为最小。 ——百度百科 把问题看作固体内部粒子，把最优解看作平衡态，用程序模拟退火的过程，就是模拟退火算法。 过程模拟退火中有三个参数，分别是初始温度 $T_0$、降温系数 $\\Delta$。其中，$\\Delta$ 是一个略小于 $1$ 的数。 令温度 $T=T_0$，然后每次降温时 $T=T*\\Delta$，直到 $T=0$。 在每次降温过程中，都要用当前解产生一个新解，即 $x_1=x_0+\\Delta x$。其中，$\\Delta x \\in R$ 并且 $\\left\\vert \\Delta x\\right\\vert \\propto T$，表示解的变动值，温度越低，它的变化幅度越小，产生的新解也会越来越趋近于最优解，如图， 这时候我们需要考虑是否用新解替换当前解，定义当前温度为 $T$，某个解 $x$ 的贡献为 $f(x)$（这里的贡献不是指大小，而是这个解的优劣），则修改当前解的概率为 P=\\begin{cases}1&f(x_1)\\geqslant f(x_0)\\\\e^\\frac{-\\left\\vert f(x_1)-f(x_0)\\right\\vert}{T}&f(x_1)","categories":[{"name":"笔记","slug":"笔记","permalink":"https://a154051.gitee.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"模拟退火","slug":"模拟退火","permalink":"https://a154051.gitee.io/tags/%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB/"}],"author":"a154051"}],"categories":[{"name":"笔记","slug":"笔记","permalink":"https://a154051.gitee.io/categories/%E7%AC%94%E8%AE%B0/"},{"name":"题解","slug":"题解","permalink":"https://a154051.gitee.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"博弈论","slug":"博弈论","permalink":"https://a154051.gitee.io/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/"},{"name":"整除分块","slug":"整除分块","permalink":"https://a154051.gitee.io/tags/%E6%95%B4%E9%99%A4%E5%88%86%E5%9D%97/"},{"name":"做题记录","slug":"做题记录","permalink":"https://a154051.gitee.io/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"Kruskal重构树","slug":"Kruskal重构树","permalink":"https://a154051.gitee.io/tags/Kruskal%E9%87%8D%E6%9E%84%E6%A0%91/"},{"name":"贪心","slug":"贪心","permalink":"https://a154051.gitee.io/tags/%E8%B4%AA%E5%BF%83/"},{"name":"模拟退火","slug":"模拟退火","permalink":"https://a154051.gitee.io/tags/%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB/"},{"name":"树","slug":"树","permalink":"https://a154051.gitee.io/tags/%E6%A0%91/"},{"name":"字符串","slug":"字符串","permalink":"https://a154051.gitee.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"后缀自动机-SAM","slug":"后缀自动机-SAM","permalink":"https://a154051.gitee.io/tags/%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA-SAM/"},{"name":"网络流","slug":"网络流","permalink":"https://a154051.gitee.io/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"},{"name":"DP","slug":"DP","permalink":"https://a154051.gitee.io/tags/DP/"}]}