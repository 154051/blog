{"meta":{"title":"a154051","subtitle":"","description":"","author":"a154051","url":"https://a154051.gitee.io","root":"/"},"pages":[{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2021-09-29T13:40:23.000Z","comments":false,"path":"about/index.html","permalink":"https://a154051.gitee.io/about/index.html","excerpt":"","text":"[さくら荘のhojun] 与&nbsp; Mashiro&nbsp; （ 真（ま）白（しろ） ） 对话中... bot_ui_ini()"},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2021-09-29T13:40:23.000Z","comments":false,"path":"donate/index.html","permalink":"https://a154051.gitee.io/donate/index.html","excerpt":"","text":""},{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2021-09-29T13:40:23.000Z","comments":false,"path":"bangumi/index.html","permalink":"https://a154051.gitee.io/bangumi/index.html","excerpt":"","text":""},{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2023-10-13T10:42:06.497Z","comments":false,"path":"client/index.html","permalink":"https://a154051.gitee.io/client/index.html","excerpt":"","text":"直接下载 or 扫码下载："},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2023-10-13T10:42:06.497Z","comments":true,"path":"comment/index.html","permalink":"https://a154051.gitee.io/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》"},{"title":"游戏","date":"2021-03-09T09:00:00.000Z","updated":"2023-10-13T10:42:06.490Z","comments":false,"path":"games/index.html","permalink":"https://a154051.gitee.io/games/index.html","excerpt":"","text":"颓废区 请自行保存存档 2048 小黑屋 flappy bird 进化 生命游戏 生命游戏介绍好东西"},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2023-10-13T10:42:06.496Z","comments":false,"path":"lab/index.html","permalink":"https://a154051.gitee.io/lab/index.html","excerpt":"","text":"sakura主题balabala"},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2023-10-13T10:42:06.495Z","comments":false,"path":"music/index.html","permalink":"https://a154051.gitee.io/music/index.html","excerpt":"","text":""},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2023-10-13T10:42:06.495Z","comments":true,"path":"links/index.html","permalink":"https://a154051.gitee.io/links/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-12-12T14:14:16.000Z","updated":"2023-11-09T02:59:24.215Z","comments":false,"path":"tags/index.html","permalink":"https://a154051.gitee.io/tags/index.html","excerpt":"","text":""},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2021-09-29T13:40:23.000Z","comments":true,"path":"rss/index.html","permalink":"https://a154051.gitee.io/rss/index.html","excerpt":"","text":""},{"title":"关于","date":"2019-01-04T14:53:25.000Z","updated":"2023-10-13T10:42:06.489Z","comments":true,"path":"theme-sakura/index.html","permalink":"https://a154051.gitee.io/theme-sakura/index.html","excerpt":"","text":"退役OI人，随便写点东西。 QQ：2279162137 微信：m2279162137 （几百年不看一回） Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro Hexo-Sakura主题 感谢ctz大佬写的教程，解决了很多问题。"},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2021-09-29T13:40:23.000Z","comments":false,"path":"video/index.html","permalink":"https://a154051.gitee.io/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }"}],"posts":[{"title":"十月做题记录","slug":"shi-yue-zuo-ti-ji-lu","date":"2023-10-24T08:10:00.000Z","updated":"2023-10-24T10:01:10.273Z","comments":true,"path":"2023/10/24/shi-yue-zuo-ti-ji-lu/","link":"","permalink":"https://a154051.gitee.io/2023/10/24/shi-yue-zuo-ti-ji-lu/","excerpt":"","text":"加星号表示看了题解。 摆烂的十月份。 P1709 [USACO5.5] 隐藏口令 Hidden Password ＊ 题目链接 最小表示法模板题，设当前比较以 $i$ 和 $j$ 开头的字符串，则对两字符串一位一位向后比较，即每次比较 $i+k$ 和 $j+k$，直到遇到不同的字符，假设 $i$ 开头的字符串更小，则令 $j$ 直接跳到 $j+k+1$，因为对于以 $j$ 到 $j+k$ 开头的字符串，都有对应的以 $i$ 到 $i+k$ 开头的字符串必它小。时间复杂度 $O( n)$。 代码 #include &lt;bits/stdc++.h&gt; using namespace std; const int N=5e6+7; char a[N]; int main() { int n; cin&gt;&gt;n; for(int i=0;i&lt;n;++i) { char ch=getchar(); while(ch&lt;&#39;a&#39;||ch&gt;&#39;z&#39;) ch=getchar(); a[i]=ch; } int i=0,j=1,k=0; while(k&lt;n&amp;&amp;i&lt;n&amp;&amp;j&lt;n) { if(a[(i+k)%n]==a[(j+k)%n]) ++k; else { a[(i+k)%n]&gt;a[(j+k)%n]?i=i+k+1:j=j+k+1; if(i==j) ++i; k=0; } } cout&lt;&lt;min(i,j); return 0; } P6310 「Wdsr-1」仓库建设题目链接 写过题解了，【题解】P6310 [Wdsr-1]仓库建设 武汉大学2023年新生程序设计竞赛（同步赛）A. 教科书般的亵渎题目链接 将 $a$ 从大到小排序，若第一项为 $0$ 或 $1$ 且后面每一项与前一项的差小于等于 $1$ 则为 $YES$，否则为 $NO$。 代码 #include &lt;bits/stdc++.h&gt; using namespace std; const int N=1e6; int a[N]; int main() { int n; cin&gt;&gt;n; for(int i=1;i&lt;=n;++i) scanf(&quot;%d&quot;,&amp;a[i]); sort(a+1,a+1+n); int last=0; for(int i=1;i&lt;=n;++i) { if(a[i]==last||a[i]==last+1) {last=a[i];continue;} cout&lt;&lt;&quot;NO&quot;; return 0; } cout&lt;&lt;&quot;YES&quot;; return 0; } C. 覆叶之交题目链接 给定三个矩形，求它们的面积并。 用容斥写，难点在代码实现。 代码 #include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; struct squ { bool flag; ll x1,x2,y1,y2; }a[20]; int tot=3,tmp[10]; void sol(squ A,squ B) { ++tot; if(A.flag||B.flag) {a[tot].flag=1;return ;} if(A.x2&lt;=B.x1||B.x2&lt;=A.x1||A.y2&lt;=B.y1||B.y2&lt;=A.y1) {a[tot].flag=1;return ;} tmp[1]=A.x1;tmp[2]=A.x2;tmp[3]=B.x1;tmp[4]=B.x2; sort(tmp+1,tmp+5); a[tot].x2=tmp[3];a[tot].x1=tmp[2]; tmp[1]=A.y1;tmp[2]=A.y2;tmp[3]=B.y1;tmp[4]=B.y2; sort(tmp+1,tmp+5); a[tot].y1=tmp[2];a[tot].y2=tmp[3]; } int main() { ll ans=0; for(int i=1;i&lt;=3;++i) { cin&gt;&gt;a[i].x1&gt;&gt;a[i].y1&gt;&gt;a[i].x2&gt;&gt;a[i].y2; ans+=abs((a[i].x1-a[i].x2)*(a[i].y1-a[i].y2)); } for(int i=1;i&lt;=3;++i) for(int j=i+1;j&lt;=3;++j) { sol(a[i],a[j]); if(a[tot].flag==0) ans-=abs((a[tot].x1-a[tot].x2)*(a[tot].y1-a[tot].y2)); } sol(a[4],a[5]);sol(a[6],a[7]); if(a[tot].flag==0) ans+=abs((a[tot].x1-a[tot].x2)*(a[tot].y1-a[tot].y2)); cout&lt;&lt;ans; return 0; } E. 不是n皇后问题题目链接 看着挺麻烦，实际上就是把 $1$ 到 $n^2$ 按顺序填进格子就行了。 代码 #include &lt;bits/stdc++.h&gt; using namespace std; const int N=1e6; int main() { int n,cnt=0; cin&gt;&gt;n; for(int i=1;i&lt;=n;++i) { for(int j=1;j&lt;=n;++j) printf(&quot;%d &quot;,++cnt); printf(&quot;\\n&quot;); } return 0; } J. 放棋子题目链接 行和列可以分开计算，对于同一行，要使分数最大，则每次落子需要相连的旗子尽可能多，因此可以从左至右依次落子，这样就可以得到这一行的最大分数。可以证明，如果从第一行到最后一行操作也可以得到列的最大分数。时间复杂度 $O(n\\times m)$。 代码 #include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int N=1e5+7; vector&lt;int&gt; a[N]; int main() { int n,m; ll ans=0; cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;++i) { a[i].push_back(0); ll now=0; for(int j=1;j&lt;=m;++j) { char ch=getchar(); while(ch!=&#39;#&#39;&amp;&amp;ch!=&#39;.&#39;) ch=getchar(); a[i].push_back(0); if(ch==&#39;#&#39;) { a[i][j]=1; ++now; ans+=now*now; } else now=0; } } for(int i=1;i&lt;=m;++i) { ll now=0; for(int j=1;j&lt;=n;++j) { if(a[j][i]) ++now,ans+=now*now; else now=0; } } cout&lt;&lt;ans; return 0; } K. 矩形分割题目链接 显然我们想要分割出来的正方形边长尽可能大，所以以矩形的短边为正方形边长进行分割直到无法分割，如果还剩下来一个小矩形，就再对这个矩形进行上述操作，直到分割完全。 代码 #include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; int sol(int n,int m) { if(n==0||m==0) return 0; if(n==m) return n; if(n&lt;m) swap(n,m); return m*(n/m)+sol(m,n%m); } int main() { int n,m; cin&gt;&gt;n&gt;&gt;m; cout&lt;&lt;sol(n,m); return 0; } L. 小镜的数学题题目链接 从 $x$ 向后暴力找，最坏也不会超过 $2x$，数据比较水就过了。 代码 #include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; int main() { ll n; cin&gt;&gt;n; for(ll i=n+1;;++i) { if((n&amp;i)==0) { cout&lt;&lt;i; return 0; } n=(n&amp;i); } return 0; } P2017 [USACO09DEC] Dizzy Cows G题目链接 给定一个图，有无向边和有向边，给每条无向边指定一个方向，并且不出现环。 考虑拓扑排序判定有向无环图的过程，每次删去出度为 $0$ 的点，若最终能删完则为有向无环图，可以发现，每条边都是由拓扑序大的指向拓扑序小的。因此在本题中先无视无向边对原图进行拓扑排序，再让无向边由拓扑序大的点指向拓扑序小的点，就得到了有向无环图。 代码 #include &lt;bits/stdc++.h&gt; using namespace std; const int N=1e5+7; vector&lt;int&gt; last[N]; int deg[N],dep[N],cnt=0; deque&lt;int&gt; q; int main() { int n,m1,m2; cin&gt;&gt;n&gt;&gt;m1&gt;&gt;m2; for(int i=1;i&lt;=m1;++i) { int x,y; scanf(&quot;%d%d&quot;,&amp;x,&amp;y); ++deg[x]; last[y].push_back(x); } for(int i=1;i&lt;=n;++i) if(!deg[i]) q.push_back(i); while(q.size()) { int x=q.front(); q.pop_front(); dep[x]=++cnt; for(int i=0;i&lt;last[x].size();++i) if((--deg[last[x][i]])==0) q.push_back(last[x][i]); } while(m2--) { int x,y; scanf(&quot;%d%d&quot;,&amp;x,&amp;y); if(dep[x]&lt;dep[y]) swap(x,y); printf(&quot;%d %d\\n&quot;,x,y); } return 0; } 2023 年华中科技大学程序设计竞赛新生赛（线上同步赛）几乎每道题都会犯sb错误，我是超级罚时王。 P9769 [HUSTFC 2023] 简单的加法乘法计算题题目链接 设 $f_i$ 表示从 $0$ 到 $i$ 的最小操作次数，考虑最后一次操作，要么是加上 $A$ 中的一个数，要么是乘上 $B$ 中的一个数，所以 $f_i=\\min\\{ \\min\\limits_{j=1}^n f_{i-A_j},\\min\\limits_{k=1}^m f_{i/B_k}\\}$，加法用堆来维护，乘法一个个枚举，时间复杂度 $O(ym\\log n)$，如果用单调队列可以降到 $O(ym)$。 代码 #include &lt;bits/stdc++.h&gt; #define mp(x,y) make_pair(x,y) typedef long long ll; using namespace std; const int N=5e6+7; int f[N],b[20]; priority_queue&lt;pair&lt;int,int&gt; &gt; q; bool vis[N]; int main() { int x,n,m; cin&gt;&gt;x&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=m;++i) scanf(&quot;%d&quot;,&amp;b[i]); vis[0]=1;q.push(mp(0,0)); for(int i=1;i&lt;=x;++i) { int tmp=q.top().second; while(!vis[tmp]) q.pop(),tmp=q.top().second; f[i]=f[tmp]+1; for(int j=1;j&lt;=m;++j) if(i%b[j]==0) f[i]=min(f[i],f[i/b[j]]+1); q.push(mp(-f[i],i)); vis[i]=1; if(i-n-1&gt;=0) vis[i-n-1]=0; } cout&lt;&lt;f[x]; return 0; } P9771 [HUSTFC 2023] 排列排序问题题目链接 显然切割出来的序列是单调的，并且相邻的两个数相差 $1$，按这个方法切割使每个切出来的序列尽可能大就行了。时间复杂度 $O(n)$。 代码 #include &lt;bits/stdc++.h&gt; typedef long long ll; using namespace std; const int N=1e6+7; int a[N]; int main() { int n; cin&gt;&gt;n; for(int i=1;i&lt;=n;++i) scanf(&quot;%d&quot;,&amp;a[i]); int flag=-1,last=a[1],ans=0; for(int i=2;i&lt;=n;++i) { if(flag==-1) { if(a[i]==last+1) flag=1,last=a[i]; else if(a[i]==last-1) flag=0,last=a[i]; else last=a[i],++ans; continue; } if(a[i]==last+1&amp;&amp;flag==1) {last=a[i];continue;} if(a[i]==last-1&amp;&amp;flag==0) {last=a[i];continue;} last=a[i];++ans; flag=-1; } cout&lt;&lt;ans; return 0; } P9774[HUSTFC 2023] 新取模运算题目链接 显然新定义的运算符满足分配律，于是对于 $n$ 到 $1$ 这 $n$ 个数，可以分为是 $p$ 的倍数和不是 $p$ 的倍数分别计算，最后再相乘。 对于不是 $p$ 的倍数的数，它们对 $p$ 进行新定义运算等价于直接对 $p$ 取模，这一部分可以通过预处理 $1$ 到 $p$ 的阶乘来求解。 对于是 $p$ 的倍数的数，例如 $p,2p,3p…kp$，它们对 $p$ 进行新定义运算需要先除以 $p$，变为 $1,2,3…k$，这就成了原问题的子问题，于是可以递归求解，边界是 $ k&lt;p$。时间复杂度 $O(\\log_p n \\times \\log n)$。 代码 #include &lt;bits/stdc++.h&gt; typedef long long ll; using namespace std; const int N=1e6+7; int p; ll jc[N]; ll qpow(ll x,ll k) {; ll ans=1,tmp=x; while(k) { if(k&amp;1) ans=ans*tmp%p; tmp=tmp*tmp%p; k&gt;&gt;=1; } return ans; } ll sol(ll n) { ll tmp=n/p; ll ans=qpow(jc[p-1],tmp)*jc[n%p]%p; if(tmp) ans=ans*sol(tmp)%p; return ans; } int main() { int T; cin&gt;&gt;T&gt;&gt;p; jc[0]=1; for(int i=1;i&lt;=p;++i) jc[i]=jc[i-1]*i%p; while(T--) { ll n; scanf(&quot;%lld&quot;,&amp;n); printf(&quot;%lld\\n&quot;,sol(n)); } return 0; } P9775 [HUSTFC 2023] 广义线段树题目链接 给定一棵 $2n-1$ 个节点的树，$1$ 是根节点，$n$ 到 $2n-1$ 是叶子节点，给定叶子节点的点权，其他节点的点权是以它为子树的所有叶子节点的乘积。令每个叶子节点乘上一个数，求最后所有节点的和。 对叶子节点乘上一个数，则从叶子节点到根节点路径上所有节点都要乘上这个数。所以原问题转化为对树上的一条链乘上一个数，可以用树链剖分，时间复杂度 $O(n\\log^2 n)$。比赛时没细想，但实际上可以先对所有叶子节点做修改，再在 dfs 返回时向上传就可以了，时间复杂度 $O(n)$。 代码 #include &lt;bits/stdc++.h&gt; typedef long long ll; using namespace std; const int N=2e6+7,mod=998244353; struct tree { ll tag,val; }tr[N&lt;&lt;1]; ll a[N],b[N]; int nx[N][2],fa[N],dep[N],siz[N],top[N],pos[N],son[N],tot=0,rev[N]; void push(int now,ll k) { tr[now].val=tr[now].val*k%mod; tr[now].tag=tr[now].tag*k%mod; return ; } void build(int now,int l,int r) { tr[now].tag=1; if(l==r) {tr[now].val=a[rev[l]];return ;} int mid=(l+r)&gt;&gt;1; build(now&lt;&lt;1,l,mid); build(now&lt;&lt;1|1,mid+1,r); tr[now].val=(tr[now&lt;&lt;1].val+tr[now&lt;&lt;1|1].val)%mod; } void mul(int now,int l,int r,int x,int y,ll k) { if(l&gt;=x&amp;&amp;r&lt;=y) { tr[now].val=tr[now].val*k%mod; tr[now].tag=tr[now].tag*k%mod; return ; } if(tr[now].tag!=1) { push(now&lt;&lt;1,tr[now].tag); push(now&lt;&lt;1|1,tr[now].tag); tr[now].tag=1; } int mid=(l+r)&gt;&gt;1; if(x&lt;=mid) mul(now&lt;&lt;1,l,mid,x,y,k); if(y&gt;mid) mul(now&lt;&lt;1|1,mid+1,r,x,y,k); tr[now].val=(tr[now&lt;&lt;1].val+tr[now&lt;&lt;1|1].val)%mod; } void dfs1(int x,int FA) { fa[x]=FA;dep[x]=dep[FA]+1;siz[x]=1; if(nx[x][0]) { dfs1(nx[x][0],x);dfs1(nx[x][1],x); siz[x]+=siz[nx[x][0]]+siz[nx[x][1]]; son[x]=siz[nx[x][0]]&gt;siz[nx[x][1]]?nx[x][0]:nx[x][1]; a[x]=a[nx[x][0]]*a[nx[x][1]]%mod; } } void dfs2(int x,int tp) { top[x]=tp;pos[x]=++tot;rev[tot]=x; if(!son[x]) return ; dfs2(son[x],tp); int tmp=nx[x][0]; if(tmp==son[x]) tmp=nx[x][1]; dfs2(tmp,tmp); } void chg(int x,ll k) { if(k==1) return ; while(x) { mul(1,1,tot,pos[top[x]],pos[x],k); x=fa[top[x]]; } } int main() { int n; cin&gt;&gt;n; for(int i=n;i&lt;=n*2-1;++i) scanf(&quot;%lld&quot;,&amp;a[i]); for(int i=1;i&lt;=n;++i) scanf(&quot;%lld&quot;,&amp;b[i]); for(int i=1;i&lt;n;++i) scanf(&quot;%d%d&quot;,&amp;nx[i][0],&amp;nx[i][1]); dfs1(1,0); dfs2(1,1); build(1,1,tot); for(int i=1;i&lt;=n;++i) { chg(i+n-1,b[i]); printf(&quot;%lld &quot;,tr[1].val); } return 0; } P9777 [HUSTFC 2023] Fujisaki 讨厌数学题目链接 已知 $x^1+x^{-1}=k$，求 $x^n+x^{-n}$。 可以发现 $(x^a+x^{-a})(x^b+x^{-b})=x^{a+b}+x^{-(a+b)}+x^{(a-b)}+x^{-(a-b)}$。设 $f_n=x^n+x^{-n}$，可以得到 $f_{(a+b)}=f_a \\times f_b-f_{(a-b)}$。因此，若 $n$ 是偶数，有 $f_n=f_{n/2}^2-f_0$，若 $n$ 是奇数，有 $f_n=f_{n/2}\\times f_{n/2+1}-f_1$。 设 $n$ 在第一层，向下拆分得到第二层，第二层要么有一个数要么有两个数，考虑两个数的情况，这两个数一定相差 $1$，将它们向下拆分，第三层仍然是两个数，并且也是相差 $1$，可以证明每一层都至多两个数。每次拆分都除以 $2$，因此有 $\\log n$ 层。可以用记忆化搜索，但是 $n$ 太大了，要用 $map$ 存，时间复杂度 $O(\\log^2 n)$。 代码 #include &lt;bits/stdc++.h&gt; typedef long long ll; using namespace std; map&lt;ll,ll&gt; mp; const int N=1e6+7; int mod; ll k; ll sol(ll n) { if(n==1) return k; if(mp.find(n)!=mp.end()) return mp[n]; ll ans=1; if(n&amp;1) ans=sol(n/2)*sol(n/2+1)%mod-k; else ans=sol(n/2),ans=ans*ans%mod-2; while(ans&lt;0) ans+=mod; mp[n]=ans; return ans; } int main() { ll n; cin&gt;&gt;mod&gt;&gt;k&gt;&gt;n; if(n==0) cout&lt;&lt;&quot;2&quot;; else printf(&quot;%lld&quot;,sol(n)); return 0; } P9779 [HUSTFC 2023] 不定项选择题题目链接 $n$ 道题一共有 $2^n$ 种情况，除去全都不选的情况，最坏情况是最后一次才试出来，即要试 $2^n-1$ 次。其实我是看样例猜出来的结论 代码 #include &lt;bits/stdc++.h&gt; typedef long long ll; using namespace std; const int N=2e5+7; int main() { int n,ans=1; cin&gt;&gt;n; for(int i=1;i&lt;=n;++i) ans*=2; cout&lt;&lt;ans-1; return 0; } P9780 [HUSTFC 2023] Azur Lane题目链接 先考虑怎样使天数最小，一天内放置的喵箱等级是一个不上升序列，因此将序列划分为多个不上升序列，使每个序列尽可能大，就得到了天数最小的情况。 之后天数每增加一，就需要从已划分的序列中再划分出一个序列，同时使花费最少，显然天数靠前的喵箱越多花费就越多，因此我们希望喵箱尽可能放在后面，于是可以从第一天开始向后找到第一个序列长度大于 $1$ 的序列，将它划分出一个数，最后将答案加上天数增加导致前面喵箱增加的花费。时间复杂度 $O(n)$。 代码 #include &lt;bits/stdc++.h&gt; typedef long long ll; using namespace std; const int N=1e6+7; int a[N]; ll b[N]; int main() { int m,k,tot=1; ll ans=0; cin&gt;&gt;m&gt;&gt;k; for(int i=1;i&lt;=m;++i) scanf(&quot;%d&quot;,&amp;a[i]); b[1]=1; for(int i=2;i&lt;=m;++i) { if(a[i]&lt;=a[i-1]) ++b[tot]; else b[++tot]=1; } for(int i=1;i&lt;=tot;++i) ans+=b[i]*(tot-i+1); int now=1,totlast=0; for(int i=1;i&lt;=m;++i) { if(i&lt;tot) {printf(&quot;-1 &quot;);continue;} if(i==tot) {printf(&quot;%lld &quot;,ans);continue;} while(b[now]==1) ++totlast,++now; --b[now];++totlast; ans+=totlast; printf(&quot;%lld &quot;,ans); } return 0; } P9782 [HUSTFC 2023] A+B problem题目链接 签到题，$26$ 进制加法。 代码 #include &lt;bits/stdc++.h&gt; typedef long long ll; using namespace std; const int N=2e5+7; int main() { char ch1,tmp,ch2; scanf(&quot;%c%c%c&quot;,&amp;ch1,&amp;tmp,&amp;ch2); int k=ch1-&#39;A&#39;+ch2-&#39;A&#39;; if(k&gt;=26) { k-=26;cout&lt;&lt;&#39;B&#39;; } cout&lt;&lt;char(k+&#39;A&#39;); return 0; }","categories":[{"name":"题解","slug":"题解","permalink":"https://a154051.gitee.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"做题记录","slug":"做题记录","permalink":"https://a154051.gitee.io/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"}],"author":"a154051"},{"title":"【题解】P6310 [Wdsr-1]仓库建设","slug":"solution-P6310-cang-ku-jian-she","date":"2023-09-25T15:17:51.000Z","updated":"2023-10-13T12:58:30.089Z","comments":true,"path":"2023/09/25/solution-P6310-cang-ku-jian-she/","link":"","permalink":"https://a154051.gitee.io/2023/09/25/solution-P6310-cang-ku-jian-she/","excerpt":"","text":"P6310 「Wdsr-1」仓库建设 两年没写题解了，本来想找个蓝题练练手，结果被狠狠薄纱了，硬刚了半天才写出来。变量名极为抽象，写到后面我自己都搞混了。 题意给定一张无向联通图，边有边权，可以选择一些城市发出粮车，第 $i$ 座城市的粮车的油量可以行驶的路程为 $x_i$，每到一个城市都会加满油，第一问为求最少选择几个城市可以覆盖所有城市，第二问为当第 $i$ 个城市无法选择时最少选择多少城市才能满足条件，如果不能则输出 $-1$。 题解显然我们希望路径中最大的边权最小，自然想到了 Kruskal 重构树，重构树的叶子节点为原图的 $n$ 个节点，其他节点代表原图的一条边，点权即是边权，深度越浅的点点权越大。 设 $val$ 表示点权，从某个叶子节点 $i$ 向上找到最浅的节点 $j$ 满足 $val_j \\le x_i$，记为 $fa_i$，如果选择了 $i$，则以 $fa_i$ 为根的子树的叶子节点都可以被覆盖。显然如果某条路径上有多个 $fa_i$ 我们要选择深度最浅的那个，则该子树内的其他点都不用选。 所以第一问只需要从根节点向下遍历，遇到 $fa$ 节点就将计数器加一，并直接返回，不用遍历该子树。 对于第二问，假设当前无法选择的节点为 $i$，如果 $fa_i$ 不是第一问选择的节点，则答案不变。 如果从 $i$ 到根的路径上只有 $fa_i$，若 $\\exists j \\neq i,fa_j = fa_i$ 则答案不变，若这样的 $j$ 不存在，则无法到达 $i$，答案为 $-1$。 如果 $fa_i$ 是第一问选择的节点且从 $i$ 到根的路径上还有其他的 $fa$，则只需要在 $fa_i$ 子树内选择深度最浅的几个 $fa$ 节点就能覆盖所有点，像第一问一样在 $fa_i$ 的子树内遍历，遇到 $fa$ 节点就将计数器加一，并直接返回，不用遍历该子树，最后将第一问的答案减一再加上计数器就是最终答案。 向上找 $fa$ 用倍增实现，其他值都可以一次 dfs 求出来，总时间复杂度为 $O(n \\log n)$。 代码#include &lt;bits/stdc++.h&gt; using namespace std; const int N=3e5+7; struct edge &#123; int u,v,w; &#125;e[N]; int a[N],fa[N],val[N&lt;&lt;1],f[N&lt;&lt;1][21],dep[N&lt;&lt;1],cnt[N&lt;&lt;1],num[N],leaf[N&lt;&lt;1],up[N&lt;&lt;1]; //cnt是统计某个fa节点的子树内有多少个深度最浅的fa节点，num是从叶子节点到根有多少fa节点 //leaf是某个fa节点对应的叶子节点有几个，up是距离fa节点最近的祖先fa节点 bool vis[N&lt;&lt;1]; vector&lt;int&gt; son[N&lt;&lt;1]; bool cmp(edge x,edge y)&#123;return x.w&lt;y.w;&#125; int fd(int x) &#123; if(!fa[x]) return x; return fa[x]=fd(fa[x]); &#125; void dfs1(int x,int FA) &#123; dep[x]=dep[FA]+1;f[x][0]=FA; for(int i=0;i&lt;son[x].size();++i) dfs1(son[x][i],x); &#125; void dfs2(int x,int FA,int CNT) &#123; if(vis[x]) ++cnt[FA],++CNT,up[x]=FA; for(int i=0;i&lt;son[x].size();++i) &#123; if(vis[x]) dfs2(son[x][i],x,CNT); else dfs2(son[x][i],FA,CNT); &#125; if(!son[x].size()) num[x]=CNT; &#125; int main() &#123; int n,m; cin&gt;&gt;n&gt;&gt;m; int tot=n; for(int i=1;i&lt;=m;++i) scanf(&quot;%d%d%d&quot;,&amp;e[i].u,&amp;e[i].v,&amp;e[i].w); sort(e+1,e+1+m,cmp); for(int i=1;i&lt;=m;++i) &#123; int x=fd(e[i].u),y=fd(e[i].v); if(x!=y) &#123; fa[x]=fa[y]=++tot; son[tot].push_back(x); son[tot].push_back(y); val[tot]=e[i].w; &#125; &#125; for(int i=1;i&lt;=n;++i) scanf(&quot;%d&quot;,&amp;a[i]); dfs1(tot,0); for(int j=1;j&lt;=20;++j) for(int i=1;i&lt;=tot;++i) f[i][j]=f[f[i][j-1]][j-1]; for(int i=1;i&lt;=n;++i) &#123; int now=i; for(int j=20;j&gt;=0;--j) if(f[now][j]&amp;&amp;a[i]&gt;=val[f[now][j]]) now=f[now][j]; vis[now]=1; fa[i]=now; ++leaf[now]; &#125; dfs2(tot,0,0); printf(&quot;%d &quot;,cnt[0]); for(int i=1;i&lt;=n;++i) &#123; if(num[i]==1&amp;&amp;leaf[fa[i]]&lt;=1) printf(&quot;-1 &quot;); else if(up[fa[i]]||leaf[fa[i]]&gt;1) printf(&quot;%d &quot;,cnt[0]); else printf(&quot;%d &quot;,cnt[0]-1+cnt[fa[i]]); &#125; return 0; &#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://a154051.gitee.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"Kruskal重构树","slug":"Kruskal重构树","permalink":"https://a154051.gitee.io/tags/Kruskal%E9%87%8D%E6%9E%84%E6%A0%91/"}],"author":"a154051"},{"title":"【题解】P4331 [BalticOI 2004]Sequence","slug":"solution-P4331-sequence","date":"2021-09-25T08:35:02.000Z","updated":"2023-10-13T10:42:06.491Z","comments":true,"path":"2021/09/25/solution-P4331-sequence/","link":"","permalink":"https://a154051.gitee.io/2021/09/25/solution-P4331-sequence/","excerpt":"","text":"P4331 [BalticOI 2004]Sequence 数字序列 好多题解都是用的中位数做法，其实贪心就可以直接做。 题意给定一个长度为 $n$ 的整数序列 $a$，求出一个严格递增整数序列 $b$，使得 $\\sum^n_{i=1}\\left\\vert a_i-b_i\\right\\vert$ 最小。 做法首先给 $b$ 赋一个初值，使得 $b_i\\le a_i(i\\in n)$ 并且 $b_i=b_{i-1}+1(i\\in [2,n])$。 在这种情况下，要想使答案更优只能增大 $b$ 序列或不变。 因为 $b$ 严格递增，并且 $b_i=b_{i-1}+1$，所以要想使 $b_i$ 增加 $x$，就要对 $[i,n]$ 整个区间加上 $x$。 定义 $val_i=\\begin{cases}1&amp;a_i&gt;b_i \\\\ -1&amp;a_i\\le b_i\\end{cases}$，$sum_i=\\sum\\limits_{j=i}^n val_j$。 然后重复执行下列操作： 在 $[1,n]$ 中找到最大的 $sum$ 的位置 $k$，可以发现 $b_i=b_{i-1}+1(i\\in[k+1,n])$，证明在下面。 设 $x=\\min\\{a_i-b_i \\}(i\\in[k,n],a_i-b_i&gt;0)$，令 $b_i+x(i\\in[k,n])$。 更新 $val$ 和 $sum$。 直到所有的 $sum$ 都小于等于 $0$。 正确性证明： 对初始序列 $b$ 执行一遍该操作显然正确。 记 $last$ 为上一次操作中最大的 $sum$ 的位置，$k$ 为这次操作中最大的 $sum$ 的位置。 可以得到，对于任意的 $i\\in [1,last-1]$，都有 $sum_i\\le sum_{last}$。 在上一次操作中，$[last,n]$ 中至少会有一个位置的 $val$ 变为 $-1$，则 $sum_i(i\\in[1,last-1])$ 只会变得更小，所以 $k$ 不可能在 $[1,last-1]$ 中，$k$ 只会越来越靠右，因此 $b_i=b_{i-1}+1(i\\in[k+1,n])$，所以对 $b_i(i\\in [k,n])$ 执行该操作显然也正确。 证毕。 用线段树维护 $sum$，$set$ 维护 $[k,n]$ 中 $a_i-b_i(i\\in[k,n])$ 大于 $0$ 的元素。 每次操作用线段树求出 $[1,n]$ 中最大的 $sum$ 的位置 $k$，将 $set$ 中位置在 $[1,k-1]$ 的元素删除，在 $set$ 中查询此时 $a_i-b_i$ 的最小值，将等于该值的元素删除，并在线段树上将区间 $[1,\\text{该元素位置}]$ 中所有 $sum$ 减 $1$。 由于不会添加元素，所以 $set$ 至多有 $n$ 次删除操作，线段树至多有 $n$ 次修改操作。 时间复杂度为 $O(n\\log n)$。 复杂度虽然正确，但常数有点大，时间卡得很紧，要开 $O2$ 才能过。 代码#include &lt;bits/stdc++.h&gt; #define mk(x,y) make_pair(x,y) #define ls now&lt;&lt;1 #define rs now&lt;&lt;1|1 using namespace std; typedef long long ll; const int mn=1e6+7; struct tree &#123; int ans,mx,tag; &#125;tr[mn&lt;&lt;2]; int a[mn],sum[mn],val[mn]; ll b[mn]; set&lt;pair&lt;ll,int&gt; &gt; st; int in() &#123; int x=0; char c=getchar(); while(!isdigit(c)) c=getchar(); while(isdigit(c)) &#123; x=x*10+c-&#39;0&#39;; c=getchar(); &#125; return x; &#125; void upd(int now) &#123; if(tr[rs].mx&gt;=tr[ls].mx) tr[now].mx=tr[rs].mx,tr[now].ans=tr[rs].ans; else tr[now].mx=tr[ls].mx,tr[now].ans=tr[ls].ans; &#125; void build(int now,int l,int r) &#123; if(l==r) &#123; tr[now].mx=sum[l]; tr[now].ans=l; return ; &#125; int mid=(l+r)&gt;&gt;1; build(now&lt;&lt;1,l,mid); build(now&lt;&lt;1|1,mid+1,r); upd(now); &#125; void push(int now) &#123; if(!tr[now].tag) return ; tr[now&lt;&lt;1].mx+=tr[now].tag; tr[now&lt;&lt;1].tag+=tr[now].tag; tr[now&lt;&lt;1|1].mx+=tr[now].tag; tr[now&lt;&lt;1|1].tag+=tr[now].tag; tr[now].tag=0; &#125; void add(int now,int l,int r,int x,int v) &#123; if(r&lt;=x) &#123; tr[now].mx+=v; tr[now].tag+=v; return ; &#125; push(now); int mid=(l+r)&gt;&gt;1; if(x&gt;mid) add(now&lt;&lt;1|1,mid+1,r,x,v); add(now&lt;&lt;1,l,mid,x,v); upd(now); &#125; int main() &#123; int n,mi=1; n=in(); ll ans=0; for(int i=1;i&lt;=n;++i) &#123; a[i]=in(); mi=min(mi,a[i]-i+1); &#125; for(int i=1;i&lt;=n;++i) &#123; b[i]=mi+i-1; ans+=abs(b[i]-a[i]); if(b[i]&lt;a[i]) val[i]=1,st.insert(mk(a[i]-b[i],i)); else val[i]=-1; &#125; sum[n]=val[n]; for(int i=n-1;i&gt;=1;--i) sum[i]=sum[i+1]+val[i]; build(1,1,n); int last=1,cnt=0; while(1) &#123; if(tr[1].mx&lt;=0)&#123; //终止条件 for(int i=last;i&lt;=n;++i) b[i]+=cnt; break; &#125; int now=tr[1].ans; //最大的 sum 的位置 for(int i=last;i&lt;now;++i)&#123; //删除 set 中多余的元素 b[i]+=cnt; if(a[i]-b[i]-cnt&gt;0) st.erase(mk(a[i]-b[i],i)); &#125; last=now; ans-=tr[1].mx*((*st.begin()).first-cnt); cnt=(*st.begin()).first; while(st.size()) //删除 a-b 等于 0 的元素 &#123; pair&lt;ll,int&gt; it=*st.begin(); if(it.first!=cnt) break; add(1,1,n,it.second,-2); //维护 sum st.erase(st.begin()); &#125; &#125; printf(&quot;%lld\\n&quot;,ans); for(int i=1;i&lt;=n;++i) printf(&quot;%lld &quot;,b[i]); return 0; &#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://a154051.gitee.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"https://a154051.gitee.io/tags/%E8%B4%AA%E5%BF%83/"}],"author":"a154051"},{"title":"【题解】P3291 [SCOI2016]妖怪","slug":"solution-P3291-yao-guai","date":"2021-09-01T12:11:16.000Z","updated":"2023-10-13T10:42:06.494Z","comments":true,"path":"2021/09/01/solution-P3291-yao-guai/","link":"","permalink":"https://a154051.gitee.io/2021/09/01/solution-P3291-yao-guai/","excerpt":"","text":"蒟蒻不会凸包，于是用模拟退火过了这道题。 如果你还不会模拟退火，可以看看我之前写的学习笔记。 题意来自辰星凌的题解： 给出 $n$ 个点 $(x_i,y_i)$，设 $f_i(a,b)=x_i+y_i+\\frac{bx_i}{a}+\\frac{ay_i}{b}$，求出一组 $(a,b)$，使得 $\\max\\{f_{i\\in[1,n]}(a,b)\\}$ 最小，输出这个最小值。 做法正常模拟退火流程，每次随机生成两个数 $(a,b)$，暴力遍历一遍所有点计算出当前的答案，与上一次的答案比较。 蒟蒻一开始只是想骗点分，没想到拿了 $80$ 分，于是就进入了痛苦的调参过程。（注：没有在洛谷提交，洛谷数据不全。） 最初提交时总是第 $7$ 个点错，后来有一次分比较低，但是第 $7$ 个点对了，我比较了一下认为是初始温度的问题，初始温度低会导致生成出来的数的范围小，而那个点最优情况下的 $(a,b)$ 大于这个范围，所以就一直错。 于是稍微修改一下参数就 $A$ 了，最后一共提交了 $172$ 次… 不开 $O2$ 会 $T$，时间复杂度 $O(\\text{玄学})$。 代码#include &lt;bits/stdc++.h&gt; #define rd t*(rand()*2-RAND_MAX) #define max(x,y) (x&lt;y?y:x) //这里是个小优化，会快一点 using namespace std; typedef long long ll; const double eps=1e-6,down=0.89; const int mn=1e6+7; int n; double x[mn],y[mn]; double sol(double a,double b) &#123; double rs=0; for(int i=1;i&lt;=n;++i) &#123; double tmp=x[i]+y[i]+x[i]/a*b+y[i]/b*a; rs=max(rs,tmp); &#125; return rs; &#125; int main() &#123; srand(154051); scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;++i) scanf(&quot;%lf%lf&quot;,&amp;x[i],&amp;y[i]); ll a=1,b=1; double ans,minn; minn=ans=sol(1,1); for(double t=1100000;t&gt;eps;t*=down) &#123; ll aa=a+rd,bb=b+rd; if(aa==0) aa++; if(bb==0) bb++; if(aa&lt;0) aa=-aa; if(bb&lt;0) bb=-bb; double rs=sol(aa,bb); if(minn&gt;rs) minn=rs; if(rs&lt;ans||exp((ans-rs)/t)*RAND_MAX&gt;rand()) &#123; ans=rs; a=aa;b=bb; &#125; &#125; printf(&quot;%.4f&quot;,minn); return 0; &#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://a154051.gitee.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"模拟退火","slug":"模拟退火","permalink":"https://a154051.gitee.io/tags/%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB/"}],"author":"a154051"},{"title":"【题解】P3761 [TJOI2017]城市","slug":"solution-P3761-city","date":"2021-08-08T12:31:36.000Z","updated":"2023-10-13T10:42:06.491Z","comments":true,"path":"2021/08/08/solution-P3761-city/","link":"","permalink":"https://a154051.gitee.io/2021/08/08/solution-P3761-city/","excerpt":"","text":"P3761 [TJOI2017]城市 前排提醒：本文着重证明了 $O(n)$ 的做法，$O(n^2)$ 的做法讲得不是很明白。 题意给一颗有边权的树，删去一条边并加上一条权值相同的边（要求操作后还是一颗树），求树的直径最小是多少。 $n\\le 5000$。 题解很妙的一道题，主要难点在于结论的寻找和证明。 最朴素的做法是枚举每条要删除的边，整棵树被分为了两颗子树，再枚举两颗子树上选的点，计算直径。时间复杂度 $O(n^4)$。 $O(n^2)$ 做法新加入一条边后，新树的直径有两种情况： 直径在分出来的两颗树中的一个。 直径经过了新加入的边。 对于第一种情况，新加入的边不会产生影响。 对于第二种情况，要想办法连边使得新树的直径最小。可以发现两棵树要连的点都是树的中心（即该点到其他节点的最远距离最小）。 考虑 $DP$，第一遍 $\\text{dfs}$ 求出在该节点子树内从它出发的最远和次远距离。 第二遍 $\\text{dfs}$ 根据父亲的信息求出在整棵树中从该节点出发的最远和次远距离，在这个过程中找出树的中心。 所以优化后的做法为枚举每条要删除的边，求出分出来的两颗树的直径和中心，比较这三个值，取最大。时间复杂度 $O(n^2)$。 这个复杂度已经可以通过这道题了，但是还能继续优化到 $O(n)$。 $O(n)$ 做法时间复杂度的瓶颈主要在 $DP$，考虑优化。 结论一：树的中心是树的直径的（带权）中点。 证明： 对于直径上任意一点 $u$，显然从 $u$ 出发的最远路径一定在直径上，若要求直径中心则只需比较 $u$ 到直径两端的最远距离，所以直径中点 $mid$ 是该直径的中心。 对于不在直径上的点 $v$，从 $v$ 出发到 $mid$，再到直径较远一端的所走路程，必然比直接从 $mid$ 出发的所走路程远。根据定义，树的中心要到其他点的最远距离最小，所以 $v$ 不是树的中心。 综上，$mid$ 是树的中心。证毕。 问题就转化为了如何求树的直径的中点。 对于删边操作，可以发现只有删原树直径上的边才有意义，因为删其他边直径没有变。 所以从直径一端出发到另一端依次删除边。但是每次都要遍历整棵树求直径中点，时间复杂度还是没有变，考虑优化。 以下只针对删边后的两颗树中的一个分析，另一个同理。 结论二：对于一颗分割出来的树，它直径的一端一定是原树直径的一端。 证明： 反证法，如图， 删边后得到了以 $C$ 为根的子树，假设 $EF$ 该树的直径，说明 $\\text{dis}(E,F)&gt;\\text{dis}(A,B)$，$\\text{dis}(E,F)+\\text{dis}(B,E)&gt;\\text{dis}(A,B)$，则 $FD$ 比 $AD$ 更长，与 $AD$ 是原树直径矛盾，该假设不成立，所以 $A$ 一定是删边后树的直径的一端。证毕。 考虑如何快速维护删边后树的直径： （图片来自getchar123的题解） （橙色为截掉的边，绿色为直径，右图紫色的点为重复遍历的点，红色为新遍历的点） 在遍历删边的过程中，如果每次都遍历整棵树，会有大量重复节点（紫色点），根据结论二，我们只需要考虑经过新加进来的 原树直径上的点 能否得到更长的路径。 即从 $10$ 号点出发遍历红色点，找到最长路径，加上 $\\text{dis}(1,10)$，与原来的直径比较。 这样每次都只需要遍历新加进来的节点，维护直径的总时间复杂度优化到了 $O(n)$。 但是每次维护直径中点都要遍历一遍直径，时间复杂度还是 $O(n^2)$，继续优化。 结论三：对于分割出来的树，它的直径中点一定在原树直径上。 证明： 如图，删边后的树的直径一定是形如这个样子， 分割出来的树的直径和原树的直径的重叠部分一定大于非重叠部分，即 $\\text{dis}(A,B)&gt;\\text{dis}(E,B)$，如果不是，则路径 $ED$ 就会比原树直径还长。 根据直径中点的定义，中点一定在路径 $AB$ 上。证毕。 可以发现删边过程中，分割出来的树的直径是不下降的，新树和原树的重叠部分也是不下降的。 所以每次只需要从上一次的中点开始，在原树直径上向后遍历，直到当前点比上一个点劣时停止（再往后只会更劣）。维护中点的总时间复杂度为 $O(n)$。 综上，该算法的时间复杂度为 $O(n)$。 这里只维护了分割出来的其中一棵树，对于另一棵树可以倒过来重复这些操作。 代码#include &lt;bits/stdc++.h&gt; using namespace std; const int mn=5e3+7; struct node &#123; int mid,len_L,len_R; //分别是中点，直径，半径（中点到其他点的最远距离） &#125;ans[3][mn]; int tt=0,fr[mn],nx[mn*2],to[mn*2],w[mn*2]; int rt=1,rt2=1,maxlen=0,d[mn],mx=0; int q[mn],top=0; //存直径上所有点 bool vis[mn]; void add(int x,int y,int v) &#123; ++tt; nx[tt]=fr[x]; fr[x]=tt; to[tt]=y; w[tt]=v; &#125; void findrt(int x,int fa,int dis) &#123; if(dis&gt;maxlen) maxlen=dis,rt=x; for(int i=fr[x];i;i=nx[i]) if(to[i]!=fa) findrt(to[i],x,dis+w[i]); &#125; void findrt2(int x,int fa,int dis) &#123; d[x]=dis; if(dis&gt;maxlen) maxlen=dis,rt2=x; for(int i=fr[x];i;i=nx[i]) if(to[i]!=fa) findrt2(to[i],x,dis+w[i]); &#125; void deep(int x,int fa,int dis) &#123; d[x]=dis; for(int i=fr[x];i;i=nx[i]) if(to[i]!=fa) deep(to[i],x,dis+w[i]); &#125; bool dfs(int x,int fa,int dis) &#123; q[++top]=x; if(x==rt2) return 1; for(int i=fr[x];i;i=nx[i]) &#123; int y=to[i]; if(y==fa) continue; bool flag=dfs(y,x,dis+w[i]); if(flag) return 1; &#125; --top; return 0; &#125; void dfs2(int x,int dis) &#123; vis[x]=1; mx=max(mx,dis); for(int i=fr[x];i;i=nx[i]) &#123; int y=to[i]; if(vis[y]) continue; dfs2(y,dis+w[i]); &#125; &#125; void sol(int k) &#123; memset(vis,0,sizeof(vis)); for(int i=1;i&lt;=top;++i) vis[q[i]]=1; int mid=1,len_L=0,len_R=0; ans[k][1]=(node)&#123;mid,len_L,len_R&#125;; for(int i=2;i&lt;top;++i) &#123; mx=0; dfs2(q[i],0); //遍历新加进来的节点 if(d[q[i]]-d[q[1]]+mx&lt;=len_L) ans[k][i]=(node)&#123;mid,len_L,len_R&#125;; else &#123; len_L=d[q[i]]-d[q[1]]+mx; len_R=max(d[q[mid]]-d[q[1]],len_L-d[q[mid]]-d[q[1]]); for(int j=mid+1;j&lt;=i;++j) &#123; int dis=max(d[q[j]]-d[q[1]],len_L-d[q[j]]-d[q[1]]); if(dis&gt;len_R) break; //这里就直接跳出，后面只会更劣 len_R=dis;mid=j; &#125; ans[k][i]=(node)&#123;mid,len_L,len_R&#125;; &#125; &#125; &#125; int main() &#123; int n; cin&gt;&gt;n; for(int i=1;i&lt;n;++i) &#123; int x,y,v; scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;v); add(x,y,v); add(y,x,v); &#125; findrt(1,0,0); //找直径一端 maxlen=0; findrt2(rt,0,0); //找另一端 maxlen=0; dfs(rt,0,0); //存直径 sol(1); /***************以下为倒过来处理另一棵树***************/ memset(d,0,sizeof(d)); top=0; swap(rt,rt2); deep(rt,0,0); //根变了，深度也要重新求 dfs(rt,0,0); sol(2); int ANS=1e9; for(int i=1;i&lt;top;++i) ANS=min(ANS,max(d[q[i+1]]-d[q[i]]+ans[2][i].len_R+ans[1][top-i].len_R,max(ans[2][i].len_L,ans[1][top-i].len_L))); cout&lt;&lt;ANS; return 0; &#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://a154051.gitee.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"树","slug":"树","permalink":"https://a154051.gitee.io/tags/%E6%A0%91/"}],"author":"a154051"},{"title":"【题解】P4248 [AHOI2013]差异","slug":"solution-P4248-cha-yi","date":"2021-07-17T11:49:52.000Z","updated":"2023-10-13T10:42:06.493Z","comments":true,"path":"2021/07/17/solution-P4248-cha-yi/","link":"","permalink":"https://a154051.gitee.io/2021/07/17/solution-P4248-cha-yi/","excerpt":"","text":"题意给一个长度为 $n$ 的字符串，求 \\sum\\limits_{1\\le i","categories":[{"name":"题解","slug":"题解","permalink":"https://a154051.gitee.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"https://a154051.gitee.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"后缀自动机-SAM","slug":"后缀自动机-SAM","permalink":"https://a154051.gitee.io/tags/%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA-SAM/"}],"author":"a154051"},{"title":"【题解】P2472 [SCOI2007]蜥蜴","slug":"solution-P2472-xi-yi","date":"2021-03-05T08:36:55.000Z","updated":"2023-10-13T10:42:06.491Z","comments":true,"path":"2021/03/05/solution-P2472-xi-yi/","link":"","permalink":"https://a154051.gitee.io/2021/03/05/solution-P2472-xi-yi/","excerpt":"","text":"P2472 [SCOI2007]蜥蜴 网络瘤，毒瘤的瘤。 蒟蒻第一次不看题解写出来网络瘤（然而还是逃不过debug半天的命运）。 题意在 $r\\times c$ 的网格中，每个格子都有高度，高度为 $0$ 则不存在，一些格子上有蜥蜴，蜥蜴可以跳到直线距离不超过 $d$ 的格子上，每跳一次，原来的格子高度就会减一，求最少有几只蜥蜴不能逃离。 分析显然，每个格子跳了一定次数后就不能再跳了，那么如何在网络流中加入这个限制呢？ 假设原来的点编号为 $i$，高度为 $h$，总共 $n$ 个点，我们可以把这个点拆成两个，编号为 $i$ 和 $i+n$，$i$ 负责原来这个点的入边，$i+n$ 负责出边，再连一条从 $i$ 到 $i+n$ 容量为 $h$ 的边，如图： 这个思想类似于最小割点问题。 建图注：以下说的点都是高度大于 $0$ 的点，高度为 $0$ 的点直接忽略。 对于每个点都将其拆为入点和出点，容量为格子高度。 对于能跳出网格的点，从它的出点到汇点连一条容量无穷大的边。 对于有蜥蜴的点，从源点到它的入点连一条容量为 $1$ 的边（因为每个点上最多有 $1$ 个蜥蜴）。 其中，源点和汇点都是原图中不存在的，需要另外新建。 最后跑最大流，得到最多能逃离的蜥蜴数，用蜥蜴总数减去最大流即为所求答案。 代码#include &lt;bits/stdc++.h&gt; using namespace std; const int mn=407,inf=1e7; struct node&#123; int x,y; &#125;; vector&lt;node&gt; p; int n,m,d,tot=0,num[27][27],q[2*mn],dep[2*mn]; int fr[2*mn],fr2[2*mn],nx[100*mn],to[100*mn],val[100*mn],tt=1; void add(int x,int y,int w) &#123; ++tt; nx[tt]=fr[x]; fr[x]=tt; to[tt]=y; val[tt]=w; &#125; bool bfs() &#123; for(int i=0;i&lt;=n*m*2+1;++i) dep[i]=0,fr2[i]=fr[i]; //0 为源点，2*n*m+1 为汇点 int h=1,t=1; q[1]=0;dep[0]=1; while(h&lt;=t) &#123; int u=q[h]; for(int i=fr[u];i;i=nx[i]) &#123; int v=to[i]; if(dep[v]||!val[i]) continue; q[++t]=v; dep[v]=dep[u]+1; if(v==n*m*2+1) return 1; &#125; ++h; &#125; return 0; &#125; int dfs(int u,int in) &#123; if(u==n*m*2+1) return in; int out=0; for(int &amp;i=fr2[u];i;i=nx[i]) //当前弧优化，i 是引用，当 i 变化时 fr2 也会跟着变化 &#123; int v=to[i]; if(dep[u]==dep[v]-1&amp;&amp;val[i]) &#123; int rs=dfs(v,val[i]&lt;in?val[i]:in); val[i]-=rs;val[i^1]+=rs; out+=rs;in-=rs; if(!in) break; &#125; &#125; if(out==0) dep[u]=0; return out; &#125; inline int dist(node v0,node v1)&#123;return (v0.x-v1.x)*(v0.x-v1.x)+(v0.y-v1.y)*(v0.y-v1.y);&#125; //求两点的直线距离 int main() &#123; scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;d); for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=m;++j) &#123; num[i][j]=++tot; int x; scanf(&quot;%1d&quot;,&amp;x); if(x==0) continue; add(num[i][j],num[i][j]+n*m,x); //拆点 add(num[i][j]+n*m,num[i][j],0); p.push_back((node)&#123;i,j&#125;); if(i-d&lt;1||j-d&lt;1||i+d&gt;n||j+d&gt;m) add(num[i][j]+n*m,2*n*m+1,inf),add(2*n*m+1,num[i][j]+n*m,0); //连汇点 &#125; for(int i=0;i&lt;p.size()-1;++i) //建图 for(int j=i+1;j&lt;p.size();++j) &#123; if(dist(p[i],p[j])&gt;d*d) continue; node v0=p[i],v1=p[j]; add(num[v0.x][v0.y]+n*m,num[v1.x][v1.y],inf); add(num[v1.x][v1.y],num[v0.x][v0.y]+n*m,0); add(num[v1.x][v1.y]+n*m,num[v0.x][v0.y],inf); add(num[v0.x][v0.y],num[v1.x][v1.y]+n*m,0); &#125; int cnt=0; for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=m;++j) &#123; char ch=getchar(); while(ch!=&#39;.&#39;&amp;&amp;ch!=&#39;L&#39;) ch=getchar(); if(ch==&#39;L&#39;) ++cnt,add(0,num[i][j],1),add(num[i][j],0,0); //连源点 &#125; int ans=0; while(bfs()) ans+=dfs(0,inf); cout&lt;&lt;cnt-ans; return 0; &#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://a154051.gitee.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"网络流","slug":"网络流","permalink":"https://a154051.gitee.io/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"}],"author":"a154051"},{"title":"【题解】P2467 [SDOI2010]地精部落","slug":"solution-P2467-bu-luo","date":"2021-03-03T13:40:32.000Z","updated":"2023-10-13T10:42:06.491Z","comments":true,"path":"2021/03/03/solution-P2467-bu-luo/","link":"","permalink":"https://a154051.gitee.io/2021/03/03/solution-P2467-bu-luo/","excerpt":"","text":"P2467 [SDOI2010]地精部落 题意给 $n$ 座高度连续的山脉，即高度为 $1,2,3,···,n$，求有几种方案使得山脉的高度一高一低或一低一高（即波动数列）。答案对 $p$ 取模。 分析显然，若要求 $k$ 座山脉的波动数列，无论它们的高度是否连续，只要高度互不相同，方案数都是一样的。 举个例子：求 $3$ 座山脉的波动数列，$(1,2,3)$ 和 $(1,3,5)$ 和 $(15,40,51)$的方案数都是一样的。 定义 $f(i,j,0)$ 表示前 $i$ 座山脉中，排名为 $j$ 的山脉放在最后面并且是山谷的方案数（$1$ 表示是山峰）。则最后答案为 $\\sum_{j=1}^{n} f(n,j,0)+f(n,j,1)$。 若 $j$ 是山谷，则方案为剩下的 $i-1$ 座山脉中排名从 $j$ 到 $i-1$ 的山脉放后面并且做山峰的方案之和。$j$ 是山峰也同理。 所以有状态转移方程： f(i,j,1)=\\sum\\limits_{k=1}^{j-1}f(i-1,k,0)f(i,j,0)=\\sum\\limits_{k=j}^{i-1}f(i-1,k,1)时间复杂度为 $O(n^3)$，会超时。 可以发现最里面一层循环可以用前缀和优化。 定义 $sum0(i,j)=\\sum\\limits_{x=1}^{j}f(i,x,0)$，$sum1(i,j)$ 同理，则原转移方程可化为： f(i,j,1)=sum0(i-1,j-1)f(i,j,0)=sum1(i-1,i-1)-sum1(i-1,j-1)时间复杂度为 $O(n^2)$。 因为 $f$ 和 $sum$ 只用到了当前一层和上一层，所以只存这两层就好，空间复杂度为 $O(n)$。 代码#include &lt;bits/stdc++.h&gt; using namespace std; const int mn=4207; long long f[mn][2],sum0[2][mn],sum1[2][mn]; int main() &#123; int n,p; scanf(&quot;%d%d&quot;,&amp;n,&amp;p); f[1][1]=f[1][0]=sum0[1][1]=sum1[1][1]=1; for(int i=2;i&lt;=n;++i) &#123; int now=i&amp;1; //now为当前层，now^1为上一层。这里相当于 now=i%2 for(int j=1;j&lt;=i;++j) &#123; f[j][1]=sum0[now^1][j-1]; f[j][0]=(sum1[now^1][i-1]-sum1[now^1][j-1])%p; while(f[j][0]&lt;0) f[j][0]+=p; //避免取模后相减变为负数 sum0[now][j]=(sum0[now][j-1]+f[j][0])%p; sum1[now][j]=(sum1[now][j-1]+f[j][1])%p; &#125; &#125; long long ans=0; for(int i=1;i&lt;=n;++i) ans=((ans+f[i][0])%p+f[i][1])%p; cout&lt;&lt;ans; &#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://a154051.gitee.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"DP","slug":"DP","permalink":"https://a154051.gitee.io/tags/DP/"}],"author":"a154051"},{"title":"【题解】P6394樱花，还有你","slug":"solution-P6394-ying-hua","date":"2021-02-27T03:14:00.000Z","updated":"2023-10-13T10:42:06.493Z","comments":true,"path":"2021/02/27/solution-P6394-ying-hua/","link":"","permalink":"https://a154051.gitee.io/2021/02/27/solution-P6394-ying-hua/","excerpt":"","text":"P6394 樱花，还有你 题面好浪漫，可惜我是11月11日写的这题。 题意有 $k$ 棵树，每棵树上有 $s_i$ 朵花，有几种方案能恰好取 $n$ 朵花，若收集不到 $n$ 朵花，输出impossible。 注意：用 $(a_1,a_2,⋯)$ 表示一种方案，则 $(1,1,1)$ 和 $(1,1,1,0)$ 是两种不同的方案。 分析Subtask 1$\\sum s_i&lt;n$ 白给，直接输出impossible即可。 Subtask 2&amp;3$n,k \\le 5\\times10^2$ 定义 $f(i,j)$ 表示前 $i$ 棵树收集 $j$ 朵花的方案数。 显然有状态转移方程： f(i,j)=\\sum\\limits_{x=0}^{\\min(j,s_i)}f(i-1,j-x)最终答案为 $\\sum_{i=1}^{k}f(i,n)$。 时间复杂度：$O(n^2k)$，空间复杂度：$O(nk)$。 Subtask 4$n,k \\le 5\\times10^3$ $O(n^2k)$ 的复杂度会超时，需要优化。 发现可以用前缀和优化掉最里面一层循环。 定义 $sum(i,j)=\\sum_{x=0}^j f(i,x)$。 所以 f(i,j)=sum(i-1,j)-sum(i-1,j-\\min(j,s_i)-1)为了避免数组下标为负数，应改为 f(i,j)=sum(i-1,j)-sum(i-1,j-\\min(j,s_i))+f(i-1,j-\\min(j,s_i)时间复杂度：$O(nk)$。 这时候发现无耻出题人只给了 $64MB$，内存会炸。 观察上述转移方程，发现 $f$ 数组和 $sum$ 数组只用到了这一层和上一层，所以只存这两层就好。 空间复杂度：$O(n)$。 代码#include &lt;bits/stdc++.h&gt; using namespace std; const int mn=5e3+7,mod=10086001; int s[mn],f[2][mn],sum[2][mn]; int now; //now为当前这一层，now^1为上一层 int min1(int x,int y) &#123; return x&lt;y?x:y; &#125; int main() &#123; int n,k,cnt=0; cin&gt;&gt;n&gt;&gt;k; f[0][0]=sum[0][0]=f[1][0]=sum[1][0]=1; for(int i=1;i&lt;=k;++i) scanf(&quot;%d&quot;,&amp;s[i]),cnt+=s[i]; if(cnt&lt;n) &#123; cout&lt;&lt;&quot;impossible&quot;; return 0; &#125; int ans=0; for(int i=1;i&lt;=k;++i) &#123; now=i&amp;1; //相当于now=i%2 for(int j=1;j&lt;=n;++j) &#123; sum[now^1][j]=(sum[now^1][j-1]+f[now^1][j])%mod; f[now][j]=(sum[now^1][j]-sum[now^1][j-min1(j,s[i])]+f[now^1][j-min1(j,s[i])])%mod; while(f[now][j]&lt;0) f[now][j]+=mod; //取模后相减有可能出现负数 &#125; ans=(ans+f[now][n])%mod; &#125; cout&lt;&lt;ans; return 0; &#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://a154051.gitee.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"DP","slug":"DP","permalink":"https://a154051.gitee.io/tags/DP/"}],"author":"a154051"},{"title":"【学习笔记】模拟退火算法","slug":"mo-ni-tui-huo-bi-ji","date":"2021-02-08T11:40:00.000Z","updated":"2023-10-13T10:42:06.494Z","comments":true,"path":"2021/02/08/mo-ni-tui-huo-bi-ji/","link":"","permalink":"https://a154051.gitee.io/2021/02/08/mo-ni-tui-huo-bi-ji/","excerpt":"","text":"简介模拟退火(Simulated Annealing，SA)是一种随机化算法。它适用于解决方案量极大的问题，如旅行商问题，求解多峰函数极值等问题。 原理 模拟退火算法来源于固体退火原理，是一种基于概率的算法，将固体加温至充分高，再让其徐徐冷却，加温时，固体内部粒子随温升变为无序状，内能增大，而徐徐冷却时粒子渐趋有序，在每个温度都达到平衡态，最后在常温时达到基态，内能减为最小。 ——百度百科 把问题看作固体内部粒子，把最优解看作平衡态，用程序模拟退火的过程，就是模拟退火算法。 过程模拟退火中有三个参数，分别是初始温度 $T_0$、降温系数 $\\Delta$。其中，$\\Delta$ 是一个略小于 $1$ 的数。 令温度 $T=T_0$，然后每次降温时 $T=T*\\Delta$，直到 $T=0$。 在每次降温过程中，都要用当前解产生一个新解，即 $x_1=x_0+\\Delta x$。其中，$\\Delta x \\in R$ 并且 $\\left\\vert \\Delta x\\right\\vert \\propto T$，表示解的变动值，温度越低，它的变化幅度越小，产生的新解也会越来越趋近于最优解，如图， 这时候我们需要考虑是否用新解替换当前解，定义当前温度为 $T$，某个解 $x$ 的贡献为 $f(x)$（这里的贡献不是指大小，而是这个解的优劣），则修改当前解的概率为 P=\\begin{cases}1&f(x_1)\\geqslant f(x_0)\\\\e^\\frac{-\\left\\vert f(x_1)-f(x_0)\\right\\vert}{T}&f(x_1)","categories":[{"name":"笔记","slug":"笔记","permalink":"https://a154051.gitee.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"模拟退火","slug":"模拟退火","permalink":"https://a154051.gitee.io/tags/%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB/"}],"author":"a154051"}],"categories":[{"name":"题解","slug":"题解","permalink":"https://a154051.gitee.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"笔记","slug":"笔记","permalink":"https://a154051.gitee.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"做题记录","slug":"做题记录","permalink":"https://a154051.gitee.io/tags/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"Kruskal重构树","slug":"Kruskal重构树","permalink":"https://a154051.gitee.io/tags/Kruskal%E9%87%8D%E6%9E%84%E6%A0%91/"},{"name":"贪心","slug":"贪心","permalink":"https://a154051.gitee.io/tags/%E8%B4%AA%E5%BF%83/"},{"name":"模拟退火","slug":"模拟退火","permalink":"https://a154051.gitee.io/tags/%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB/"},{"name":"树","slug":"树","permalink":"https://a154051.gitee.io/tags/%E6%A0%91/"},{"name":"字符串","slug":"字符串","permalink":"https://a154051.gitee.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"后缀自动机-SAM","slug":"后缀自动机-SAM","permalink":"https://a154051.gitee.io/tags/%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA-SAM/"},{"name":"网络流","slug":"网络流","permalink":"https://a154051.gitee.io/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"},{"name":"DP","slug":"DP","permalink":"https://a154051.gitee.io/tags/DP/"}]}