{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/Sakura/source/404.html","path":"404.html","modified":0,"renderable":1},{"_id":"themes/Sakura/source/warn.html","path":"warn.html","modified":0,"renderable":1},{"_id":"themes/Sakura/source/css/APlayer.min.css","path":"css/APlayer.min.css","modified":0,"renderable":1},{"_id":"themes/Sakura/source/css/bangumi.css","path":"css/bangumi.css","modified":0,"renderable":1},{"_id":"themes/Sakura/source/css/code.css","path":"css/code.css","modified":0,"renderable":1},{"_id":"themes/Sakura/source/css/dark.css","path":"css/dark.css","modified":0,"renderable":1},{"_id":"themes/Sakura/source/css/donate.css","path":"css/donate.css","modified":0,"renderable":1},{"_id":"themes/Sakura/source/css/font.css","path":"css/font.css","modified":0,"renderable":1},{"_id":"themes/Sakura/source/css/insight.styl","path":"css/insight.styl","modified":0,"renderable":1},{"_id":"themes/Sakura/source/css/jquery.fancybox.min.css","path":"css/jquery.fancybox.min.css","modified":0,"renderable":1},{"_id":"themes/Sakura/source/css/lib.min.css","path":"css/lib.min.css","modified":0,"renderable":1},{"_id":"themes/Sakura/source/css/sharejs.css","path":"css/sharejs.css","modified":0,"renderable":1},{"_id":"themes/Sakura/source/css/spoiler.css","path":"css/spoiler.css","modified":0,"renderable":1},{"_id":"themes/Sakura/source/css/style.css","path":"css/style.css","modified":0,"renderable":1},{"_id":"themes/Sakura/source/css/zoom.css","path":"css/zoom.css","modified":0,"renderable":1},{"_id":"themes/Sakura/source/fonts/fontawesome-webfont.woff2","path":"fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/Sakura/source/fonts/iconfont.eot","path":"fonts/iconfont.eot","modified":0,"renderable":1},{"_id":"themes/Sakura/source/fonts/iconfont.svg","path":"fonts/iconfont.svg","modified":0,"renderable":1},{"_id":"themes/Sakura/source/fonts/iconfont.woff","path":"fonts/iconfont.woff","modified":0,"renderable":1},{"_id":"themes/Sakura/source/fonts/iconfont.ttf","path":"fonts/iconfont.ttf","modified":0,"renderable":1},{"_id":"themes/Sakura/source/images/chess-king.svg","path":"images/chess-king.svg","modified":0,"renderable":1},{"_id":"themes/Sakura/source/images/chess-queen.svg","path":"images/chess-queen.svg","modified":0,"renderable":1},{"_id":"themes/Sakura/source/images/favicon.ico","path":"images/favicon.ico","modified":0,"renderable":1},{"_id":"themes/Sakura/source/js/APlayer.min.js","path":"js/APlayer.min.js","modified":0,"renderable":1},{"_id":"themes/Sakura/source/js/InsightSearch.js","path":"js/InsightSearch.js","modified":0,"renderable":1},{"_id":"themes/Sakura/source/js/jquery.fancybox.min.js","path":"js/jquery.fancybox.min.js","modified":0,"renderable":1},{"_id":"themes/Sakura/source/js/botui.js","path":"js/botui.js","modified":0,"renderable":1},{"_id":"themes/Sakura/source/js/sakura-app.js","path":"js/sakura-app.js","modified":0,"renderable":1},{"_id":"themes/Sakura/source/js/lib.min.js","path":"js/lib.min.js","modified":0,"renderable":1},{"_id":"themes/Sakura/source/js/spoiler.js","path":"js/spoiler.js","modified":0,"renderable":1},{"_id":"themes/Sakura/source/js/zoom.min.js","path":"js/zoom.min.js","modified":0,"renderable":1},{"_id":"themes/Sakura/source/fonts/SAKURASO.old/icon.css","path":"fonts/SAKURASO.old/icon.css","modified":0,"renderable":1},{"_id":"themes/Sakura/source/fonts/SAKURASO.old/sakuraso-symbol.svg","path":"fonts/SAKURASO.old/sakuraso-symbol.svg","modified":0,"renderable":1},{"_id":"themes/Sakura/source/fonts/SAKURASO.old/sakuraso.eot","path":"fonts/SAKURASO.old/sakuraso.eot","modified":0,"renderable":1},{"_id":"themes/Sakura/source/fonts/SAKURASO.old/sakuraso.ttf","path":"fonts/SAKURASO.old/sakuraso.ttf","modified":0,"renderable":1},{"_id":"themes/Sakura/source/fonts/SAKURASO.old/sakuraso.svg","path":"fonts/SAKURASO.old/sakuraso.svg","modified":0,"renderable":1},{"_id":"themes/Sakura/source/fonts/SAKURASO.old/sakuraso.woff","path":"fonts/SAKURASO.old/sakuraso.woff","modified":0,"renderable":1},{"_id":"themes/Sakura/source/images/donate/AliPayQR.jpg","path":"images/donate/AliPayQR.jpg","modified":0,"renderable":1},{"_id":"themes/Sakura/source/images/donate/BTCQR.png","path":"images/donate/BTCQR.png","modified":0,"renderable":1},{"_id":"themes/Sakura/source/images/donate/WeChanQR.jpg","path":"images/donate/WeChanQR.jpg","modified":0,"renderable":1},{"_id":"themes/Sakura/source/images/donate/WeChanSQ.jpg","path":"images/donate/WeChanSQ.jpg","modified":0,"renderable":1},{"_id":"themes/Sakura/source/images/donate/bitcoin.svg","path":"images/donate/bitcoin.svg","modified":0,"renderable":1},{"_id":"themes/Sakura/source/images/donate/github.svg","path":"images/donate/github.svg","modified":0,"renderable":1},{"_id":"themes/Sakura/source/images/donate/alipay.svg","path":"images/donate/alipay.svg","modified":0,"renderable":1},{"_id":"themes/Sakura/source/images/donate/paypal.svg","path":"images/donate/paypal.svg","modified":0,"renderable":1},{"_id":"themes/Sakura/source/images/donate/like.svg","path":"images/donate/like.svg","modified":0,"renderable":1},{"_id":"themes/Sakura/source/images/donate/wechat.svg","path":"images/donate/wechat.svg","modified":0,"renderable":1}],"Cache":[{"_id":"source/_posts/mo-ni-tui-huo-bi-ji.md","hash":"6df401459b50c7912d7a898a324a30eee7ee9ee6","modified":1697193726494},{"_id":"source/_posts/shi-yue-zuo-ti-ji-lu.md","hash":"7172bc92fbb7e79df260b89937343ab114c04661","modified":1698141670273},{"_id":"source/_posts/solution-P2472-xi-yi.md","hash":"593ef24176bf7a4e1ebc5bbd74e0f6dd9529ff50","modified":1697193726491},{"_id":"source/_posts/solution-P2467-bu-luo.md","hash":"a6fb2a5349655ddeffb18a5287d654f199f3a6af","modified":1697193726491},{"_id":"source/_posts/solution-P3291-yao-guai.md","hash":"2f62d684d0baa19340c1b0db19b8276b14433ca0","modified":1697193726494},{"_id":"source/_posts/solution-P3761-city.md","hash":"eae383ef6c38681252aa585544b813e23d6d6874","modified":1697193726491},{"_id":"source/_posts/solution-P4248-cha-yi.md","hash":"32bb569ccbe4aaaee4ffd11cfb711947433ec464","modified":1697193726493},{"_id":"source/_posts/solution-P4331-sequence.md","hash":"4fa0c226ae8ce9e51a98084d2c6ed3d263da7bda","modified":1697193726491},{"_id":"source/_posts/solution-P6310-cang-ku-jian-she.md","hash":"5aed6ec9c97713c8db6d799a1b389ed15675b190","modified":1697201910089},{"_id":"source/_posts/solution-P6394-ying-hua.md","hash":"2075ce17ce532aef5c9a45e1b29e03820df2fcc6","modified":1697193726493},{"_id":"source/about/index.md","hash":"1839bceb1edc2bdef38d3c0a3d61c9bc72f0a472","modified":1632922823000},{"_id":"source/bangumi/index.md","hash":"3bfe3cee0195356b33a132b760dc7ad7618fd00c","modified":1632922823000},{"_id":"source/comment/index.md","hash":"1cc5947caca06c73d289c4810dfcab63b524c010","modified":1697193726497},{"_id":"source/client/index.md","hash":"2077b2185c26e90d129d7df9b2c02d2f290e15b3","modified":1697193726497},{"_id":"source/donate/index.md","hash":"d3299dc74ac555eca9909be3503bc0cef52162c3","modified":1632922823000},{"_id":"source/games/index.md","hash":"7331a77aea4c15d83b53ccddc49532b0f719ed02","modified":1697193726490},{"_id":"source/lab/index.md","hash":"b5eaba8147a33517ab94023b3e5402b9a15b0ab3","modified":1697193726496},{"_id":"source/links/index.md","hash":"be65c1c92c63b424a7223c9e97b4246b67feef97","modified":1697193726495},{"_id":"source/music/index.md","hash":"735f8407ab33f503327dcd8a4e84083e7acc9254","modified":1697193726495},{"_id":"source/rss/index.md","hash":"9743b6bf5f76c0edc68cd6d6bc5d368f8499905d","modified":1632922823000},{"_id":"source/tags/index.md","hash":"cdb906f2aa0d335867850aa05f5df1d9c69dbbcd","modified":1697198715700},{"_id":"source/theme-sakura/index.md","hash":"07bfe058b5d80d92f6a6840bdd922b934199c7c9","modified":1697193726489},{"_id":"source/video/index.md","hash":"e387a6a406eec70998293846d371072a1c5a60cb","modified":1632922823000},{"_id":"themes/Sakura/README.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632922823000},{"_id":"themes/Sakura/README.zhCN.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632922823000},{"_id":"themes/Sakura/.gitignore","hash":"8a27dbc2899378d9b63a768d2b15be8e1b65887d","modified":1632922823000},{"_id":"themes/Sakura/.travis.yml","hash":"59da7c4691ba01d4c05bd64e058551171fe649b6","modified":1632922823000},{"_id":"themes/Sakura/CNAME","hash":"6b332d1ef5947dadc6e394dd1445eb3596eddfe6","modified":1632922823000},{"_id":"themes/Sakura/LICENSE","hash":"e84291eaaeb4a02004d4aa6a504cbf9475f5c562","modified":1632922823000},{"_id":"themes/Sakura/_config.yml","hash":"387d4a3d3c5eee4498d9a331463547f9b577d7ae","modified":1697201386095},{"_id":"themes/Sakura/package.json","hash":"ec5fa23203039ece9acda53dfac3710b371bd401","modified":1632922823000},{"_id":"themes/Sakura/languages/en.yml","hash":"38044728f53054310a9061bdd385d6b524f46e78","modified":1632922823000},{"_id":"themes/Sakura/languages/zh-cn.yml","hash":"c342d8a47b921dcfec052f8ee04e5828f485b210","modified":1697193726501},{"_id":"themes/Sakura/layout/archive.ejs","hash":"5793d8e23173f5a3308bf6718788b34def54eb1a","modified":1632922823000},{"_id":"themes/Sakura/layout/bangumi.ejs","hash":"075b0fd65cbe113c15610d6632018b7bd6f5d2a3","modified":1632922823000},{"_id":"themes/Sakura/layout/category.ejs","hash":"54e5398ee512c58ba6d72c6e84d5e977e4967908","modified":1687100362387},{"_id":"themes/Sakura/layout/donate.ejs","hash":"44791063577f2d6b4746d753f080644476b653d8","modified":1697200685184},{"_id":"themes/Sakura/layout/index.ejs","hash":"cac4388fd26ab339a0097cf4c7d8a436a7ed55f3","modified":1632922823000},{"_id":"themes/Sakura/layout/layout.ejs","hash":"df8925936551ffc765afbcc74543598d8f23837e","modified":1687006307039},{"_id":"themes/Sakura/layout/links.ejs","hash":"a8a5a891162eaef82e972a8af9df6a0b4afe3205","modified":1697199121175},{"_id":"themes/Sakura/layout/page.ejs","hash":"4a2ddc7c5868279d368a527a340a7d7fddeb975c","modified":1632922823000},{"_id":"themes/Sakura/layout/post.ejs","hash":"32457bc480205dd9be7c3bebbd9b04beb2a60992","modified":1632922823000},{"_id":"themes/Sakura/layout/tag.ejs","hash":"3347288eeb49d5c57bd98dd82df89251909f82ba","modified":1687100364614},{"_id":"themes/Sakura/layout/tags.ejs","hash":"4dcea5e324b6a1802ba2cef7d734d0a67e65846b","modified":1697199122130},{"_id":"themes/Sakura/source/404.html","hash":"9fc63f250573812d0d964247b2358fec041f328a","modified":1632922823000},{"_id":"themes/Sakura/source/warn.html","hash":"1a2e9b6013fdf6b22f3790feffcc72533be385dd","modified":1632922823000},{"_id":"themes/Sakura/layout/_partial/_page.ejs","hash":"c438ab0fb6d3310e3c568e3944a770af746e6d59","modified":1632922823000},{"_id":"themes/Sakura/layout/_partial/_post.ejs","hash":"ba480fd3b4c6997acf10c14f489c55f5ccc6da22","modified":1632922823000},{"_id":"themes/Sakura/layout/_partial/aplayer.ejs","hash":"0e5f026debe67f3b991a0d9b103f296ccda505ba","modified":1632922823000},{"_id":"themes/Sakura/layout/_partial/archive.ejs","hash":"00b3d3ebfc1cf840c77b0f7452a651e0496839c7","modified":1632922823000},{"_id":"themes/Sakura/layout/_partial/category-archive.ejs","hash":"a05b1a49269866d6203cf25654c2db0e5daabcd6","modified":1632922823000},{"_id":"themes/Sakura/layout/_partial/comment.ejs","hash":"1384c4bd648d6cf10c1fb929116bf394aa5090e6","modified":1694953329236},{"_id":"themes/Sakura/layout/_partial/footer.ejs","hash":"bc064b5c0d673bb289675a3a36c35e9979a33759","modified":1699344690183},{"_id":"themes/Sakura/layout/_partial/header.ejs","hash":"66943be8bf726c5215120a744f451579a540d439","modified":1632922823000},{"_id":"themes/Sakura/layout/_partial/head.ejs","hash":"f02bd7182e92ca76d00ac8ac4cfe451cf446cdfb","modified":1687081392740},{"_id":"themes/Sakura/layout/_partial/headertop.ejs","hash":"ae51b43f060be2e594e16b8cb33941a9bf866ed5","modified":1632922823000},{"_id":"themes/Sakura/layout/_partial/mheader.ejs","hash":"de10fa51ddd773d469e36bbb6ea21b583708e5b4","modified":1632922823000},{"_id":"themes/Sakura/layout/_partial/setdisplay.ejs","hash":"a1621fb7741b862f3e09c148b3876fa693b95abf","modified":1632922823000},{"_id":"themes/Sakura/layout/_partial/skin-btn.ejs","hash":"9f502a28a93c704d6a2c3b99fc772a6e43d8a7d7","modified":1632922823000},{"_id":"themes/Sakura/layout/_partial/skin-list.ejs","hash":"8dc6363a87b37599e3ddcc8fcd35b2bc4fb79d86","modified":1632922823000},{"_id":"themes/Sakura/layout/_partial/startdash.ejs","hash":"4cadc3d40886cb40d63c99d37c4d361f79298b82","modified":1687005522671},{"_id":"themes/Sakura/layout/_widget/category-items.ejs","hash":"19d77cb41eab6a94752c2166c2b7a96dd23e975e","modified":1632922823000},{"_id":"themes/Sakura/layout/_widget/common-article.ejs","hash":"bd23c20c87bbd10dc8fea5154a0762dd30a386b6","modified":1699345638646},{"_id":"themes/Sakura/layout/_widget/common-page.ejs","hash":"94ef1101b58b1530affc6b407617a6a79f259e57","modified":1687081066725},{"_id":"themes/Sakura/layout/_widget/index-items.ejs","hash":"dd792e14393b40735e1e6efcfc0cda032bfbede7","modified":1687100618992},{"_id":"themes/Sakura/layout/_widget/tag-cloud.ejs","hash":"a653b92bd399bd857894dde9b8e577400b9d7b0a","modified":1632922823000},{"_id":"themes/Sakura/layout/_partial/set.ejs","hash":"c412b0905fa031df3c1ca8a072021f0e3f730c39","modified":1632922823000},{"_id":"themes/Sakura/source/css/APlayer.min.css","hash":"07372a2ba507388d0fed166d761b1c2c2a659dce","modified":1632922823000},{"_id":"themes/Sakura/source/css/bangumi.css","hash":"4d30d793a8813b14c55cee12d4a5adbb1cc7c535","modified":1632922823000},{"_id":"themes/Sakura/source/css/code.css","hash":"97cfb4f8802a0100a7e3ad3fc7faa9426d7934cf","modified":1632922823000},{"_id":"themes/Sakura/source/css/dark.css","hash":"9988ccbb5e2399d1bd7f3a900a1ef7256a1a8560","modified":1632922823000},{"_id":"themes/Sakura/source/css/donate.css","hash":"fb5b21bae281772ea4e1df250d1d118edd8fe3ec","modified":1632922823000},{"_id":"themes/Sakura/source/css/font.css","hash":"714d3b9fbd98fdc398ce9aa60ec1d60d50628933","modified":1632922823000},{"_id":"themes/Sakura/source/css/insight.styl","hash":"5c330fa26c0c2c7326f3093f17625c7de0181795","modified":1632922823000},{"_id":"themes/Sakura/source/css/jquery.fancybox.min.css","hash":"1be9b79be02a1cfc5d96c4a5e0feb8f472babd95","modified":1632922823000},{"_id":"themes/Sakura/source/css/sharejs.css","hash":"62b3ea2384cdf4f9dbce34e17f660856d51a605c","modified":1632922823000},{"_id":"themes/Sakura/source/css/spoiler.css","hash":"592f09b0bf65d376615b1d1649d1b51d66a8f1b9","modified":1632922823000},{"_id":"themes/Sakura/source/css/zoom.css","hash":"e6feedd50deaf58cd27b33ed99f04f479c9fba31","modified":1632922823000},{"_id":"themes/Sakura/source/fonts/iconfont.eot","hash":"a6d4a6cbd2e7e0ece89973f4c848c7209b062120","modified":1632922823000},{"_id":"themes/Sakura/source/fonts/iconfont.svg","hash":"f469a7fe346fc3665d70dde9e4eb81331f504b5f","modified":1632922823000},{"_id":"themes/Sakura/source/fonts/iconfont.woff","hash":"7222cdc09d819e340fd8cea8498d36270b0400b1","modified":1632922823000},{"_id":"themes/Sakura/source/fonts/iconfont.ttf","hash":"5454ae941eeeda1fee8a1b9ef608dae39f58288e","modified":1632922823000},{"_id":"themes/Sakura/source/images/chess-king.svg","hash":"d860fc19b40d778f5d7cf4b6a867b5585beaf7bd","modified":1687098141650},{"_id":"themes/Sakura/source/images/chess-queen.svg","hash":"1044647a0b057c7bfedaa3f2d2524973198d29d0","modified":1687086780681},{"_id":"themes/Sakura/source/images/favicon.ico","hash":"124582ab19fd5de72b6f96f1faaeef3fe5e6926e","modified":1632922823000},{"_id":"themes/Sakura/source/js/APlayer.min.js","hash":"22caa28ff6b41a16ff40f15d38f1739e22359478","modified":1632922823000},{"_id":"themes/Sakura/source/js/InsightSearch.js","hash":"3acae0bd3b55b16b93006466942de81b2a27b011","modified":1632922823000},{"_id":"themes/Sakura/source/js/sakura-app.js","hash":"1c84ed899a1791c33bbdc94e07534766908c2cba","modified":1698141603526},{"_id":"themes/Sakura/source/js/spoiler.js","hash":"bbcbcbb9e77933929819ad65345955df6d22246a","modified":1632922823000},{"_id":"themes/Sakura/source/js/zoom.min.js","hash":"0b377c432d448cfc09c9e451128a48810a250926","modified":1632922823000},{"_id":"themes/Sakura/layout/_widget/search/insight.ejs","hash":"072cc5dbd9d3c818a353cfd55ad7ec0e535155b6","modified":1687099667730},{"_id":"themes/Sakura/source/fonts/SAKURASO.old/icon.css","hash":"cca92568d623792d63db3706a705d3c77412d025","modified":1632922823000},{"_id":"themes/Sakura/source/fonts/SAKURASO.old/sakuraso-symbol.svg","hash":"dd2a3d764889d23575a33251ff64761fb4bbb317","modified":1632922823000},{"_id":"themes/Sakura/source/fonts/SAKURASO.old/sakuraso.eot","hash":"509315fee1cbfcbfd9beec880032f75532df38af","modified":1632922823000},{"_id":"themes/Sakura/source/fonts/SAKURASO.old/sakuraso.ttf","hash":"91025ed91b9a317ddc835cc88d660c193a6c0228","modified":1632922823000},{"_id":"themes/Sakura/source/fonts/SAKURASO.old/sakuraso.svg","hash":"6eb5c281f77452342361ed3352f62e2dec0f3b5c","modified":1632922823000},{"_id":"themes/Sakura/source/fonts/SAKURASO.old/sakuraso.woff","hash":"00856819a670a578f78ffa2cae66717e21b24b36","modified":1632922823000},{"_id":"themes/Sakura/source/images/donate/BTCQR.png","hash":"1abc7fa494a5bb9765dee1004f544ad962d46c91","modified":1632922823000},{"_id":"themes/Sakura/source/images/donate/bitcoin.svg","hash":"635f7cca5e675d192be2717788175c7a2146013a","modified":1632922823000},{"_id":"themes/Sakura/source/images/donate/github.svg","hash":"90ba9a3b0dc19e70e742a39b014194f801e00f97","modified":1632922823000},{"_id":"themes/Sakura/source/images/donate/alipay.svg","hash":"46cc0552a9f6d700d618db3fcad25e1b8e697e36","modified":1632922823000},{"_id":"themes/Sakura/source/images/donate/paypal.svg","hash":"92f3bc495f20a0190d3041be03345c46d6238c25","modified":1632922823000},{"_id":"themes/Sakura/source/images/donate/like.svg","hash":"22a2754dc454d7b0321b70914fb2936b8d2ea8ab","modified":1632922823000},{"_id":"themes/Sakura/source/images/donate/wechat.svg","hash":"330496ad42446a29f37a2b97fc388ebd77a8cb9f","modified":1632922823000},{"_id":"themes/Sakura/source/css/lib.min.css","hash":"3c4c8e1006dcc8e57e4a02e9d735a52c2a95cc72","modified":1632922823000},{"_id":"themes/Sakura/source/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1632922823000},{"_id":"themes/Sakura/source/js/jquery.fancybox.min.js","hash":"9e2b205a88c949fc8e6a7550d502dabe2b1ab4c0","modified":1632922823000},{"_id":"themes/Sakura/source/js/botui.js","hash":"7fd0a8b3a214c7840d4b1297195f3e9282b5cbb9","modified":1632922823000},{"_id":"themes/Sakura/source/images/donate/WeChanSQ.jpg","hash":"27a05e1012dde94e06d711d3c868ef8e1bf50af0","modified":1632922823000},{"_id":"themes/Sakura/source/css/style.css","hash":"9897404e371ea86b1eaf9eae4dc5cd34ababcb19","modified":1687099996401},{"_id":"themes/Sakura/source/images/donate/AliPayQR.jpg","hash":"315df35efab2584bc427914865bdc31ec90eaa99","modified":1632922823000},{"_id":"themes/Sakura/source/images/donate/WeChanQR.jpg","hash":"a3d79bd57a41945603816d071b6c965146d693dc","modified":1632922823000},{"_id":"themes/Sakura/source/js/lib.min.js","hash":"28f7ece281fef37370c561b7bca5285776ae8fd9","modified":1632922823000},{"_id":"public/atom.xml","hash":"bde1039c0888a5b9184da86b70c8cf9824e5c7d1","modified":1699345650147},{"_id":"public/content.json","hash":"2c6a068a613bdcb2602b35bd3c95c56cc7ac190b","modified":1699345650147},{"_id":"public/sitemap.xml","hash":"29a8fe693d3ff54cd6d5fd850645c2db24a65759","modified":1699345650147},{"_id":"public/about/index.html","hash":"24585d398d5b40d8a97c45cef4256b753753b329","modified":1699345650147},{"_id":"public/bangumi/index.html","hash":"2ffce435443729e235522f48e65f204254a90ee2","modified":1699345650147},{"_id":"public/comment/index.html","hash":"8066cdfe227c4ffda930641d65a12949a55f5115","modified":1699345650147},{"_id":"public/client/index.html","hash":"1408af7c2e5fc1e45d5993f7d029d455c5f668ea","modified":1699345650147},{"_id":"public/donate/index.html","hash":"0edd46ba3227e73111365de6b6f0d772fbf95aba","modified":1699345650147},{"_id":"public/games/index.html","hash":"ed86be727d8036e5b99ce9efd610bf5611926b9d","modified":1699345650147},{"_id":"public/lab/index.html","hash":"ee225ecf1fe63137bdb194486d460e7e729f1632","modified":1699345650147},{"_id":"public/links/index.html","hash":"5084f3d6aaa9e13313af878280f793ee7ac3d9eb","modified":1699345650147},{"_id":"public/music/index.html","hash":"1876ee6dadda2beb6d024fbbe3a47d6bde721ffc","modified":1699345650147},{"_id":"public/rss/index.html","hash":"b96f43f23b883c883b9b5973d0fb78fb2a6596e6","modified":1699345650147},{"_id":"public/tags/index.html","hash":"d529d570a0ff2f7b64d34b6eb48afadea25d1373","modified":1699345650147},{"_id":"public/theme-sakura/index.html","hash":"af446fde34a0b19541be4710c39d9129a23dde85","modified":1699345650147},{"_id":"public/video/index.html","hash":"ffbba6f221a29016a1412188592788b3b25dc9fa","modified":1699345650147},{"_id":"public/2023/10/24/shi-yue-zuo-ti-ji-lu/index.html","hash":"e4409e430f9fa10ad9efa43e2b51ba29b2b90abc","modified":1699345650147},{"_id":"public/2023/09/25/solution-P6310-cang-ku-jian-she/index.html","hash":"e6e247ec39f8dec25ac47f5dfe0f63cadb5cadda","modified":1699345650147},{"_id":"public/2021/09/25/solution-P4331-sequence/index.html","hash":"6f4e6690662484b895346468a8330eafa214b98d","modified":1699345650147},{"_id":"public/2021/09/01/solution-P3291-yao-guai/index.html","hash":"e111ec822da8f663a2fdd513f6b88f6f7bf29033","modified":1699345650147},{"_id":"public/2021/08/08/solution-P3761-city/index.html","hash":"5877ed69405a261f235cd4f4b465304bf0124b9b","modified":1699345650147},{"_id":"public/2021/07/17/solution-P4248-cha-yi/index.html","hash":"6c27358f7b458fc4fed3fc4c030e348d8e0b0f0f","modified":1699345650147},{"_id":"public/2021/03/05/solution-P2472-xi-yi/index.html","hash":"7961e697b6fab0bf90f4d2c39eafb34b1405c021","modified":1699345650147},{"_id":"public/2021/03/03/solution-P2467-bu-luo/index.html","hash":"c7d3410f180cb5e26e74fdad89f62b2c79ab6caf","modified":1699345650147},{"_id":"public/2021/02/27/solution-P6394-ying-hua/index.html","hash":"309c2dd1c681cdcfd7dc5651defa1782cd244be4","modified":1699345650147},{"_id":"public/2021/02/08/mo-ni-tui-huo-bi-ji/index.html","hash":"1ab0cbaae769516e14317798612042ac50fc0fe0","modified":1699345650147},{"_id":"public/archives/index.html","hash":"6094fb5308c6beb89c507416d6f504aaf7ed6f4b","modified":1699345650147},{"_id":"public/archives/2021/index.html","hash":"9abe61f7127db3fe7f4bdf33ecf567cfed925be2","modified":1699345650147},{"_id":"public/archives/2021/02/index.html","hash":"39c48e653179a834968080c174db466e448bcf58","modified":1699345650147},{"_id":"public/archives/2021/03/index.html","hash":"e620b64626e23a5116f582ef0098d39837a70aae","modified":1699345650147},{"_id":"public/archives/2021/07/index.html","hash":"3b45fe3e8158c21f5307ad7810d426f8aa63d53f","modified":1699345650147},{"_id":"public/archives/2021/08/index.html","hash":"84f9239c27f85d7ba71c61c99b6b08ecb89ddf50","modified":1699345650147},{"_id":"public/archives/2021/09/index.html","hash":"6475e99ebdca0acc685b2923c09e67d482949d3f","modified":1699345650147},{"_id":"public/archives/2023/index.html","hash":"7c243f91441139c9ba61e5e683d770fa78160992","modified":1699345650147},{"_id":"public/archives/2023/09/index.html","hash":"7d30809fd1e147d5b534b2f8830fb2b0a6393577","modified":1699345650147},{"_id":"public/archives/2023/10/index.html","hash":"d96ed2a2b2b959e51e3dae62662be11f89515fff","modified":1699345650147},{"_id":"public/categories/题解/index.html","hash":"39c3621982e1ebe79e8b26182e6ca7b6d8741012","modified":1699345650147},{"_id":"public/categories/笔记/index.html","hash":"e035b3d94bb422a00bf33ba86b7db14e9f07bc48","modified":1699345650147},{"_id":"public/index.html","hash":"0a4f2deb7d0fdac96209ccadf3cf4b4c061e8c69","modified":1699345650147},{"_id":"public/tags/做题记录/index.html","hash":"18ab67882966d0aaac6e4f3c114a1f1b3428c6f3","modified":1699345650147},{"_id":"public/tags/模拟退火/index.html","hash":"5bacbd245ed46934f65681ef7682e36460b7d0f8","modified":1699345650147},{"_id":"public/tags/网络流/index.html","hash":"955f448e08aceab7d25ab247298305163cf348b6","modified":1699345650147},{"_id":"public/tags/DP/index.html","hash":"b2a55241deef1b0adac15f643d80d6cbfc7c0404","modified":1699345650147},{"_id":"public/tags/树/index.html","hash":"8ba6e033c29c777efe511fa43ec794cf60c2dd02","modified":1699345650147},{"_id":"public/tags/字符串/index.html","hash":"b943ae83831678af05ec872413575efe23b850d6","modified":1699345650147},{"_id":"public/tags/后缀自动机-SAM/index.html","hash":"a64a8ab4796f13e1332725e2eb351f85584bb5fa","modified":1699345650147},{"_id":"public/tags/贪心/index.html","hash":"a9a49442de2253d58dee9043e24a5d10e158c4e1","modified":1699345650147},{"_id":"public/tags/Kruskal重构树/index.html","hash":"0348ea77e7dd6264898f64cf10f8a4936f5a65fc","modified":1699345650147},{"_id":"public/fonts/iconfont.eot","hash":"a6d4a6cbd2e7e0ece89973f4c848c7209b062120","modified":1699345650147},{"_id":"public/css/spoiler.css","hash":"592f09b0bf65d376615b1d1649d1b51d66a8f1b9","modified":1699345650147},{"_id":"public/fonts/iconfont.svg","hash":"f469a7fe346fc3665d70dde9e4eb81331f504b5f","modified":1699345650147},{"_id":"public/fonts/iconfont.woff","hash":"7222cdc09d819e340fd8cea8498d36270b0400b1","modified":1699345650147},{"_id":"public/fonts/iconfont.ttf","hash":"5454ae941eeeda1fee8a1b9ef608dae39f58288e","modified":1699345650147},{"_id":"public/images/chess-king.svg","hash":"d860fc19b40d778f5d7cf4b6a867b5585beaf7bd","modified":1699345650147},{"_id":"public/images/chess-queen.svg","hash":"1044647a0b057c7bfedaa3f2d2524973198d29d0","modified":1699345650147},{"_id":"public/images/favicon.ico","hash":"124582ab19fd5de72b6f96f1faaeef3fe5e6926e","modified":1699345650147},{"_id":"public/js/spoiler.js","hash":"bbcbcbb9e77933929819ad65345955df6d22246a","modified":1699345650147},{"_id":"public/fonts/SAKURASO.old/sakuraso-symbol.svg","hash":"dd2a3d764889d23575a33251ff64761fb4bbb317","modified":1699345650147},{"_id":"public/fonts/SAKURASO.old/sakuraso.eot","hash":"509315fee1cbfcbfd9beec880032f75532df38af","modified":1699345650147},{"_id":"public/fonts/SAKURASO.old/sakuraso.ttf","hash":"91025ed91b9a317ddc835cc88d660c193a6c0228","modified":1699345650147},{"_id":"public/fonts/SAKURASO.old/sakuraso.svg","hash":"6eb5c281f77452342361ed3352f62e2dec0f3b5c","modified":1699345650147},{"_id":"public/fonts/SAKURASO.old/sakuraso.woff","hash":"00856819a670a578f78ffa2cae66717e21b24b36","modified":1699345650147},{"_id":"public/images/donate/BTCQR.png","hash":"1abc7fa494a5bb9765dee1004f544ad962d46c91","modified":1699345650147},{"_id":"public/images/donate/bitcoin.svg","hash":"635f7cca5e675d192be2717788175c7a2146013a","modified":1699345650147},{"_id":"public/images/donate/github.svg","hash":"90ba9a3b0dc19e70e742a39b014194f801e00f97","modified":1699345650147},{"_id":"public/images/donate/alipay.svg","hash":"46cc0552a9f6d700d618db3fcad25e1b8e697e36","modified":1699345650147},{"_id":"public/images/donate/paypal.svg","hash":"92f3bc495f20a0190d3041be03345c46d6238c25","modified":1699345650147},{"_id":"public/images/donate/like.svg","hash":"22a2754dc454d7b0321b70914fb2936b8d2ea8ab","modified":1699345650147},{"_id":"public/images/donate/wechat.svg","hash":"330496ad42446a29f37a2b97fc388ebd77a8cb9f","modified":1699345650147},{"_id":"public/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1699345650147},{"_id":"public/images/donate/WeChanSQ.jpg","hash":"27a05e1012dde94e06d711d3c868ef8e1bf50af0","modified":1699345650147},{"_id":"public/404.html","hash":"9fc63f250573812d0d964247b2358fec041f328a","modified":1699345650147},{"_id":"public/warn.html","hash":"1a2e9b6013fdf6b22f3790feffcc72533be385dd","modified":1699345650147},{"_id":"public/css/APlayer.min.css","hash":"07372a2ba507388d0fed166d761b1c2c2a659dce","modified":1699345650147},{"_id":"public/css/bangumi.css","hash":"4d30d793a8813b14c55cee12d4a5adbb1cc7c535","modified":1699345650147},{"_id":"public/css/code.css","hash":"97cfb4f8802a0100a7e3ad3fc7faa9426d7934cf","modified":1699345650147},{"_id":"public/css/dark.css","hash":"9988ccbb5e2399d1bd7f3a900a1ef7256a1a8560","modified":1699345650147},{"_id":"public/css/donate.css","hash":"fb5b21bae281772ea4e1df250d1d118edd8fe3ec","modified":1699345650147},{"_id":"public/css/insight.css","hash":"e3edf9f215f8b4bf6131a781edf2634df039796c","modified":1699345650147},{"_id":"public/css/jquery.fancybox.min.css","hash":"1be9b79be02a1cfc5d96c4a5e0feb8f472babd95","modified":1699345650147},{"_id":"public/css/sharejs.css","hash":"62b3ea2384cdf4f9dbce34e17f660856d51a605c","modified":1699345650147},{"_id":"public/css/zoom.css","hash":"e6feedd50deaf58cd27b33ed99f04f479c9fba31","modified":1699345650147},{"_id":"public/js/InsightSearch.js","hash":"3acae0bd3b55b16b93006466942de81b2a27b011","modified":1699345650147},{"_id":"public/js/zoom.min.js","hash":"0b377c432d448cfc09c9e451128a48810a250926","modified":1699345650147},{"_id":"public/fonts/SAKURASO.old/icon.css","hash":"cca92568d623792d63db3706a705d3c77412d025","modified":1699345650147},{"_id":"public/css/font.css","hash":"714d3b9fbd98fdc398ce9aa60ec1d60d50628933","modified":1699345650147},{"_id":"public/css/lib.min.css","hash":"3c4c8e1006dcc8e57e4a02e9d735a52c2a95cc72","modified":1699345650147},{"_id":"public/js/APlayer.min.js","hash":"22caa28ff6b41a16ff40f15d38f1739e22359478","modified":1699345650147},{"_id":"public/css/style.css","hash":"9897404e371ea86b1eaf9eae4dc5cd34ababcb19","modified":1699345650147},{"_id":"public/js/jquery.fancybox.min.js","hash":"9e2b205a88c949fc8e6a7550d502dabe2b1ab4c0","modified":1699345650147},{"_id":"public/js/sakura-app.js","hash":"1c84ed899a1791c33bbdc94e07534766908c2cba","modified":1699345650147},{"_id":"public/js/botui.js","hash":"7fd0a8b3a214c7840d4b1297195f3e9282b5cbb9","modified":1699345650147},{"_id":"public/images/donate/AliPayQR.jpg","hash":"315df35efab2584bc427914865bdc31ec90eaa99","modified":1699345650147},{"_id":"public/images/donate/WeChanQR.jpg","hash":"a3d79bd57a41945603816d071b6c965146d693dc","modified":1699345650147},{"_id":"public/js/lib.min.js","hash":"28f7ece281fef37370c561b7bca5285776ae8fd9","modified":1699345650147}],"Category":[{"name":"题解","_id":"cloo2ivvm0004r8v3bb7k038x"},{"name":"笔记","_id":"cloo2ivvs000cr8v3eg6vhb37"}],"Data":[],"Page":[{"title":"about","date":"2018-12-12T14:14:36.000Z","keywords":"关于","description":null,"comments":0,"photos":"https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/about.jpg","_content":"{% raw %}\n<!-- 因为vue和botui更新导至bug,现将对话移至js下的botui中配置 -->\n<div class=\"entry-content\">\n  <div class=\"moe-mashiro\" style=\"text-align:center; font-size: 50px; margin-bottom: 20px;\">[さくら荘のhojun]</div>\n  <div id=\"hello-mashiro\" class=\"popcontainer\" style=\"min-height: 300px; padding: 2px 6px 4px; background-color: rgba(242, 242, 242, 0.5); border-radius: 10px;\">\n    <center>\n    <p>\n    </p>\n    <h4>\n    与&nbsp;<ruby>\n    Mashiro&nbsp;<rp>\n    （</rp>\n    <rt>\n    真（ま）白（しろ）</rt>\n    <rp>\n    ）</rp>\n    </ruby>\n    对话中...</h4>\n    <p>\n    </p>\n    </center>\n    <bot-ui></botui>\n  </div>\n</div>\n<script src=\"/js/botui.js\"></script>\n<script>\nbot_ui_ini()\n</script>\n{% endraw %}","source":"about/index.md","raw":"---\ntitle: about\ndate: 2018-12-12 22:14:36\nkeywords: 关于\ndescription: \ncomments: false\nphotos: https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/about.jpg\n---\n{% raw %}\n<!-- 因为vue和botui更新导至bug,现将对话移至js下的botui中配置 -->\n<div class=\"entry-content\">\n  <div class=\"moe-mashiro\" style=\"text-align:center; font-size: 50px; margin-bottom: 20px;\">[さくら荘のhojun]</div>\n  <div id=\"hello-mashiro\" class=\"popcontainer\" style=\"min-height: 300px; padding: 2px 6px 4px; background-color: rgba(242, 242, 242, 0.5); border-radius: 10px;\">\n    <center>\n    <p>\n    </p>\n    <h4>\n    与&nbsp;<ruby>\n    Mashiro&nbsp;<rp>\n    （</rp>\n    <rt>\n    真（ま）白（しろ）</rt>\n    <rp>\n    ）</rp>\n    </ruby>\n    对话中...</h4>\n    <p>\n    </p>\n    </center>\n    <bot-ui></botui>\n  </div>\n</div>\n<script src=\"/js/botui.js\"></script>\n<script>\nbot_ui_ini()\n</script>\n{% endraw %}","updated":"2021-09-29T13:40:23.000Z","path":"about/index.html","layout":"page","_id":"cloo2ivve0000r8v313s13xlt","content":"\n<!-- 因为vue和botui更新导至bug,现将对话移至js下的botui中配置 -->\n<div class=\"entry-content\">\n  <div class=\"moe-mashiro\" style=\"text-align:center; font-size: 50px; margin-bottom: 20px;\">[さくら荘のhojun]</div>\n  <div id=\"hello-mashiro\" class=\"popcontainer\" style=\"min-height: 300px; padding: 2px 6px 4px; background-color: rgba(242, 242, 242, 0.5); border-radius: 10px;\">\n    <center>\n    <p>\n    </p>\n    <h4>\n    与&nbsp;<ruby>\n    Mashiro&nbsp;<rp>\n    （</rp>\n    <rt>\n    真（ま）白（しろ）</rt>\n    <rp>\n    ）</rp>\n    </ruby>\n    对话中...</h4>\n    <p>\n    </p>\n    </center>\n    <bot-ui></botui>\n  </div>\n</div>\n<script src=\"/js/botui.js\"></script>\n<script>\nbot_ui_ini()\n</script>\n<link rel=\"stylesheet\" href=\"/css/spoiler.css\" type=\"text/css\"><script src=\"/js/spoiler.js\" type=\"text/javascript\" async></script>","site":{"data":{}},"excerpt":"","more":"\n<!-- 因为vue和botui更新导至bug,现将对话移至js下的botui中配置 -->\n<div class=\"entry-content\">\n  <div class=\"moe-mashiro\" style=\"text-align:center; font-size: 50px; margin-bottom: 20px;\">[さくら荘のhojun]</div>\n  <div id=\"hello-mashiro\" class=\"popcontainer\" style=\"min-height: 300px; padding: 2px 6px 4px; background-color: rgba(242, 242, 242, 0.5); border-radius: 10px;\">\n    <center>\n    <p>\n    </p>\n    <h4>\n    与&nbsp;<ruby>\n    Mashiro&nbsp;<rp>\n    （</rp>\n    <rt>\n    真（ま）白（しろ）</rt>\n    <rp>\n    ）</rp>\n    </ruby>\n    对话中...</h4>\n    <p>\n    </p>\n    </center>\n    <bot-ui></botui>\n  </div>\n</div>\n<script src=\"/js/botui.js\"></script>\n<script>\nbot_ui_ini()\n</script>\n"},{"layout":"bangumi","title":"bangumi","comments":0,"date":"2019-02-10T13:32:48.000Z","keywords":null,"description":null,"bangumis":[{"img":"https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg","title":"朝花夕誓——于离别之朝束起约定之花","status":"已追完","progress":100,"jp":"さよならの朝に約束の花をかざろう","time":"2018-02-24 SUN.","desc":"住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。"},{"img":"http://lain.bgm.tv/pic/cover/l/88/6b/285666_q9f05.jpg","title":"进击的巨人 最终季","status":"追番中","progress":13,"jp":"進撃の巨人 The Final Season","time":"2020-12-6.","desc":"在艾伦他们居住的帕拉迪岛之外，还存在一个其他人类居住的世界。当中一个国家「玛雷」与其他各国爆发战争。陷入苦战之际，他们决定要攻进帕拉迪岛，把「始祖的巨人」抢过来。在这里又看到另一群孩子们拼命求生存的身影……。"}],"_content":"","source":"bangumi/index.md","raw":"---\nlayout: bangumi\ntitle: bangumi\ncomments: false\ndate: 2019-02-10 21:32:48\nkeywords:\ndescription:\nbangumis:\n  - img: https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg\n    title: 朝花夕誓——于离别之朝束起约定之花\n    status: 已追完\n    progress: 100\n    jp: さよならの朝に約束の花をかざろう\n    time: 2018-02-24 SUN.\n    desc: 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。\n  - img: http://lain.bgm.tv/pic/cover/l/88/6b/285666_q9f05.jpg\n    title: 进击的巨人 最终季\n    status: 追番中\n    progress: 13\n    jp: 進撃の巨人 The Final Season\n    time: 2020-12-6.\n    desc: 在艾伦他们居住的帕拉迪岛之外，还存在一个其他人类居住的世界。当中一个国家「玛雷」与其他各国爆发战争。陷入苦战之际，他们决定要攻进帕拉迪岛，把「始祖的巨人」抢过来。在这里又看到另一群孩子们拼命求生存的身影……。\n---\n","updated":"2021-09-29T13:40:23.000Z","path":"bangumi/index.html","_id":"cloo2ivvk0002r8v3cjthbicj","content":"<link rel=\"stylesheet\" href=\"/css/spoiler.css\" type=\"text/css\"><script src=\"/js/spoiler.js\" type=\"text/javascript\" async></script>","site":{"data":{}},"excerpt":"","more":""},{"title":"comment","date":"2018-12-20T15:13:48.000Z","keywords":"留言板","description":null,"comments":1,"photos":"https://a154051-img-1321592229.cos.ap-beijing.myqcloud.com/img/comment0.png","_content":"{% raw %}\n<div class=\"entry-content\">\n  <div class=\"poem-wrap\">\n    <div class=\"poem-border poem-left\">\n    </div>\n    <div class=\"poem-border poem-right\">\n    </div>\n    <h1>\n    念两句诗</h1>\n    <p id=\"poem\">\n    叙别梦、扬州一觉。</p>\n    <p id=\"info\">\n    【宋代】吴文英《夜游宫·人去西楼雁杳》</p>\n  </div>\n</div>\n{% endraw %}","source":"comment/index.md","raw":"---\ntitle: comment\ndate: 2018-12-20 23:13:48\nkeywords: 留言板\ndescription: \ncomments: true\nphotos: https://a154051-img-1321592229.cos.ap-beijing.myqcloud.com/img/comment0.png\n---\n{% raw %}\n<div class=\"entry-content\">\n  <div class=\"poem-wrap\">\n    <div class=\"poem-border poem-left\">\n    </div>\n    <div class=\"poem-border poem-right\">\n    </div>\n    <h1>\n    念两句诗</h1>\n    <p id=\"poem\">\n    叙别梦、扬州一觉。</p>\n    <p id=\"info\">\n    【宋代】吴文英《夜游宫·人去西楼雁杳》</p>\n  </div>\n</div>\n{% endraw %}","updated":"2023-10-13T10:42:06.497Z","path":"comment/index.html","layout":"page","_id":"cloo2ivvo0006r8v3gvlf8rta","content":"\n<div class=\"entry-content\">\n  <div class=\"poem-wrap\">\n    <div class=\"poem-border poem-left\">\n    </div>\n    <div class=\"poem-border poem-right\">\n    </div>\n    <h1>\n    念两句诗</h1>\n    <p id=\"poem\">\n    叙别梦、扬州一觉。</p>\n    <p id=\"info\">\n    【宋代】吴文英《夜游宫·人去西楼雁杳》</p>\n  </div>\n</div>\n<link rel=\"stylesheet\" href=\"/css/spoiler.css\" type=\"text/css\"><script src=\"/js/spoiler.js\" type=\"text/javascript\" async></script>","site":{"data":{}},"excerpt":"","more":"\n<div class=\"entry-content\">\n  <div class=\"poem-wrap\">\n    <div class=\"poem-border poem-left\">\n    </div>\n    <div class=\"poem-border poem-right\">\n    </div>\n    <h1>\n    念两句诗</h1>\n    <p id=\"poem\">\n    叙别梦、扬州一觉。</p>\n    <p id=\"info\">\n    【宋代】吴文英《夜游宫·人去西楼雁杳》</p>\n  </div>\n</div>\n"},{"title":"client","date":"2018-12-20T15:13:35.000Z","keywords":"Android客户端","description":null,"comments":0,"photos":"https://a154051-img-1321592229.cos.ap-beijing.myqcloud.com/img/banner/client.jpg","_content":"直接下载 or 扫码下载：\n{% raw %}\n<div style=\"text-align: center;\">\n<img class=\"lazyload\" data-src=\"https://view.moezx.cc/images/2018/06/08/app-download.png#in-center#width-50\" style=\"width: 200px; height: 200px;\" alt=\"\">\n</div>\n{% endraw %}","source":"client/index.md","raw":"---\ntitle: client\ndate: 2018-12-20 23:13:35\nkeywords: Android客户端\ndescription: \ncomments: false\nphotos: https://a154051-img-1321592229.cos.ap-beijing.myqcloud.com/img/banner/client.jpg\n---\n直接下载 or 扫码下载：\n{% raw %}\n<div style=\"text-align: center;\">\n<img class=\"lazyload\" data-src=\"https://view.moezx.cc/images/2018/06/08/app-download.png#in-center#width-50\" style=\"width: 200px; height: 200px;\" alt=\"\">\n</div>\n{% endraw %}","updated":"2023-10-13T10:42:06.497Z","path":"client/index.html","layout":"page","_id":"cloo2ivvq0008r8v34zpm4ip0","content":"<p>直接下载 or 扫码下载：<br>\n<div style=\"text-align: center;\">\n<img class=\"lazyload\" data-src=\"https://view.moezx.cc/images/2018/06/08/app-download.png#in-center#width-50\" style=\"width: 200px; height: 200px;\" alt=\"\">\n</div>\n</p>\n<link rel=\"stylesheet\" href=\"/css/spoiler.css\" type=\"text/css\"><script src=\"/js/spoiler.js\" type=\"text/javascript\" async></script>","site":{"data":{}},"excerpt":"","more":"<p>直接下载 or 扫码下载：<br>\n<div style=\"text-align: center;\">\n<img class=\"lazyload\" data-src=\"https://view.moezx.cc/images/2018/06/08/app-download.png#in-center#width-50\" style=\"width: 200px; height: 200px;\" alt=\"\">\n</div>\n</p>\n"},{"layout":"donate","title":"donate","date":"2018-12-20T15:13:05.000Z","keywords":"谢谢饲主了喵~","description":null,"comments":0,"photos":"https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/donate.jpg","_content":"","source":"donate/index.md","raw":"---\nlayout: donate\ntitle: donate\ndate: 2018-12-20 23:13:05\nkeywords: 谢谢饲主了喵~\ndescription: \ncomments: false\nphotos: https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/donate.jpg\n---\n","updated":"2021-09-29T13:40:23.000Z","path":"donate/index.html","_id":"cloo2ivvr000ar8v37vezfjsf","content":"<link rel=\"stylesheet\" href=\"/css/spoiler.css\" type=\"text/css\"><script src=\"/js/spoiler.js\" type=\"text/javascript\" async></script>","site":{"data":{}},"excerpt":"","more":""},{"title":"游戏","keywords":"游戏","date":"2021-03-09T09:00:00.000Z","photos":"https://a154051-img-1321592229.cos.ap-beijing.myqcloud.com/img/no-game-no-life-zero.jpg","comments":0,"_content":"\n<h2 style=\"text-align:center;margin:40px 0 40px 0\">颓废区</h2>\n\n请自行保存存档\n\n<a href=\"/2048.html\" target=\"_blank\"><span class=\"Mybutton\">2048</span></a>\n\n<a href=\"/adarkroom.html?lang=zh_cn\" target=\"_blank\"><span class=\"Mybutton\">小黑屋</span></a>\n\n<a href=\"/flappybird.html\" target=\"_blank\"><span class=\"Mybutton\">flappy bird</span></a>\n\n<a href=\"https://likexia.gitee.io/evolve\" target=\"_blank\"><span class=\"Mybutton\">进化</span></a>\n\n<a href=\"http://home.ustc.edu.cn/~zzzz/lifegame/lifegame.html\" target=\"_blank\"><span class=\"Mybutton\">生命游戏</span></a>\n\n## [生命游戏介绍](https://zhuanlan.zhihu.com/p/63657798)\n\n## [好东西](http://likexia.gitee.io/game/#/)","source":"games/index.md","raw":"---\ntitle: 游戏\nkeywords: 游戏\ndate: 2021-03-09 17:00:00\nphotos: https://a154051-img-1321592229.cos.ap-beijing.myqcloud.com/img/no-game-no-life-zero.jpg\ncomments: false\n---\n\n<h2 style=\"text-align:center;margin:40px 0 40px 0\">颓废区</h2>\n\n请自行保存存档\n\n<a href=\"/2048.html\" target=\"_blank\"><span class=\"Mybutton\">2048</span></a>\n\n<a href=\"/adarkroom.html?lang=zh_cn\" target=\"_blank\"><span class=\"Mybutton\">小黑屋</span></a>\n\n<a href=\"/flappybird.html\" target=\"_blank\"><span class=\"Mybutton\">flappy bird</span></a>\n\n<a href=\"https://likexia.gitee.io/evolve\" target=\"_blank\"><span class=\"Mybutton\">进化</span></a>\n\n<a href=\"http://home.ustc.edu.cn/~zzzz/lifegame/lifegame.html\" target=\"_blank\"><span class=\"Mybutton\">生命游戏</span></a>\n\n## [生命游戏介绍](https://zhuanlan.zhihu.com/p/63657798)\n\n## [好东西](http://likexia.gitee.io/game/#/)","updated":"2023-10-13T10:42:06.490Z","path":"games/index.html","layout":"page","_id":"cloo2ivvt000fr8v33jf2cnhz","content":"<h2 style=\"text-align:center;margin:40px 0 40px 0\">颓废区</h2>\n\n<p>请自行保存存档</p>\n<p><a href=\"/2048.html\" target=\"_blank\"><span class=\"Mybutton\">2048</span></a></p>\n<p><a href=\"/adarkroom.html?lang=zh_cn\" target=\"_blank\"><span class=\"Mybutton\">小黑屋</span></a></p>\n<p><a href=\"/flappybird.html\" target=\"_blank\"><span class=\"Mybutton\">flappy bird</span></a></p>\n<p><a href=\"https://likexia.gitee.io/evolve\" target=\"_blank\"><span class=\"Mybutton\">进化</span></a></p>\n<p><a href=\"http://home.ustc.edu.cn/~zzzz/lifegame/lifegame.html\" target=\"_blank\"><span class=\"Mybutton\">生命游戏</span></a></p>\n<h2 id=\"生命游戏介绍\"><a href=\"#生命游戏介绍\" class=\"headerlink\" title=\"生命游戏介绍\"></a><a href=\"https://zhuanlan.zhihu.com/p/63657798\">生命游戏介绍</a></h2><h2 id=\"好东西\"><a href=\"#好东西\" class=\"headerlink\" title=\"好东西\"></a><a href=\"http://likexia.gitee.io/game/#/\">好东西</a></h2><link rel=\"stylesheet\" href=\"/css/spoiler.css\" type=\"text/css\"><script src=\"/js/spoiler.js\" type=\"text/javascript\" async></script>","site":{"data":{}},"excerpt":"","more":"<h2 style=\"text-align:center;margin:40px 0 40px 0\">颓废区</h2>\n\n<p>请自行保存存档</p>\n<p><a href=\"/2048.html\" target=\"_blank\"><span class=\"Mybutton\">2048</span></a></p>\n<p><a href=\"/adarkroom.html?lang=zh_cn\" target=\"_blank\"><span class=\"Mybutton\">小黑屋</span></a></p>\n<p><a href=\"/flappybird.html\" target=\"_blank\"><span class=\"Mybutton\">flappy bird</span></a></p>\n<p><a href=\"https://likexia.gitee.io/evolve\" target=\"_blank\"><span class=\"Mybutton\">进化</span></a></p>\n<p><a href=\"http://home.ustc.edu.cn/~zzzz/lifegame/lifegame.html\" target=\"_blank\"><span class=\"Mybutton\">生命游戏</span></a></p>\n<h2 id=\"生命游戏介绍\"><a href=\"#生命游戏介绍\" class=\"headerlink\" title=\"生命游戏介绍\"></a><a href=\"https://zhuanlan.zhihu.com/p/63657798\">生命游戏介绍</a></h2><h2 id=\"好东西\"><a href=\"#好东西\" class=\"headerlink\" title=\"好东西\"></a><a href=\"http://likexia.gitee.io/game/#/\">好东西</a></h2>"},{"title":"lab","comments":0,"date":"2019-01-05T13:47:59.000Z","keywords":"Lab实验室","description":null,"photos":"https://a154051-img-1321592229.cos.ap-beijing.myqcloud.com/img/lab0.jpg","_content":"\n## sakura主题\nbalabala","source":"lab/index.md","raw":"---\ntitle: lab\ncomments: false\ndate: 2019-01-05 21:47:59\nkeywords: Lab实验室\ndescription: \nphotos: https://a154051-img-1321592229.cos.ap-beijing.myqcloud.com/img/lab0.jpg\n---\n\n## sakura主题\nbalabala","updated":"2023-10-13T10:42:06.496Z","path":"lab/index.html","layout":"page","_id":"cloo2ivvu000hr8v3503ffh5u","content":"<h2 id=\"sakura主题\"><a href=\"#sakura主题\" class=\"headerlink\" title=\"sakura主题\"></a>sakura主题</h2><p>balabala</p>\n<link rel=\"stylesheet\" href=\"/css/spoiler.css\" type=\"text/css\"><script src=\"/js/spoiler.js\" type=\"text/javascript\" async></script>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"sakura主题\"><a href=\"#sakura主题\" class=\"headerlink\" title=\"sakura主题\"></a>sakura主题</h2><p>balabala</p>\n"},{"layout":"links","title":"links","date":"2018-12-19T15:11:06.000Z","keywords":"友人帐","description":null,"comments":1,"photos":"https://a154051-img-1321592229.cos.ap-beijing.myqcloud.com/img/links0.jpg","links":[{"group":"奆佬们的博客","desc":"只有自己是蒟蒻","items":[{"url":"https://www.luogu.com.cn/blog/wyd20230071/#","img":"https://a154051-img-1321592229.cos.ap-beijing.myqcloud.com/img/links/1.png","name":"天南星魔芋","desc":null},{"url":"https://www.cnblogs.com/Sure042/","img":"https://a154051-img-1321592229.cos.ap-beijing.myqcloud.com/img/links/2.png","name":"Sure042","desc":null},{"url":"https://www.cnblogs.com/nakiri-ayame-suki/","img":"https://a154051-img-1321592229.cos.ap-beijing.myqcloud.com/img/links/3.png","name":"Nakiri_Ayame_suki","desc":null},{"url":"https://www.cnblogs.com/unknown-year/","img":"https://a154051-img-1321592229.cos.ap-beijing.myqcloud.com/img/links/hn.png","name":"SingularPoint","desc":null},{"url":"https://www.cnblogs.com/Dr-Albert-Wensley/","img":"https://a154051-img-1321592229.cos.ap-beijing.myqcloud.com/img/links/6.jpg","name":"_桀氓_","desc":null},{"url":"https://www.cnblogs.com/ezuyz/","img":"https://a154051-img-1321592229.cos.ap-beijing.myqcloud.com/img/links/ezuyz.png","name":"☄️ezuyz☄️","desc":null},{"url":"https://www.cnblogs.com/xsm098/","img":"https://a154051-img-1321592229.cos.ap-beijing.myqcloud.com/img/links/7.png","name":"gisfire&","desc":null}]}],"_content":"","source":"links/index.md","raw":"---\nlayout: links\ntitle: links\ndate: 2018-12-19 23:11:06\nkeywords: 友人帐\ndescription: \ncomments: true\nphotos: https://a154051-img-1321592229.cos.ap-beijing.myqcloud.com/img/links0.jpg\nlinks:\n  - group: 奆佬们的博客\n    desc: 只有自己是蒟蒻\n    items:\n    - url: https://www.luogu.com.cn/blog/wyd20230071/#\n      img: https://a154051-img-1321592229.cos.ap-beijing.myqcloud.com/img/links/1.png\n      name: 天南星魔芋\n      desc: \n    - url: https://www.cnblogs.com/Sure042/\n      img: https://a154051-img-1321592229.cos.ap-beijing.myqcloud.com/img/links/2.png\n      name: Sure042\n      desc: \n    - url: https://www.cnblogs.com/nakiri-ayame-suki/\n      img: https://a154051-img-1321592229.cos.ap-beijing.myqcloud.com/img/links/3.png\n      name: Nakiri_Ayame_suki\n      desc: \n    - url: https://www.cnblogs.com/unknown-year/\n      img: https://a154051-img-1321592229.cos.ap-beijing.myqcloud.com/img/links/hn.png\n      name: SingularPoint\n      desc: \n    - url: https://www.cnblogs.com/Dr-Albert-Wensley/\n      img: https://a154051-img-1321592229.cos.ap-beijing.myqcloud.com/img/links/6.jpg\n      name: _桀氓_\n      desc: \n    - url: https://www.cnblogs.com/ezuyz/\n      img: https://a154051-img-1321592229.cos.ap-beijing.myqcloud.com/img/links/ezuyz.png\n      name: ☄️ezuyz☄️\n      desc: \n    - url: https://www.cnblogs.com/xsm098/\n      img: https://a154051-img-1321592229.cos.ap-beijing.myqcloud.com/img/links/7.png\n      name: gisfire&\n      desc: \n---\n","updated":"2023-10-13T10:42:06.495Z","path":"links/index.html","_id":"cloo2ivvx000mr8v31k128n0f","content":"<link rel=\"stylesheet\" href=\"/css/spoiler.css\" type=\"text/css\"><script src=\"/js/spoiler.js\" type=\"text/javascript\" async></script>","site":{"data":{}},"excerpt":"","more":""},{"title":"music","date":"2018-12-20T15:14:28.000Z","keywords":"喜欢的音乐","description":null,"comments":0,"photos":"https://a154051-img-1321592229.cos.ap-beijing.myqcloud.com/img/music0.jpg","_content":"{% raw %}\n<meting-js\n  server=\"netease\"\n  type=\"playlist\"\n  id=\"2731690811\"\n  mutex=\"true\">\n</meting-js>\n\n<meting-js\n  server=\"netease\"\n  type=\"playlist\"\n  id=\"419239189\"\n  mutex=\"true\">\n</meting-js>\n{% endraw %}","source":"music/index.md","raw":"---\ntitle: music\ndate: 2018-12-20 23:14:28\nkeywords: 喜欢的音乐\ndescription: \ncomments: false\nphotos: https://a154051-img-1321592229.cos.ap-beijing.myqcloud.com/img/music0.jpg\n---\n{% raw %}\n<meting-js\n  server=\"netease\"\n  type=\"playlist\"\n  id=\"2731690811\"\n  mutex=\"true\">\n</meting-js>\n\n<meting-js\n  server=\"netease\"\n  type=\"playlist\"\n  id=\"419239189\"\n  mutex=\"true\">\n</meting-js>\n{% endraw %}","updated":"2023-10-13T10:42:06.495Z","path":"music/index.html","layout":"page","_id":"cloo2ivvy000qr8v3a9i6eih4","content":"\n<meting-js\n  server=\"netease\"\n  type=\"playlist\"\n  id=\"2731690811\"\n  mutex=\"true\">\n</meting-js>\n\n<meting-js\n  server=\"netease\"\n  type=\"playlist\"\n  id=\"419239189\"\n  mutex=\"true\">\n</meting-js>\n<link rel=\"stylesheet\" href=\"/css/spoiler.css\" type=\"text/css\"><script src=\"/js/spoiler.js\" type=\"text/javascript\" async></script>","site":{"data":{}},"excerpt":"","more":"\n<meting-js\n  server=\"netease\"\n  type=\"playlist\"\n  id=\"2731690811\"\n  mutex=\"true\">\n</meting-js>\n\n<meting-js\n  server=\"netease\"\n  type=\"playlist\"\n  id=\"419239189\"\n  mutex=\"true\">\n</meting-js>\n"},{"title":"rss","date":"2018-12-20T15:09:03.000Z","photos":null,"_content":"","source":"rss/index.md","raw":"---\ntitle: rss\ndate: 2018-12-20 23:09:03\nphotos:\n---\n","updated":"2021-09-29T13:40:23.000Z","path":"rss/index.html","comments":1,"layout":"page","_id":"cloo2ivw0000ur8v34frq938x","content":"<link rel=\"stylesheet\" href=\"/css/spoiler.css\" type=\"text/css\"><script src=\"/js/spoiler.js\" type=\"text/javascript\" async></script>","site":{"data":{}},"excerpt":"","more":""},{"layout":"tags","title":"tags","date":"2018-12-12T14:14:16.000Z","photos":"https://a154051-img-1321592229.cos.ap-beijing.myqcloud.com/img/5-15.png","tagss":null,"comments":0,"_content":"","source":"tags/index.md","raw":"---\nlayout: tags\ntitle: tags\ndate: 2018-12-12 22:14:16\nphotos: https://a154051-img-1321592229.cos.ap-beijing.myqcloud.com/img/5-15.png\ntagss:\ncomments: false\n---","updated":"2023-10-13T12:05:15.700Z","path":"tags/index.html","_id":"cloo2ivw1000yr8v3cepd1y9q","content":"<link rel=\"stylesheet\" href=\"/css/spoiler.css\" type=\"text/css\"><script src=\"/js/spoiler.js\" type=\"text/javascript\" async></script>","site":{"data":{}},"excerpt":"","more":""},{"title":"关于","comments":1,"date":"2019-01-04T14:53:25.000Z","keywords":"关于","description":null,"photos":"https://a154051-img-1321592229.cos.ap-beijing.myqcloud.com/img/1.jpg","_content":"退役OI人，随便写点东西。\n\nQQ：`2279162137`\n\n微信：`m2279162137` （几百年不看一回）\n\nHexo主题Sakura修改自WordPress主题[Sakura](https://github.com/mashirozx/Sakura/)，感谢原作者[Mashiro](https://2heng.xin/)\n\n[Hexo-Sakura主题](https://github.com/honjun/hexo-theme-sakura)\n\n感谢[ctz](https://ctz45562.github.io/)大佬写的[教程](https://ctz45562.github.io/2019/06/04/blog%E3%81%AE%E6%90%AD%E5%BB%BA%E4%B9%8Bsakura)，解决了很多问题。","source":"theme-sakura/index.md","raw":"---\ntitle: 关于\ncomments: true\ndate: 2019-01-04 22:53:25\nkeywords: 关于\ndescription:\nphotos: https://a154051-img-1321592229.cos.ap-beijing.myqcloud.com/img/1.jpg\n---\n退役OI人，随便写点东西。\n\nQQ：`2279162137`\n\n微信：`m2279162137` （几百年不看一回）\n\nHexo主题Sakura修改自WordPress主题[Sakura](https://github.com/mashirozx/Sakura/)，感谢原作者[Mashiro](https://2heng.xin/)\n\n[Hexo-Sakura主题](https://github.com/honjun/hexo-theme-sakura)\n\n感谢[ctz](https://ctz45562.github.io/)大佬写的[教程](https://ctz45562.github.io/2019/06/04/blog%E3%81%AE%E6%90%AD%E5%BB%BA%E4%B9%8Bsakura)，解决了很多问题。","updated":"2023-10-13T10:42:06.489Z","path":"theme-sakura/index.html","layout":"page","_id":"cloo2ivw20012r8v30z9n6znm","content":"<p>退役OI人，随便写点东西。</p>\n<p>QQ：<code>2279162137</code></p>\n<p>微信：<code>m2279162137</code> （几百年不看一回）</p>\n<p>Hexo主题Sakura修改自WordPress主题<a href=\"https://github.com/mashirozx/Sakura/\">Sakura</a>，感谢原作者<a href=\"https://2heng.xin/\">Mashiro</a></p>\n<p><a href=\"https://github.com/honjun/hexo-theme-sakura\">Hexo-Sakura主题</a></p>\n<p>感谢<a href=\"https://ctz45562.github.io/\">ctz</a>大佬写的<a href=\"https://ctz45562.github.io/2019/06/04/blog%E3%81%AE%E6%90%AD%E5%BB%BA%E4%B9%8Bsakura\">教程</a>，解决了很多问题。</p>\n<link rel=\"stylesheet\" href=\"/css/spoiler.css\" type=\"text/css\"><script src=\"/js/spoiler.js\" type=\"text/javascript\" async></script>","site":{"data":{}},"excerpt":"","more":"<p>退役OI人，随便写点东西。</p>\n<p>QQ：<code>2279162137</code></p>\n<p>微信：<code>m2279162137</code> （几百年不看一回）</p>\n<p>Hexo主题Sakura修改自WordPress主题<a href=\"https://github.com/mashirozx/Sakura/\">Sakura</a>，感谢原作者<a href=\"https://2heng.xin/\">Mashiro</a></p>\n<p><a href=\"https://github.com/honjun/hexo-theme-sakura\">Hexo-Sakura主题</a></p>\n<p>感谢<a href=\"https://ctz45562.github.io/\">ctz</a>大佬写的<a href=\"https://ctz45562.github.io/2019/06/04/blog%E3%81%AE%E6%90%AD%E5%BB%BA%E4%B9%8Bsakura\">教程</a>，解决了很多问题。</p>\n"},{"title":"video","date":"2018-12-20T15:14:38.000Z","keywords":"B站","description":null,"comments":0,"photos":null,"_content":"{% raw %}\n<script>\n  var videos = [\n    {\n      img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg',\n      title: '朝花夕誓——于离别之朝束起约定之花',\n      status: '已追完',\n      progress: 100,\n      jp: 'さよならの朝に約束の花をかざろう',\n      time: '放送时间: 2018-02-24 SUN.',\n      desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。'\n    },\n    {\n      img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg',\n      title: '朝花夕誓——于离别之朝束起约定之花',\n      status: '已追完',\n      progress: 100,\n      jp: 'さよならの朝に約束の花をかざろう',\n      time: '2018-02-24 SUN.',\n      desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。'\n    }\n  ]\n</script>\n{% endraw %}\n\n{% raw %}\n  <style>.should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}\n  </style>\n  <header class=\"page-header\"><h1 class=\"cat-title\">番组计划</h1> <span class=\"cat-des\"><p>这里将是永远的回忆</p> </span></header>\n  <div class=\"bangumi\">\n    <div class=\"row\" id=\"rootRow\">\n    </div>\n  </div>\n  <script>\n  window.onload = function(){\n    videos.forEach(function(video, i){\n      $('#rootRow').append(`<div class=\"col s12 m6\" id=\"bangumi-218971\">\n        <div class=\"card hoverable\" style=\"overflow: visible;\">\n          <div class=\"card-image waves-effect waves-block waves-light\">\n            <div class=\"activator itempic lazyload\" style=\"background-image: url(${video.img});\" data-src=\"${video.img}\">\n            </div>\n          </div>\n          <div class=\"card-content\">\n            <div class=\"card-title should-ellipsis activator grey-text text-darken-4\">\n              ${video.title}<i class=\"fa fa-commenting-o right\"></i>\n            </div>\n            <p class=\"should-ellipsis-full\">\n            ${video.jp}</p>\n            <ul class=\"skill-list\">\n              <li class=\"skill\">\n                <div>\n                ${video.status}</div>\n                <progress class=\"skill-1\" max=\"100\" value=\"${video.progress}\">\n                </progress>\n              </li>\n            </ul>\n          </div>\n          <div class=\"card-reveal\" style=\"display: none; transform: translateY(0%);\">\n            <span class=\"card-title grey-text text-darken-4\">\n              ${video.title}<i class=\"fa fa-close right\"></i>\n            </span>\n            <span>\n              ${video.jp}<br>\n            </span>\n            <span>\n              放送时间: ${video.time}<span>\n                <p>${video.desc}</p>\n                <ul class=\"skill-list\">\n                  <li class=\"skill\">\n                    <div>\n                    ${video.status}</div>\n                    <progress class=\"skill-1\" max=\"100\" value=\"${video.progress}\">\n                    </progress>\n                  </li>\n                </ul>\n              </span>\n            </span>\n          </div>\n        </div>\n      </div>`)\n    })\n  }\n  </script>\n{% endraw %}","source":"video/index.md","raw":"---\ntitle: video\ndate: 2018-12-20 23:14:38\nkeywords: B站\ndescription: \ncomments: false\nphotos: \n---\n{% raw %}\n<script>\n  var videos = [\n    {\n      img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg',\n      title: '朝花夕誓——于离别之朝束起约定之花',\n      status: '已追完',\n      progress: 100,\n      jp: 'さよならの朝に約束の花をかざろう',\n      time: '放送时间: 2018-02-24 SUN.',\n      desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。'\n    },\n    {\n      img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg',\n      title: '朝花夕誓——于离别之朝束起约定之花',\n      status: '已追完',\n      progress: 100,\n      jp: 'さよならの朝に約束の花をかざろう',\n      time: '2018-02-24 SUN.',\n      desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。'\n    }\n  ]\n</script>\n{% endraw %}\n\n{% raw %}\n  <style>.should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}\n  </style>\n  <header class=\"page-header\"><h1 class=\"cat-title\">番组计划</h1> <span class=\"cat-des\"><p>这里将是永远的回忆</p> </span></header>\n  <div class=\"bangumi\">\n    <div class=\"row\" id=\"rootRow\">\n    </div>\n  </div>\n  <script>\n  window.onload = function(){\n    videos.forEach(function(video, i){\n      $('#rootRow').append(`<div class=\"col s12 m6\" id=\"bangumi-218971\">\n        <div class=\"card hoverable\" style=\"overflow: visible;\">\n          <div class=\"card-image waves-effect waves-block waves-light\">\n            <div class=\"activator itempic lazyload\" style=\"background-image: url(${video.img});\" data-src=\"${video.img}\">\n            </div>\n          </div>\n          <div class=\"card-content\">\n            <div class=\"card-title should-ellipsis activator grey-text text-darken-4\">\n              ${video.title}<i class=\"fa fa-commenting-o right\"></i>\n            </div>\n            <p class=\"should-ellipsis-full\">\n            ${video.jp}</p>\n            <ul class=\"skill-list\">\n              <li class=\"skill\">\n                <div>\n                ${video.status}</div>\n                <progress class=\"skill-1\" max=\"100\" value=\"${video.progress}\">\n                </progress>\n              </li>\n            </ul>\n          </div>\n          <div class=\"card-reveal\" style=\"display: none; transform: translateY(0%);\">\n            <span class=\"card-title grey-text text-darken-4\">\n              ${video.title}<i class=\"fa fa-close right\"></i>\n            </span>\n            <span>\n              ${video.jp}<br>\n            </span>\n            <span>\n              放送时间: ${video.time}<span>\n                <p>${video.desc}</p>\n                <ul class=\"skill-list\">\n                  <li class=\"skill\">\n                    <div>\n                    ${video.status}</div>\n                    <progress class=\"skill-1\" max=\"100\" value=\"${video.progress}\">\n                    </progress>\n                  </li>\n                </ul>\n              </span>\n            </span>\n          </div>\n        </div>\n      </div>`)\n    })\n  }\n  </script>\n{% endraw %}","updated":"2021-09-29T13:40:23.000Z","path":"video/index.html","layout":"page","_id":"cloo2ivw30015r8v3gl6g3m4e","content":"\n<script>\n  var videos = [\n    {\n      img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg',\n      title: '朝花夕誓——于离别之朝束起约定之花',\n      status: '已追完',\n      progress: 100,\n      jp: 'さよならの朝に約束の花をかざろう',\n      time: '放送时间: 2018-02-24 SUN.',\n      desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。'\n    },\n    {\n      img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg',\n      title: '朝花夕誓——于离别之朝束起约定之花',\n      status: '已追完',\n      progress: 100,\n      jp: 'さよならの朝に約束の花をかざろう',\n      time: '2018-02-24 SUN.',\n      desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。'\n    }\n  ]\n</script>\n\n\n  <style>.should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}\n  </style>\n  <header class=\"page-header\"><h1 class=\"cat-title\">番组计划</h1> <span class=\"cat-des\"><p>这里将是永远的回忆</p> </span></header>\n  <div class=\"bangumi\">\n    <div class=\"row\" id=\"rootRow\">\n    </div>\n  </div>\n  <script>\n  window.onload = function(){\n    videos.forEach(function(video, i){\n      $('#rootRow').append(`<div class=\"col s12 m6\" id=\"bangumi-218971\">\n        <div class=\"card hoverable\" style=\"overflow: visible;\">\n          <div class=\"card-image waves-effect waves-block waves-light\">\n            <div class=\"activator itempic lazyload\" style=\"background-image: url(${video.img});\" data-src=\"${video.img}\">\n            </div>\n          </div>\n          <div class=\"card-content\">\n            <div class=\"card-title should-ellipsis activator grey-text text-darken-4\">\n              ${video.title}<i class=\"fa fa-commenting-o right\"></i>\n            </div>\n            <p class=\"should-ellipsis-full\">\n            ${video.jp}</p>\n            <ul class=\"skill-list\">\n              <li class=\"skill\">\n                <div>\n                ${video.status}</div>\n                <progress class=\"skill-1\" max=\"100\" value=\"${video.progress}\">\n                </progress>\n              </li>\n            </ul>\n          </div>\n          <div class=\"card-reveal\" style=\"display: none; transform: translateY(0%);\">\n            <span class=\"card-title grey-text text-darken-4\">\n              ${video.title}<i class=\"fa fa-close right\"></i>\n            </span>\n            <span>\n              ${video.jp}<br>\n            </span>\n            <span>\n              放送时间: ${video.time}<span>\n                <p>${video.desc}</p>\n                <ul class=\"skill-list\">\n                  <li class=\"skill\">\n                    <div>\n                    ${video.status}</div>\n                    <progress class=\"skill-1\" max=\"100\" value=\"${video.progress}\">\n                    </progress>\n                  </li>\n                </ul>\n              </span>\n            </span>\n          </div>\n        </div>\n      </div>`)\n    })\n  }\n  </script>\n<link rel=\"stylesheet\" href=\"/css/spoiler.css\" type=\"text/css\"><script src=\"/js/spoiler.js\" type=\"text/javascript\" async></script>","site":{"data":{}},"excerpt":"","more":"\n<script>\n  var videos = [\n    {\n      img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg',\n      title: '朝花夕誓——于离别之朝束起约定之花',\n      status: '已追完',\n      progress: 100,\n      jp: 'さよならの朝に約束の花をかざろう',\n      time: '放送时间: 2018-02-24 SUN.',\n      desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。'\n    },\n    {\n      img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg',\n      title: '朝花夕誓——于离别之朝束起约定之花',\n      status: '已追完',\n      progress: 100,\n      jp: 'さよならの朝に約束の花をかざろう',\n      time: '2018-02-24 SUN.',\n      desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。'\n    }\n  ]\n</script>\n\n\n  <style>.should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}\n  </style>\n  <header class=\"page-header\"><h1 class=\"cat-title\">番组计划</h1> <span class=\"cat-des\"><p>这里将是永远的回忆</p> </span></header>\n  <div class=\"bangumi\">\n    <div class=\"row\" id=\"rootRow\">\n    </div>\n  </div>\n  <script>\n  window.onload = function(){\n    videos.forEach(function(video, i){\n      $('#rootRow').append(`<div class=\"col s12 m6\" id=\"bangumi-218971\">\n        <div class=\"card hoverable\" style=\"overflow: visible;\">\n          <div class=\"card-image waves-effect waves-block waves-light\">\n            <div class=\"activator itempic lazyload\" style=\"background-image: url(${video.img});\" data-src=\"${video.img}\">\n            </div>\n          </div>\n          <div class=\"card-content\">\n            <div class=\"card-title should-ellipsis activator grey-text text-darken-4\">\n              ${video.title}<i class=\"fa fa-commenting-o right\"></i>\n            </div>\n            <p class=\"should-ellipsis-full\">\n            ${video.jp}</p>\n            <ul class=\"skill-list\">\n              <li class=\"skill\">\n                <div>\n                ${video.status}</div>\n                <progress class=\"skill-1\" max=\"100\" value=\"${video.progress}\">\n                </progress>\n              </li>\n            </ul>\n          </div>\n          <div class=\"card-reveal\" style=\"display: none; transform: translateY(0%);\">\n            <span class=\"card-title grey-text text-darken-4\">\n              ${video.title}<i class=\"fa fa-close right\"></i>\n            </span>\n            <span>\n              ${video.jp}<br>\n            </span>\n            <span>\n              放送时间: ${video.time}<span>\n                <p>${video.desc}</p>\n                <ul class=\"skill-list\">\n                  <li class=\"skill\">\n                    <div>\n                    ${video.status}</div>\n                    <progress class=\"skill-1\" max=\"100\" value=\"${video.progress}\">\n                    </progress>\n                  </li>\n                </ul>\n              </span>\n            </span>\n          </div>\n        </div>\n      </div>`)\n    })\n  }\n  </script>\n"}],"Post":[{"author":"a154051","avatar":"https://a154051-img-1321592229.cos.ap-beijing.myqcloud.com/img/头像new.jpg","title":"十月做题记录","mathjax":true,"date":"2023-10-24T08:10:00.000Z","description":"记录摆烂的十月","keywords":"十月做题记录","photos":["https://a154051-img-1321592229.cos.ap-beijing.myqcloud.com/img/23-10-24.jpg"],"_content":"\n加星号表示看了题解。\n\n摆烂的十月份。\n\n## P1709 [USACO5.5] 隐藏口令 Hidden Password ＊\n\n [题目链接](https://www.luogu.com.cn/problem/P1709)\n \n最小表示法模板题，设当前比较以 $i$ 和 $j$ 开头的字符串，则对两字符串一位一位向后比较，即每次比较 $i+k$ 和 $j+k$，直到遇到不同的字符，假设 $i$ 开头的字符串更小，则令 $j$ 直接跳到 $j+k+1$，因为对于以 $j$ 到 $j+k$ 开头的字符串，都有对应的以 $i$ 到 $i+k$ 开头的字符串必它小。时间复杂度 $O( n)$。\n\n\n{% spoiler \"代码\" %}\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nconst int N=5e6+7;\nchar a[N];\nint main()\n{\n    int n;\n    cin>>n;\n    for(int i=0;i<n;++i) {\n        char ch=getchar();\n        while(ch<'a'||ch>'z')  ch=getchar();\n        a[i]=ch;\n    }\n    int i=0,j=1,k=0;\n    while(k<n&&i<n&&j<n) {\n        if(a[(i+k)%n]==a[(j+k)%n])  ++k;\n        else {\n            a[(i+k)%n]>a[(j+k)%n]?i=i+k+1:j=j+k+1;\n            if(i==j)  ++i;\n            k=0;\n        }\n    }\n    cout<<min(i,j);\n    return 0;\n}\n```\n\n{% endspoiler %}\n\n## P6310 「Wdsr-1」仓库建设 \n\n[题目链接](https://www.luogu.com.cn/problem/P6310)\n\n写过题解了，[【题解】P6310 [Wdsr-1]仓库建设](https://a154051.gitee.io/2023/09/25/solution-P6310-cang-ku-jian-she/)\n\n\n\n## 武汉大学2023年新生程序设计竞赛（同步赛）\n\n###  A. 教科书般的亵渎\n\n[题目链接](https://ac.nowcoder.com/acm/contest/66651/A)\n\n将 $a$ 从大到小排序，若第一项为 $0$ 或 $1$ 且后面每一项与前一项的差小于等于 $1$ 则为 $YES$，否则为 $NO$。\n\n{% spoiler \"代码\" %}\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nconst int N=1e6;\nint a[N];\nint main()\n{\n    int n;\n    cin>>n;\n    for(int i=1;i<=n;++i)  scanf(\"%d\",&a[i]);\n    sort(a+1,a+1+n);\n    int last=0;\n    for(int i=1;i<=n;++i) {\n        if(a[i]==last||a[i]==last+1) {last=a[i];continue;}\n        cout<<\"NO\";\n        return 0;\n    }\n    cout<<\"YES\";\n    return 0;\n}\n```\n\n{% endspoiler %}\n\n### C. 覆叶之交\n\n[题目链接](https://ac.nowcoder.com/acm/contest/66651/C)\n\n给定三个矩形，求它们的面积并。\n\n用容斥写，难点在代码实现。\n\n{% spoiler \"代码\" %}\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nstruct squ {\n    bool flag;\n    ll x1,x2,y1,y2;\n}a[20];\nint tot=3,tmp[10];\n\nvoid sol(squ A,squ B)\n{\n    ++tot;\n    if(A.flag||B.flag) {a[tot].flag=1;return ;}\n    if(A.x2<=B.x1||B.x2<=A.x1||A.y2<=B.y1||B.y2<=A.y1)  {a[tot].flag=1;return ;}\n    tmp[1]=A.x1;tmp[2]=A.x2;tmp[3]=B.x1;tmp[4]=B.x2;\n    sort(tmp+1,tmp+5);\n    a[tot].x2=tmp[3];a[tot].x1=tmp[2];\n\n    tmp[1]=A.y1;tmp[2]=A.y2;tmp[3]=B.y1;tmp[4]=B.y2;\n    sort(tmp+1,tmp+5);\n    a[tot].y1=tmp[2];a[tot].y2=tmp[3];\n}\nint main()\n{\n    ll ans=0;\n    for(int i=1;i<=3;++i) {\n        cin>>a[i].x1>>a[i].y1>>a[i].x2>>a[i].y2;\n        ans+=abs((a[i].x1-a[i].x2)*(a[i].y1-a[i].y2));\n    }\n    for(int i=1;i<=3;++i)\n        for(int j=i+1;j<=3;++j) {\n            sol(a[i],a[j]);\n            if(a[tot].flag==0)  ans-=abs((a[tot].x1-a[tot].x2)*(a[tot].y1-a[tot].y2));\n        }\n    sol(a[4],a[5]);sol(a[6],a[7]);\n    if(a[tot].flag==0)  ans+=abs((a[tot].x1-a[tot].x2)*(a[tot].y1-a[tot].y2));\n    cout<<ans;\n    return 0;\n}\n```\n\n{% endspoiler %}\n\n### E. 不是n皇后问题\n\n[题目链接](https://ac.nowcoder.com/acm/contest/66651/E)\n\n看着挺麻烦，实际上就是把 $1$ 到 $n^2$ 按顺序填进格子就行了。\n\n{% spoiler \"代码\" %}\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nconst int N=1e6;\nint main()\n{\n    int n,cnt=0;\n    cin>>n;\n    for(int i=1;i<=n;++i) {\n        for(int j=1;j<=n;++j)  printf(\"%d \",++cnt);\n        printf(\"\\n\");\n    }\n        \n\n    return 0;\n}\n```\n\n{% endspoiler %}\n\n### J. 放棋子\n\n[题目链接](https://ac.nowcoder.com/acm/contest/66651/J)\n\n行和列可以分开计算，对于同一行，要使分数最大，则每次落子需要相连的旗子尽可能多，因此可以从左至右依次落子，这样就可以得到这一行的最大分数。可以证明，如果从第一行到最后一行操作也可以得到列的最大分数。时间复杂度 $O(n\\times m)$。\n\n{% spoiler \"代码\" %}\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=1e5+7;\nvector<int> a[N];\nint main()\n{\n    int n,m;\n    ll ans=0;\n    cin>>n>>m;\n    for(int i=1;i<=n;++i) {\n        a[i].push_back(0);\n        ll now=0;\n        for(int j=1;j<=m;++j) {\n            char ch=getchar();\n            while(ch!='#'&&ch!='.')  ch=getchar();\n            a[i].push_back(0);\n            if(ch=='#') {\n                a[i][j]=1;\n                ++now;\n                ans+=now*now;\n            } \n            else  now=0;\n        }\n    }\n    for(int i=1;i<=m;++i) {\n        ll now=0;\n        for(int j=1;j<=n;++j) {\n            if(a[j][i])  ++now,ans+=now*now;\n            else  now=0;\n        }\n    }\n    cout<<ans;\n    return 0;\n}\n```\n\n{% endspoiler %}\n\n### K. 矩形分割\n\n[题目链接](https://ac.nowcoder.com/acm/contest/66651/K)\n\n显然我们想要分割出来的正方形边长尽可能大，所以以矩形的短边为正方形边长进行分割直到无法分割，如果还剩下来一个小矩形，就再对这个矩形进行上述操作，直到分割完全。\n\n\n{% spoiler \"代码\" %}\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nint sol(int n,int m)\n{\n    if(n==0||m==0)  return 0;\n    if(n==m)  return n;\n    if(n<m)  swap(n,m);\n    return m*(n/m)+sol(m,n%m);\n\n}\nint main()\n{\n    int n,m;\n    cin>>n>>m;\n    cout<<sol(n,m);\n    return 0;\n}\n```\n\n{% endspoiler %}\n\n### L. 小镜的数学题\n\n[题目链接](https://ac.nowcoder.com/acm/contest/66651/L)\n\n从 $x$ 向后暴力找，最坏也不会超过 $2x$，数据比较水就过了。\n\n{% spoiler \"代码\" %}\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nint main()\n{\n    ll n;\n    cin>>n;\n    for(ll i=n+1;;++i) {\n        if((n&i)==0) {\n            cout<<i;\n            return 0;\n        }\n        n=(n&i);\n    }\n    return 0;\n}\n```\n\n{% endspoiler %}\n\n## P2017 [USACO09DEC] Dizzy Cows G \n\n[题目链接](https://www.luogu.com.cn/problem/P2017)\n\n给定一个图，有无向边和有向边，给每条无向边指定一个方向，并且不出现环。\n\n考虑拓扑排序判定有向无环图的过程，每次删去出度为 $0$ 的点，若最终能删完则为有向无环图，可以发现，每条边都是由拓扑序大的指向拓扑序小的。因此在本题中先无视无向边对原图进行拓扑排序，再让无向边由拓扑序大的点指向拓扑序小的点，就得到了有向无环图。\n\n{% spoiler \"代码\" %}\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nconst int N=1e5+7;\nvector<int> last[N];\nint deg[N],dep[N],cnt=0;\ndeque<int> q;\nint main()\n{\n    int n,m1,m2;\n    cin>>n>>m1>>m2;\n    for(int i=1;i<=m1;++i) {\n        int x,y;\n        scanf(\"%d%d\",&x,&y);\n        ++deg[x];\n        last[y].push_back(x);\n    }\n    for(int i=1;i<=n;++i)\n        if(!deg[i])  q.push_back(i);\n    while(q.size()) {\n        int x=q.front();\n        q.pop_front();\n        dep[x]=++cnt;\n        for(int i=0;i<last[x].size();++i) \n            if((--deg[last[x][i]])==0)  q.push_back(last[x][i]);\n        \n    }\n    while(m2--) {\n        int x,y;\n        scanf(\"%d%d\",&x,&y);\n        if(dep[x]<dep[y])  swap(x,y);\n        printf(\"%d %d\\n\",x,y);\n    }\n    return 0;\n}\n```\n\n{% endspoiler %}\n\n## 2023 年华中科技大学程序设计竞赛新生赛（线上同步赛）\n\n几乎每道题都会犯sb错误，我是超级罚时王。\n\n### P9769 [HUSTFC 2023] 简单的加法乘法计算题 \n\n[题目链接](https://www.luogu.com.cn/problem/P9769)\n\n设 $f_i$ 表示从 $0$ 到 $i$ 的最小操作次数，考虑最后一次操作，要么是加上 $A$  中的一个数，要么是乘上 $B$ 中的一个数，所以 $f_i=\\min\\{ \\min\\limits_{j=1}^n f_{i-A_j},\\min\\limits_{k=1}^m f_{i/B_k}\\}$，加法用堆来维护，乘法一个个枚举，时间复杂度 $O(ym\\log n)$，如果用单调队列可以降到 $O(ym)$。\n\n\n{% spoiler \"代码\" %}\n\n```cpp\n#include <bits/stdc++.h>\n#define mp(x,y) make_pair(x,y)\ntypedef long long ll;\nusing namespace std;\nconst int N=5e6+7;\nint f[N],b[20];\npriority_queue<pair<int,int> > q;\nbool vis[N];\nint main()\n{\n    int x,n,m;\n    cin>>x>>n>>m;\n    for(int i=1;i<=m;++i)  scanf(\"%d\",&b[i]);\n    vis[0]=1;q.push(mp(0,0));\n    for(int i=1;i<=x;++i) {\n        int tmp=q.top().second;\n        while(!vis[tmp])  q.pop(),tmp=q.top().second;\n        f[i]=f[tmp]+1;\n        for(int j=1;j<=m;++j)\n            if(i%b[j]==0)  f[i]=min(f[i],f[i/b[j]]+1);\n        q.push(mp(-f[i],i));\n        vis[i]=1;\n        if(i-n-1>=0)  vis[i-n-1]=0;\n    }\n    cout<<f[x];\n    return 0;\n}\n```\n\n{% endspoiler %}\n\n### P9771  [HUSTFC 2023] 排列排序问题 \n\n[题目链接](https://www.luogu.com.cn/problem/P9771)\n\n显然切割出来的序列是单调的，并且相邻的两个数相差 $1$，按这个方法切割使每个切出来的序列尽可能大就行了。时间复杂度 $O(n)$。\n\n\n\n{% spoiler \"代码\" %}\n\n```cpp\n#include <bits/stdc++.h>\ntypedef long long ll;\nusing namespace std;\nconst int N=1e6+7;\nint a[N];\nint main()\n{\n    int n;\n    cin>>n;\n    for(int i=1;i<=n;++i)  scanf(\"%d\",&a[i]);\n    int flag=-1,last=a[1],ans=0;\n    for(int i=2;i<=n;++i) {\n        if(flag==-1) {\n            if(a[i]==last+1)  flag=1,last=a[i];\n            else  if(a[i]==last-1)  flag=0,last=a[i];\n            else  last=a[i],++ans;\n            continue;\n        }\n        if(a[i]==last+1&&flag==1) {last=a[i];continue;}\n        if(a[i]==last-1&&flag==0) {last=a[i];continue;}\n        last=a[i];++ans;\n        flag=-1;\n    }\n    cout<<ans;\n    return 0;\n}\n```\n\n{% endspoiler %}\n\n### P9774[HUSTFC 2023] 新取模运算 \n\n[题目链接](https://www.luogu.com.cn/problem/P9774)\n\n显然新定义的运算符满足分配律，于是对于 $n$ 到 $1$ 这 $n$ 个数，可以分为是 $p$ 的倍数和不是 $p$ 的倍数分别计算，最后再相乘。\n\n对于不是 $p$ 的倍数的数，它们对 $p$ 进行新定义运算等价于直接对 $p$ 取模，这一部分可以通过预处理 $1$ 到 $p$ 的阶乘来求解。\n\n对于是 $p$ 的倍数的数，例如 $p,2p,3p...kp$，它们对 $p$ 进行新定义运算需要先除以 $p$，变为 $1,2,3...k$，这就成了原问题的子问题，于是可以递归求解，边界是 $ k<p$。时间复杂度 $O(\\log_p n \\times \\log n)$。\n\n\n{% spoiler \"代码\" %}\n\n```cpp\n#include <bits/stdc++.h>\ntypedef long long ll;\nusing namespace std;\nconst int N=1e6+7;\nint p;\nll jc[N];\nll qpow(ll x,ll k)\n{;\n    ll ans=1,tmp=x;\n    while(k) {\n        if(k&1)  ans=ans*tmp%p;\n        tmp=tmp*tmp%p;\n        k>>=1;\n    }\n    return ans;\n}\nll sol(ll n)\n{\n    ll tmp=n/p;\n    ll ans=qpow(jc[p-1],tmp)*jc[n%p]%p;\n    if(tmp)  ans=ans*sol(tmp)%p;\n    return ans;\n}\nint main()\n{\n    int T;\n    cin>>T>>p;\n    jc[0]=1;\n    for(int i=1;i<=p;++i)  jc[i]=jc[i-1]*i%p;\n    while(T--) {\n        ll n;\n        scanf(\"%lld\",&n);\n        printf(\"%lld\\n\",sol(n));\n    }\n    return 0;\n}\n```\n\n{% endspoiler %}\n\n### P9775 [HUSTFC 2023] 广义线段树 \n\n[题目链接](https://www.luogu.com.cn/problem/P9775)\n\n给定一棵 $2n-1$ 个节点的树，$1$ 是根节点，$n$ 到 $2n-1$ 是叶子节点，给定叶子节点的点权，其他节点的点权是以它为子树的所有叶子节点的乘积。令每个叶子节点乘上一个数，求最后所有节点的和。\n\n对叶子节点乘上一个数，则从叶子节点到根节点路径上所有节点都要乘上这个数。所以原问题转化为对树上的一条链乘上一个数，可以用树链剖分，时间复杂度 $O(n\\log^2 n)$。比赛时没细想，但实际上可以先对所有叶子节点做修改，再在 dfs 返回时向上传就可以了，时间复杂度 $O(n)$。\n\n\n{% spoiler \"代码\" %}\n\n```cpp\n#include <bits/stdc++.h>\ntypedef long long ll;\nusing namespace std;\nconst int N=2e6+7,mod=998244353;\nstruct tree {\n    ll tag,val;\n}tr[N<<1];\nll a[N],b[N];\nint nx[N][2],fa[N],dep[N],siz[N],top[N],pos[N],son[N],tot=0,rev[N];\nvoid push(int now,ll k)\n{\n    tr[now].val=tr[now].val*k%mod;\n    tr[now].tag=tr[now].tag*k%mod;\n    return ;\n}\nvoid build(int now,int l,int r)\n{\n    tr[now].tag=1;\n    if(l==r) {tr[now].val=a[rev[l]];return ;}\n    int mid=(l+r)>>1;\n    build(now<<1,l,mid);\n    build(now<<1|1,mid+1,r);\n    tr[now].val=(tr[now<<1].val+tr[now<<1|1].val)%mod;\n}\nvoid mul(int now,int l,int r,int x,int y,ll k)\n{\n    if(l>=x&&r<=y) {\n        tr[now].val=tr[now].val*k%mod;\n        tr[now].tag=tr[now].tag*k%mod;\n        return ;\n    }\n    if(tr[now].tag!=1) {\n        push(now<<1,tr[now].tag);\n        push(now<<1|1,tr[now].tag);\n        tr[now].tag=1;\n    }\n    \n    int mid=(l+r)>>1;\n    if(x<=mid)  mul(now<<1,l,mid,x,y,k);\n    if(y>mid)  mul(now<<1|1,mid+1,r,x,y,k);\n    tr[now].val=(tr[now<<1].val+tr[now<<1|1].val)%mod;\n}\n\nvoid dfs1(int x,int FA)\n{\n    fa[x]=FA;dep[x]=dep[FA]+1;siz[x]=1;\n    if(nx[x][0]) {\n        dfs1(nx[x][0],x);dfs1(nx[x][1],x);\n        siz[x]+=siz[nx[x][0]]+siz[nx[x][1]];\n        son[x]=siz[nx[x][0]]>siz[nx[x][1]]?nx[x][0]:nx[x][1];\n        a[x]=a[nx[x][0]]*a[nx[x][1]]%mod;\n    }\n}\nvoid dfs2(int x,int tp)\n{\n    top[x]=tp;pos[x]=++tot;rev[tot]=x;\n    if(!son[x])  return ;\n    dfs2(son[x],tp);\n    int tmp=nx[x][0];\n    if(tmp==son[x])  tmp=nx[x][1];\n    dfs2(tmp,tmp);\n}\nvoid chg(int x,ll k)\n{\n    if(k==1)  return ;\n    while(x) {\n        mul(1,1,tot,pos[top[x]],pos[x],k);\n        x=fa[top[x]];\n    }\n}\nint main()\n{\n    int n;\n    cin>>n;\n    for(int i=n;i<=n*2-1;++i)  scanf(\"%lld\",&a[i]);\n    for(int i=1;i<=n;++i)  scanf(\"%lld\",&b[i]);\n    for(int i=1;i<n;++i)  scanf(\"%d%d\",&nx[i][0],&nx[i][1]);\n    dfs1(1,0);\n    dfs2(1,1);\n    build(1,1,tot);\n    for(int i=1;i<=n;++i) {\n        chg(i+n-1,b[i]);\n        printf(\"%lld \",tr[1].val);\n    }\n    return 0;\n}\n```\n\n{% endspoiler %}\n\n### P9777 [HUSTFC 2023] Fujisaki 讨厌数学 \n\n[题目链接](https://www.luogu.com.cn/problem/P9777)\n\n已知 $x^1+x^{-1}=k$，求 $x^n+x^{-n}$。\n\n可以发现 $(x^a+x^{-a})(x^b+x^{-b})=x^{a+b}+x^{-(a+b)}+x^{(a-b)}+x^{-(a-b)}$。设 $f_n=x^n+x^{-n}$，可以得到 $f_{(a+b)}=f_a \\times f_b-f_{(a-b)}$。因此，若 $n$ 是偶数，有 $f_n=f_{n/2}^2-f_0$，若 $n$ 是奇数，有 $f_n=f_{n/2}\\times f_{n/2+1}-f_1$。\n\n设 $n$ 在第一层，向下拆分得到第二层，第二层要么有一个数要么有两个数，考虑两个数的情况，这两个数一定相差 $1$，将它们向下拆分，第三层仍然是两个数，并且也是相差 $1$，可以证明每一层都至多两个数。每次拆分都除以 $2$，因此有 $\\log n$ 层。可以用记忆化搜索，但是 $n$ 太大了，要用 $map$ 存，时间复杂度 $O(\\log^2 n)$。\n\n\n{% spoiler \"代码\" %}\n\n```cpp\n#include <bits/stdc++.h>\ntypedef long long ll;\nusing namespace std;\nmap<ll,ll> mp;\nconst int N=1e6+7;\nint mod;\nll k;\nll sol(ll n)\n{\n    if(n==1)  return k;\n    if(mp.find(n)!=mp.end())  return mp[n];\n    ll ans=1;\n    if(n&1)  ans=sol(n/2)*sol(n/2+1)%mod-k;\n    else  ans=sol(n/2),ans=ans*ans%mod-2;\n    while(ans<0)  ans+=mod;\n    mp[n]=ans;\n    return ans;\n}\nint main()\n{\n    ll n;\n    cin>>mod>>k>>n;\n    if(n==0)  cout<<\"2\";\n    else  printf(\"%lld\",sol(n));\n\n    return 0;\n}\n```\n\n{% endspoiler %}\n\n### P9779 [HUSTFC 2023] 不定项选择题 \n\n[题目链接](https://www.luogu.com.cn/problem/P9779)\n\n$n$ 道题一共有 $2^n$ 种情况，除去全都不选的情况，最坏情况是最后一次才试出来，即要试 $2^n-1$ 次。~~其实我是看样例猜出来的结论~~\n\n\n{% spoiler \"代码\" %}\n\n```cpp\n#include <bits/stdc++.h>\ntypedef long long ll;\nusing namespace std;\nconst int N=2e5+7;\n\nint main()\n{\n    int n,ans=1;\n    cin>>n;\n    for(int i=1;i<=n;++i)  ans*=2;\n    cout<<ans-1;\n    return 0;\n}\n```\n\n{% endspoiler %}\n\n### P9780 [HUSTFC 2023] Azur Lane \n\n[题目链接](https://www.luogu.com.cn/problem/P9780)\n\n先考虑怎样使天数最小，一天内放置的喵箱等级是一个不上升序列，因此将序列划分为多个不上升序列，使每个序列尽可能大，就得到了天数最小的情况。\n\n之后天数每增加一，就需要从已划分的序列中再划分出一个序列，同时使花费最少，显然天数靠前的喵箱越多花费就越多，因此我们希望喵箱尽可能放在后面，于是可以从第一天开始向后找到第一个序列长度大于 $1$ 的序列，将它划分出一个数，最后将答案加上天数增加导致前面喵箱增加的花费。时间复杂度 $O(n)$。\n\n\n{% spoiler \"代码\" %}\n\n```cpp\n#include <bits/stdc++.h>\ntypedef long long ll;\nusing namespace std;\nconst int N=1e6+7;\nint a[N];\nll b[N];\nint main()\n{\n    int m,k,tot=1;\n    ll ans=0;\n    cin>>m>>k;\n    for(int i=1;i<=m;++i)  scanf(\"%d\",&a[i]);\n    b[1]=1;\n    for(int i=2;i<=m;++i)  {\n        if(a[i]<=a[i-1])  ++b[tot];\n        else  b[++tot]=1;\n    }\n    for(int i=1;i<=tot;++i)  ans+=b[i]*(tot-i+1);\n    int now=1,totlast=0;\n    for(int i=1;i<=m;++i) {\n        if(i<tot)  {printf(\"-1 \");continue;}\n        if(i==tot) {printf(\"%lld \",ans);continue;}\n        while(b[now]==1)  ++totlast,++now;\n        --b[now];++totlast;\n        ans+=totlast;\n        printf(\"%lld \",ans);\n    }\n    return 0;\n}\n```\n\n{% endspoiler %}\n\n### P9782 [HUSTFC 2023] A+B problem \n\n[题目链接](https://www.luogu.com.cn/problem/P9782)\n\n签到题，$26$ 进制加法。\n\n\n{% spoiler \"代码\" %}\n\n```cpp\n#include <bits/stdc++.h>\ntypedef long long ll;\nusing namespace std;\nconst int N=2e5+7;\n\nint main()\n{\n    char ch1,tmp,ch2;\n    scanf(\"%c%c%c\",&ch1,&tmp,&ch2);\n\n    int k=ch1-'A'+ch2-'A';\n    if(k>=26) {\n        k-=26;cout<<'B';\n    }\n    cout<<char(k+'A');\n    return 0;\n}\n```\n\n{% endspoiler %}\n\n","source":"_posts/shi-yue-zuo-ti-ji-lu.md","raw":"---\nauthor: a154051\navatar: 'https://a154051-img-1321592229.cos.ap-beijing.myqcloud.com/img/头像new.jpg'\ntitle: 十月做题记录\ntags:\n  - 做题记录\nmathjax: true\ndate: 2023-10-24 16:10:00\ncategories: 题解\ndescription: 记录摆烂的十月\nkeywords: 十月做题记录\nphotos: https://a154051-img-1321592229.cos.ap-beijing.myqcloud.com/img/23-10-24.jpg\n---\n\n加星号表示看了题解。\n\n摆烂的十月份。\n\n## P1709 [USACO5.5] 隐藏口令 Hidden Password ＊\n\n [题目链接](https://www.luogu.com.cn/problem/P1709)\n \n最小表示法模板题，设当前比较以 $i$ 和 $j$ 开头的字符串，则对两字符串一位一位向后比较，即每次比较 $i+k$ 和 $j+k$，直到遇到不同的字符，假设 $i$ 开头的字符串更小，则令 $j$ 直接跳到 $j+k+1$，因为对于以 $j$ 到 $j+k$ 开头的字符串，都有对应的以 $i$ 到 $i+k$ 开头的字符串必它小。时间复杂度 $O( n)$。\n\n\n{% spoiler \"代码\" %}\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nconst int N=5e6+7;\nchar a[N];\nint main()\n{\n    int n;\n    cin>>n;\n    for(int i=0;i<n;++i) {\n        char ch=getchar();\n        while(ch<'a'||ch>'z')  ch=getchar();\n        a[i]=ch;\n    }\n    int i=0,j=1,k=0;\n    while(k<n&&i<n&&j<n) {\n        if(a[(i+k)%n]==a[(j+k)%n])  ++k;\n        else {\n            a[(i+k)%n]>a[(j+k)%n]?i=i+k+1:j=j+k+1;\n            if(i==j)  ++i;\n            k=0;\n        }\n    }\n    cout<<min(i,j);\n    return 0;\n}\n```\n\n{% endspoiler %}\n\n## P6310 「Wdsr-1」仓库建设 \n\n[题目链接](https://www.luogu.com.cn/problem/P6310)\n\n写过题解了，[【题解】P6310 [Wdsr-1]仓库建设](https://a154051.gitee.io/2023/09/25/solution-P6310-cang-ku-jian-she/)\n\n\n\n## 武汉大学2023年新生程序设计竞赛（同步赛）\n\n###  A. 教科书般的亵渎\n\n[题目链接](https://ac.nowcoder.com/acm/contest/66651/A)\n\n将 $a$ 从大到小排序，若第一项为 $0$ 或 $1$ 且后面每一项与前一项的差小于等于 $1$ 则为 $YES$，否则为 $NO$。\n\n{% spoiler \"代码\" %}\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nconst int N=1e6;\nint a[N];\nint main()\n{\n    int n;\n    cin>>n;\n    for(int i=1;i<=n;++i)  scanf(\"%d\",&a[i]);\n    sort(a+1,a+1+n);\n    int last=0;\n    for(int i=1;i<=n;++i) {\n        if(a[i]==last||a[i]==last+1) {last=a[i];continue;}\n        cout<<\"NO\";\n        return 0;\n    }\n    cout<<\"YES\";\n    return 0;\n}\n```\n\n{% endspoiler %}\n\n### C. 覆叶之交\n\n[题目链接](https://ac.nowcoder.com/acm/contest/66651/C)\n\n给定三个矩形，求它们的面积并。\n\n用容斥写，难点在代码实现。\n\n{% spoiler \"代码\" %}\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nstruct squ {\n    bool flag;\n    ll x1,x2,y1,y2;\n}a[20];\nint tot=3,tmp[10];\n\nvoid sol(squ A,squ B)\n{\n    ++tot;\n    if(A.flag||B.flag) {a[tot].flag=1;return ;}\n    if(A.x2<=B.x1||B.x2<=A.x1||A.y2<=B.y1||B.y2<=A.y1)  {a[tot].flag=1;return ;}\n    tmp[1]=A.x1;tmp[2]=A.x2;tmp[3]=B.x1;tmp[4]=B.x2;\n    sort(tmp+1,tmp+5);\n    a[tot].x2=tmp[3];a[tot].x1=tmp[2];\n\n    tmp[1]=A.y1;tmp[2]=A.y2;tmp[3]=B.y1;tmp[4]=B.y2;\n    sort(tmp+1,tmp+5);\n    a[tot].y1=tmp[2];a[tot].y2=tmp[3];\n}\nint main()\n{\n    ll ans=0;\n    for(int i=1;i<=3;++i) {\n        cin>>a[i].x1>>a[i].y1>>a[i].x2>>a[i].y2;\n        ans+=abs((a[i].x1-a[i].x2)*(a[i].y1-a[i].y2));\n    }\n    for(int i=1;i<=3;++i)\n        for(int j=i+1;j<=3;++j) {\n            sol(a[i],a[j]);\n            if(a[tot].flag==0)  ans-=abs((a[tot].x1-a[tot].x2)*(a[tot].y1-a[tot].y2));\n        }\n    sol(a[4],a[5]);sol(a[6],a[7]);\n    if(a[tot].flag==0)  ans+=abs((a[tot].x1-a[tot].x2)*(a[tot].y1-a[tot].y2));\n    cout<<ans;\n    return 0;\n}\n```\n\n{% endspoiler %}\n\n### E. 不是n皇后问题\n\n[题目链接](https://ac.nowcoder.com/acm/contest/66651/E)\n\n看着挺麻烦，实际上就是把 $1$ 到 $n^2$ 按顺序填进格子就行了。\n\n{% spoiler \"代码\" %}\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nconst int N=1e6;\nint main()\n{\n    int n,cnt=0;\n    cin>>n;\n    for(int i=1;i<=n;++i) {\n        for(int j=1;j<=n;++j)  printf(\"%d \",++cnt);\n        printf(\"\\n\");\n    }\n        \n\n    return 0;\n}\n```\n\n{% endspoiler %}\n\n### J. 放棋子\n\n[题目链接](https://ac.nowcoder.com/acm/contest/66651/J)\n\n行和列可以分开计算，对于同一行，要使分数最大，则每次落子需要相连的旗子尽可能多，因此可以从左至右依次落子，这样就可以得到这一行的最大分数。可以证明，如果从第一行到最后一行操作也可以得到列的最大分数。时间复杂度 $O(n\\times m)$。\n\n{% spoiler \"代码\" %}\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=1e5+7;\nvector<int> a[N];\nint main()\n{\n    int n,m;\n    ll ans=0;\n    cin>>n>>m;\n    for(int i=1;i<=n;++i) {\n        a[i].push_back(0);\n        ll now=0;\n        for(int j=1;j<=m;++j) {\n            char ch=getchar();\n            while(ch!='#'&&ch!='.')  ch=getchar();\n            a[i].push_back(0);\n            if(ch=='#') {\n                a[i][j]=1;\n                ++now;\n                ans+=now*now;\n            } \n            else  now=0;\n        }\n    }\n    for(int i=1;i<=m;++i) {\n        ll now=0;\n        for(int j=1;j<=n;++j) {\n            if(a[j][i])  ++now,ans+=now*now;\n            else  now=0;\n        }\n    }\n    cout<<ans;\n    return 0;\n}\n```\n\n{% endspoiler %}\n\n### K. 矩形分割\n\n[题目链接](https://ac.nowcoder.com/acm/contest/66651/K)\n\n显然我们想要分割出来的正方形边长尽可能大，所以以矩形的短边为正方形边长进行分割直到无法分割，如果还剩下来一个小矩形，就再对这个矩形进行上述操作，直到分割完全。\n\n\n{% spoiler \"代码\" %}\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nint sol(int n,int m)\n{\n    if(n==0||m==0)  return 0;\n    if(n==m)  return n;\n    if(n<m)  swap(n,m);\n    return m*(n/m)+sol(m,n%m);\n\n}\nint main()\n{\n    int n,m;\n    cin>>n>>m;\n    cout<<sol(n,m);\n    return 0;\n}\n```\n\n{% endspoiler %}\n\n### L. 小镜的数学题\n\n[题目链接](https://ac.nowcoder.com/acm/contest/66651/L)\n\n从 $x$ 向后暴力找，最坏也不会超过 $2x$，数据比较水就过了。\n\n{% spoiler \"代码\" %}\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nint main()\n{\n    ll n;\n    cin>>n;\n    for(ll i=n+1;;++i) {\n        if((n&i)==0) {\n            cout<<i;\n            return 0;\n        }\n        n=(n&i);\n    }\n    return 0;\n}\n```\n\n{% endspoiler %}\n\n## P2017 [USACO09DEC] Dizzy Cows G \n\n[题目链接](https://www.luogu.com.cn/problem/P2017)\n\n给定一个图，有无向边和有向边，给每条无向边指定一个方向，并且不出现环。\n\n考虑拓扑排序判定有向无环图的过程，每次删去出度为 $0$ 的点，若最终能删完则为有向无环图，可以发现，每条边都是由拓扑序大的指向拓扑序小的。因此在本题中先无视无向边对原图进行拓扑排序，再让无向边由拓扑序大的点指向拓扑序小的点，就得到了有向无环图。\n\n{% spoiler \"代码\" %}\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nconst int N=1e5+7;\nvector<int> last[N];\nint deg[N],dep[N],cnt=0;\ndeque<int> q;\nint main()\n{\n    int n,m1,m2;\n    cin>>n>>m1>>m2;\n    for(int i=1;i<=m1;++i) {\n        int x,y;\n        scanf(\"%d%d\",&x,&y);\n        ++deg[x];\n        last[y].push_back(x);\n    }\n    for(int i=1;i<=n;++i)\n        if(!deg[i])  q.push_back(i);\n    while(q.size()) {\n        int x=q.front();\n        q.pop_front();\n        dep[x]=++cnt;\n        for(int i=0;i<last[x].size();++i) \n            if((--deg[last[x][i]])==0)  q.push_back(last[x][i]);\n        \n    }\n    while(m2--) {\n        int x,y;\n        scanf(\"%d%d\",&x,&y);\n        if(dep[x]<dep[y])  swap(x,y);\n        printf(\"%d %d\\n\",x,y);\n    }\n    return 0;\n}\n```\n\n{% endspoiler %}\n\n## 2023 年华中科技大学程序设计竞赛新生赛（线上同步赛）\n\n几乎每道题都会犯sb错误，我是超级罚时王。\n\n### P9769 [HUSTFC 2023] 简单的加法乘法计算题 \n\n[题目链接](https://www.luogu.com.cn/problem/P9769)\n\n设 $f_i$ 表示从 $0$ 到 $i$ 的最小操作次数，考虑最后一次操作，要么是加上 $A$  中的一个数，要么是乘上 $B$ 中的一个数，所以 $f_i=\\min\\{ \\min\\limits_{j=1}^n f_{i-A_j},\\min\\limits_{k=1}^m f_{i/B_k}\\}$，加法用堆来维护，乘法一个个枚举，时间复杂度 $O(ym\\log n)$，如果用单调队列可以降到 $O(ym)$。\n\n\n{% spoiler \"代码\" %}\n\n```cpp\n#include <bits/stdc++.h>\n#define mp(x,y) make_pair(x,y)\ntypedef long long ll;\nusing namespace std;\nconst int N=5e6+7;\nint f[N],b[20];\npriority_queue<pair<int,int> > q;\nbool vis[N];\nint main()\n{\n    int x,n,m;\n    cin>>x>>n>>m;\n    for(int i=1;i<=m;++i)  scanf(\"%d\",&b[i]);\n    vis[0]=1;q.push(mp(0,0));\n    for(int i=1;i<=x;++i) {\n        int tmp=q.top().second;\n        while(!vis[tmp])  q.pop(),tmp=q.top().second;\n        f[i]=f[tmp]+1;\n        for(int j=1;j<=m;++j)\n            if(i%b[j]==0)  f[i]=min(f[i],f[i/b[j]]+1);\n        q.push(mp(-f[i],i));\n        vis[i]=1;\n        if(i-n-1>=0)  vis[i-n-1]=0;\n    }\n    cout<<f[x];\n    return 0;\n}\n```\n\n{% endspoiler %}\n\n### P9771  [HUSTFC 2023] 排列排序问题 \n\n[题目链接](https://www.luogu.com.cn/problem/P9771)\n\n显然切割出来的序列是单调的，并且相邻的两个数相差 $1$，按这个方法切割使每个切出来的序列尽可能大就行了。时间复杂度 $O(n)$。\n\n\n\n{% spoiler \"代码\" %}\n\n```cpp\n#include <bits/stdc++.h>\ntypedef long long ll;\nusing namespace std;\nconst int N=1e6+7;\nint a[N];\nint main()\n{\n    int n;\n    cin>>n;\n    for(int i=1;i<=n;++i)  scanf(\"%d\",&a[i]);\n    int flag=-1,last=a[1],ans=0;\n    for(int i=2;i<=n;++i) {\n        if(flag==-1) {\n            if(a[i]==last+1)  flag=1,last=a[i];\n            else  if(a[i]==last-1)  flag=0,last=a[i];\n            else  last=a[i],++ans;\n            continue;\n        }\n        if(a[i]==last+1&&flag==1) {last=a[i];continue;}\n        if(a[i]==last-1&&flag==0) {last=a[i];continue;}\n        last=a[i];++ans;\n        flag=-1;\n    }\n    cout<<ans;\n    return 0;\n}\n```\n\n{% endspoiler %}\n\n### P9774[HUSTFC 2023] 新取模运算 \n\n[题目链接](https://www.luogu.com.cn/problem/P9774)\n\n显然新定义的运算符满足分配律，于是对于 $n$ 到 $1$ 这 $n$ 个数，可以分为是 $p$ 的倍数和不是 $p$ 的倍数分别计算，最后再相乘。\n\n对于不是 $p$ 的倍数的数，它们对 $p$ 进行新定义运算等价于直接对 $p$ 取模，这一部分可以通过预处理 $1$ 到 $p$ 的阶乘来求解。\n\n对于是 $p$ 的倍数的数，例如 $p,2p,3p...kp$，它们对 $p$ 进行新定义运算需要先除以 $p$，变为 $1,2,3...k$，这就成了原问题的子问题，于是可以递归求解，边界是 $ k<p$。时间复杂度 $O(\\log_p n \\times \\log n)$。\n\n\n{% spoiler \"代码\" %}\n\n```cpp\n#include <bits/stdc++.h>\ntypedef long long ll;\nusing namespace std;\nconst int N=1e6+7;\nint p;\nll jc[N];\nll qpow(ll x,ll k)\n{;\n    ll ans=1,tmp=x;\n    while(k) {\n        if(k&1)  ans=ans*tmp%p;\n        tmp=tmp*tmp%p;\n        k>>=1;\n    }\n    return ans;\n}\nll sol(ll n)\n{\n    ll tmp=n/p;\n    ll ans=qpow(jc[p-1],tmp)*jc[n%p]%p;\n    if(tmp)  ans=ans*sol(tmp)%p;\n    return ans;\n}\nint main()\n{\n    int T;\n    cin>>T>>p;\n    jc[0]=1;\n    for(int i=1;i<=p;++i)  jc[i]=jc[i-1]*i%p;\n    while(T--) {\n        ll n;\n        scanf(\"%lld\",&n);\n        printf(\"%lld\\n\",sol(n));\n    }\n    return 0;\n}\n```\n\n{% endspoiler %}\n\n### P9775 [HUSTFC 2023] 广义线段树 \n\n[题目链接](https://www.luogu.com.cn/problem/P9775)\n\n给定一棵 $2n-1$ 个节点的树，$1$ 是根节点，$n$ 到 $2n-1$ 是叶子节点，给定叶子节点的点权，其他节点的点权是以它为子树的所有叶子节点的乘积。令每个叶子节点乘上一个数，求最后所有节点的和。\n\n对叶子节点乘上一个数，则从叶子节点到根节点路径上所有节点都要乘上这个数。所以原问题转化为对树上的一条链乘上一个数，可以用树链剖分，时间复杂度 $O(n\\log^2 n)$。比赛时没细想，但实际上可以先对所有叶子节点做修改，再在 dfs 返回时向上传就可以了，时间复杂度 $O(n)$。\n\n\n{% spoiler \"代码\" %}\n\n```cpp\n#include <bits/stdc++.h>\ntypedef long long ll;\nusing namespace std;\nconst int N=2e6+7,mod=998244353;\nstruct tree {\n    ll tag,val;\n}tr[N<<1];\nll a[N],b[N];\nint nx[N][2],fa[N],dep[N],siz[N],top[N],pos[N],son[N],tot=0,rev[N];\nvoid push(int now,ll k)\n{\n    tr[now].val=tr[now].val*k%mod;\n    tr[now].tag=tr[now].tag*k%mod;\n    return ;\n}\nvoid build(int now,int l,int r)\n{\n    tr[now].tag=1;\n    if(l==r) {tr[now].val=a[rev[l]];return ;}\n    int mid=(l+r)>>1;\n    build(now<<1,l,mid);\n    build(now<<1|1,mid+1,r);\n    tr[now].val=(tr[now<<1].val+tr[now<<1|1].val)%mod;\n}\nvoid mul(int now,int l,int r,int x,int y,ll k)\n{\n    if(l>=x&&r<=y) {\n        tr[now].val=tr[now].val*k%mod;\n        tr[now].tag=tr[now].tag*k%mod;\n        return ;\n    }\n    if(tr[now].tag!=1) {\n        push(now<<1,tr[now].tag);\n        push(now<<1|1,tr[now].tag);\n        tr[now].tag=1;\n    }\n    \n    int mid=(l+r)>>1;\n    if(x<=mid)  mul(now<<1,l,mid,x,y,k);\n    if(y>mid)  mul(now<<1|1,mid+1,r,x,y,k);\n    tr[now].val=(tr[now<<1].val+tr[now<<1|1].val)%mod;\n}\n\nvoid dfs1(int x,int FA)\n{\n    fa[x]=FA;dep[x]=dep[FA]+1;siz[x]=1;\n    if(nx[x][0]) {\n        dfs1(nx[x][0],x);dfs1(nx[x][1],x);\n        siz[x]+=siz[nx[x][0]]+siz[nx[x][1]];\n        son[x]=siz[nx[x][0]]>siz[nx[x][1]]?nx[x][0]:nx[x][1];\n        a[x]=a[nx[x][0]]*a[nx[x][1]]%mod;\n    }\n}\nvoid dfs2(int x,int tp)\n{\n    top[x]=tp;pos[x]=++tot;rev[tot]=x;\n    if(!son[x])  return ;\n    dfs2(son[x],tp);\n    int tmp=nx[x][0];\n    if(tmp==son[x])  tmp=nx[x][1];\n    dfs2(tmp,tmp);\n}\nvoid chg(int x,ll k)\n{\n    if(k==1)  return ;\n    while(x) {\n        mul(1,1,tot,pos[top[x]],pos[x],k);\n        x=fa[top[x]];\n    }\n}\nint main()\n{\n    int n;\n    cin>>n;\n    for(int i=n;i<=n*2-1;++i)  scanf(\"%lld\",&a[i]);\n    for(int i=1;i<=n;++i)  scanf(\"%lld\",&b[i]);\n    for(int i=1;i<n;++i)  scanf(\"%d%d\",&nx[i][0],&nx[i][1]);\n    dfs1(1,0);\n    dfs2(1,1);\n    build(1,1,tot);\n    for(int i=1;i<=n;++i) {\n        chg(i+n-1,b[i]);\n        printf(\"%lld \",tr[1].val);\n    }\n    return 0;\n}\n```\n\n{% endspoiler %}\n\n### P9777 [HUSTFC 2023] Fujisaki 讨厌数学 \n\n[题目链接](https://www.luogu.com.cn/problem/P9777)\n\n已知 $x^1+x^{-1}=k$，求 $x^n+x^{-n}$。\n\n可以发现 $(x^a+x^{-a})(x^b+x^{-b})=x^{a+b}+x^{-(a+b)}+x^{(a-b)}+x^{-(a-b)}$。设 $f_n=x^n+x^{-n}$，可以得到 $f_{(a+b)}=f_a \\times f_b-f_{(a-b)}$。因此，若 $n$ 是偶数，有 $f_n=f_{n/2}^2-f_0$，若 $n$ 是奇数，有 $f_n=f_{n/2}\\times f_{n/2+1}-f_1$。\n\n设 $n$ 在第一层，向下拆分得到第二层，第二层要么有一个数要么有两个数，考虑两个数的情况，这两个数一定相差 $1$，将它们向下拆分，第三层仍然是两个数，并且也是相差 $1$，可以证明每一层都至多两个数。每次拆分都除以 $2$，因此有 $\\log n$ 层。可以用记忆化搜索，但是 $n$ 太大了，要用 $map$ 存，时间复杂度 $O(\\log^2 n)$。\n\n\n{% spoiler \"代码\" %}\n\n```cpp\n#include <bits/stdc++.h>\ntypedef long long ll;\nusing namespace std;\nmap<ll,ll> mp;\nconst int N=1e6+7;\nint mod;\nll k;\nll sol(ll n)\n{\n    if(n==1)  return k;\n    if(mp.find(n)!=mp.end())  return mp[n];\n    ll ans=1;\n    if(n&1)  ans=sol(n/2)*sol(n/2+1)%mod-k;\n    else  ans=sol(n/2),ans=ans*ans%mod-2;\n    while(ans<0)  ans+=mod;\n    mp[n]=ans;\n    return ans;\n}\nint main()\n{\n    ll n;\n    cin>>mod>>k>>n;\n    if(n==0)  cout<<\"2\";\n    else  printf(\"%lld\",sol(n));\n\n    return 0;\n}\n```\n\n{% endspoiler %}\n\n### P9779 [HUSTFC 2023] 不定项选择题 \n\n[题目链接](https://www.luogu.com.cn/problem/P9779)\n\n$n$ 道题一共有 $2^n$ 种情况，除去全都不选的情况，最坏情况是最后一次才试出来，即要试 $2^n-1$ 次。~~其实我是看样例猜出来的结论~~\n\n\n{% spoiler \"代码\" %}\n\n```cpp\n#include <bits/stdc++.h>\ntypedef long long ll;\nusing namespace std;\nconst int N=2e5+7;\n\nint main()\n{\n    int n,ans=1;\n    cin>>n;\n    for(int i=1;i<=n;++i)  ans*=2;\n    cout<<ans-1;\n    return 0;\n}\n```\n\n{% endspoiler %}\n\n### P9780 [HUSTFC 2023] Azur Lane \n\n[题目链接](https://www.luogu.com.cn/problem/P9780)\n\n先考虑怎样使天数最小，一天内放置的喵箱等级是一个不上升序列，因此将序列划分为多个不上升序列，使每个序列尽可能大，就得到了天数最小的情况。\n\n之后天数每增加一，就需要从已划分的序列中再划分出一个序列，同时使花费最少，显然天数靠前的喵箱越多花费就越多，因此我们希望喵箱尽可能放在后面，于是可以从第一天开始向后找到第一个序列长度大于 $1$ 的序列，将它划分出一个数，最后将答案加上天数增加导致前面喵箱增加的花费。时间复杂度 $O(n)$。\n\n\n{% spoiler \"代码\" %}\n\n```cpp\n#include <bits/stdc++.h>\ntypedef long long ll;\nusing namespace std;\nconst int N=1e6+7;\nint a[N];\nll b[N];\nint main()\n{\n    int m,k,tot=1;\n    ll ans=0;\n    cin>>m>>k;\n    for(int i=1;i<=m;++i)  scanf(\"%d\",&a[i]);\n    b[1]=1;\n    for(int i=2;i<=m;++i)  {\n        if(a[i]<=a[i-1])  ++b[tot];\n        else  b[++tot]=1;\n    }\n    for(int i=1;i<=tot;++i)  ans+=b[i]*(tot-i+1);\n    int now=1,totlast=0;\n    for(int i=1;i<=m;++i) {\n        if(i<tot)  {printf(\"-1 \");continue;}\n        if(i==tot) {printf(\"%lld \",ans);continue;}\n        while(b[now]==1)  ++totlast,++now;\n        --b[now];++totlast;\n        ans+=totlast;\n        printf(\"%lld \",ans);\n    }\n    return 0;\n}\n```\n\n{% endspoiler %}\n\n### P9782 [HUSTFC 2023] A+B problem \n\n[题目链接](https://www.luogu.com.cn/problem/P9782)\n\n签到题，$26$ 进制加法。\n\n\n{% spoiler \"代码\" %}\n\n```cpp\n#include <bits/stdc++.h>\ntypedef long long ll;\nusing namespace std;\nconst int N=2e5+7;\n\nint main()\n{\n    char ch1,tmp,ch2;\n    scanf(\"%c%c%c\",&ch1,&tmp,&ch2);\n\n    int k=ch1-'A'+ch2-'A';\n    if(k>=26) {\n        k-=26;cout<<'B';\n    }\n    cout<<char(k+'A');\n    return 0;\n}\n```\n\n{% endspoiler %}\n\n","slug":"shi-yue-zuo-ti-ji-lu","published":1,"updated":"2023-10-24T10:01:10.273Z","comments":1,"layout":"post","link":"","_id":"cloo2ivvh0001r8v3682obepe","content":"<p>加星号表示看了题解。</p>\n<p>摆烂的十月份。</p>\n<h2 id=\"P1709-USACO5-5-隐藏口令-Hidden-Password-＊\"><a href=\"#P1709-USACO5-5-隐藏口令-Hidden-Password-＊\" class=\"headerlink\" title=\"P1709 [USACO5.5] 隐藏口令 Hidden Password ＊\"></a>P1709 [USACO5.5] 隐藏口令 Hidden Password ＊</h2><p> <a href=\"https://www.luogu.com.cn/problem/P1709\">题目链接</a></p>\n<p>最小表示法模板题，设当前比较以 $i$ 和 $j$ 开头的字符串，则对两字符串一位一位向后比较，即每次比较 $i+k$ 和 $j+k$，直到遇到不同的字符，假设 $i$ 开头的字符串更小，则令 $j$ 直接跳到 $j+k+1$，因为对于以 $j$ 到 $j+k$ 开头的字符串，都有对应的以 $i$ 到 $i+k$ 开头的字符串必它小。时间复杂度 $O( n)$。</p>\n<div class='spoiler collapsed'>\n    \n    <div class='spoiler-title'>\n        代码\n    </div>\n    <div class='spoiler-content'>\n        <pre><code class=\"lang-cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N=5e6+7;\nchar a[N];\nint main()\n{\n    int n;\n    cin&gt;&gt;n;\n    for(int i=0;i&lt;n;++i) {\n        char ch=getchar();\n        while(ch&lt;&#39;a&#39;||ch&gt;&#39;z&#39;)  ch=getchar();\n        a[i]=ch;\n    }\n    int i=0,j=1,k=0;\n    while(k&lt;n&amp;&amp;i&lt;n&amp;&amp;j&lt;n) {\n        if(a[(i+k)%n]==a[(j+k)%n])  ++k;\n        else {\n            a[(i+k)%n]&gt;a[(j+k)%n]?i=i+k+1:j=j+k+1;\n            if(i==j)  ++i;\n            k=0;\n        }\n    }\n    cout&lt;&lt;min(i,j);\n    return 0;\n}\n</code></pre>\n\n    </div>\n</div>\n<h2 id=\"P6310-「Wdsr-1」仓库建设\"><a href=\"#P6310-「Wdsr-1」仓库建设\" class=\"headerlink\" title=\"P6310 「Wdsr-1」仓库建设\"></a>P6310 「Wdsr-1」仓库建设</h2><p><a href=\"https://www.luogu.com.cn/problem/P6310\">题目链接</a></p>\n<p>写过题解了，<a href=\"https://a154051.gitee.io/2023/09/25/solution-P6310-cang-ku-jian-she/\">【题解】P6310 [Wdsr-1]仓库建设</a></p>\n<h2 id=\"武汉大学2023年新生程序设计竞赛（同步赛）\"><a href=\"#武汉大学2023年新生程序设计竞赛（同步赛）\" class=\"headerlink\" title=\"武汉大学2023年新生程序设计竞赛（同步赛）\"></a>武汉大学2023年新生程序设计竞赛（同步赛）</h2><h3 id=\"A-教科书般的亵渎\"><a href=\"#A-教科书般的亵渎\" class=\"headerlink\" title=\"A. 教科书般的亵渎\"></a>A. 教科书般的亵渎</h3><p><a href=\"https://ac.nowcoder.com/acm/contest/66651/A\">题目链接</a></p>\n<p>将 $a$ 从大到小排序，若第一项为 $0$ 或 $1$ 且后面每一项与前一项的差小于等于 $1$ 则为 $YES$，否则为 $NO$。</p>\n<div class='spoiler collapsed'>\n    \n    <div class='spoiler-title'>\n        代码\n    </div>\n    <div class='spoiler-content'>\n        <pre><code class=\"lang-cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N=1e6;\nint a[N];\nint main()\n{\n    int n;\n    cin&gt;&gt;n;\n    for(int i=1;i&lt;=n;++i)  scanf(&quot;%d&quot;,&amp;a[i]);\n    sort(a+1,a+1+n);\n    int last=0;\n    for(int i=1;i&lt;=n;++i) {\n        if(a[i]==last||a[i]==last+1) {last=a[i];continue;}\n        cout&lt;&lt;&quot;NO&quot;;\n        return 0;\n    }\n    cout&lt;&lt;&quot;YES&quot;;\n    return 0;\n}\n</code></pre>\n\n    </div>\n</div>\n<h3 id=\"C-覆叶之交\"><a href=\"#C-覆叶之交\" class=\"headerlink\" title=\"C. 覆叶之交\"></a>C. 覆叶之交</h3><p><a href=\"https://ac.nowcoder.com/acm/contest/66651/C\">题目链接</a></p>\n<p>给定三个矩形，求它们的面积并。</p>\n<p>用容斥写，难点在代码实现。</p>\n<div class='spoiler collapsed'>\n    \n    <div class='spoiler-title'>\n        代码\n    </div>\n    <div class='spoiler-content'>\n        <pre><code class=\"lang-cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\nstruct squ {\n    bool flag;\n    ll x1,x2,y1,y2;\n}a[20];\nint tot=3,tmp[10];\n\nvoid sol(squ A,squ B)\n{\n    ++tot;\n    if(A.flag||B.flag) {a[tot].flag=1;return ;}\n    if(A.x2&lt;=B.x1||B.x2&lt;=A.x1||A.y2&lt;=B.y1||B.y2&lt;=A.y1)  {a[tot].flag=1;return ;}\n    tmp[1]=A.x1;tmp[2]=A.x2;tmp[3]=B.x1;tmp[4]=B.x2;\n    sort(tmp+1,tmp+5);\n    a[tot].x2=tmp[3];a[tot].x1=tmp[2];\n\n    tmp[1]=A.y1;tmp[2]=A.y2;tmp[3]=B.y1;tmp[4]=B.y2;\n    sort(tmp+1,tmp+5);\n    a[tot].y1=tmp[2];a[tot].y2=tmp[3];\n}\nint main()\n{\n    ll ans=0;\n    for(int i=1;i&lt;=3;++i) {\n        cin&gt;&gt;a[i].x1&gt;&gt;a[i].y1&gt;&gt;a[i].x2&gt;&gt;a[i].y2;\n        ans+=abs((a[i].x1-a[i].x2)*(a[i].y1-a[i].y2));\n    }\n    for(int i=1;i&lt;=3;++i)\n        for(int j=i+1;j&lt;=3;++j) {\n            sol(a[i],a[j]);\n            if(a[tot].flag==0)  ans-=abs((a[tot].x1-a[tot].x2)*(a[tot].y1-a[tot].y2));\n        }\n    sol(a[4],a[5]);sol(a[6],a[7]);\n    if(a[tot].flag==0)  ans+=abs((a[tot].x1-a[tot].x2)*(a[tot].y1-a[tot].y2));\n    cout&lt;&lt;ans;\n    return 0;\n}\n</code></pre>\n\n    </div>\n</div>\n<h3 id=\"E-不是n皇后问题\"><a href=\"#E-不是n皇后问题\" class=\"headerlink\" title=\"E. 不是n皇后问题\"></a>E. 不是n皇后问题</h3><p><a href=\"https://ac.nowcoder.com/acm/contest/66651/E\">题目链接</a></p>\n<p>看着挺麻烦，实际上就是把 $1$ 到 $n^2$ 按顺序填进格子就行了。</p>\n<div class='spoiler collapsed'>\n    \n    <div class='spoiler-title'>\n        代码\n    </div>\n    <div class='spoiler-content'>\n        <pre><code class=\"lang-cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N=1e6;\nint main()\n{\n    int n,cnt=0;\n    cin&gt;&gt;n;\n    for(int i=1;i&lt;=n;++i) {\n        for(int j=1;j&lt;=n;++j)  printf(&quot;%d &quot;,++cnt);\n        printf(&quot;\\n&quot;);\n    }\n\n\n    return 0;\n}\n</code></pre>\n\n    </div>\n</div>\n<h3 id=\"J-放棋子\"><a href=\"#J-放棋子\" class=\"headerlink\" title=\"J. 放棋子\"></a>J. 放棋子</h3><p><a href=\"https://ac.nowcoder.com/acm/contest/66651/J\">题目链接</a></p>\n<p>行和列可以分开计算，对于同一行，要使分数最大，则每次落子需要相连的旗子尽可能多，因此可以从左至右依次落子，这样就可以得到这一行的最大分数。可以证明，如果从第一行到最后一行操作也可以得到列的最大分数。时间复杂度 $O(n\\times m)$。</p>\n<div class='spoiler collapsed'>\n    \n    <div class='spoiler-title'>\n        代码\n    </div>\n    <div class='spoiler-content'>\n        <pre><code class=\"lang-cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\nconst int N=1e5+7;\nvector&lt;int&gt; a[N];\nint main()\n{\n    int n,m;\n    ll ans=0;\n    cin&gt;&gt;n&gt;&gt;m;\n    for(int i=1;i&lt;=n;++i) {\n        a[i].push_back(0);\n        ll now=0;\n        for(int j=1;j&lt;=m;++j) {\n            char ch=getchar();\n            while(ch!=&#39;#&#39;&amp;&amp;ch!=&#39;.&#39;)  ch=getchar();\n            a[i].push_back(0);\n            if(ch==&#39;#&#39;) {\n                a[i][j]=1;\n                ++now;\n                ans+=now*now;\n            } \n            else  now=0;\n        }\n    }\n    for(int i=1;i&lt;=m;++i) {\n        ll now=0;\n        for(int j=1;j&lt;=n;++j) {\n            if(a[j][i])  ++now,ans+=now*now;\n            else  now=0;\n        }\n    }\n    cout&lt;&lt;ans;\n    return 0;\n}\n</code></pre>\n\n    </div>\n</div>\n<h3 id=\"K-矩形分割\"><a href=\"#K-矩形分割\" class=\"headerlink\" title=\"K. 矩形分割\"></a>K. 矩形分割</h3><p><a href=\"https://ac.nowcoder.com/acm/contest/66651/K\">题目链接</a></p>\n<p>显然我们想要分割出来的正方形边长尽可能大，所以以矩形的短边为正方形边长进行分割直到无法分割，如果还剩下来一个小矩形，就再对这个矩形进行上述操作，直到分割完全。</p>\n<div class='spoiler collapsed'>\n    \n    <div class='spoiler-title'>\n        代码\n    </div>\n    <div class='spoiler-content'>\n        <pre><code class=\"lang-cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\nint sol(int n,int m)\n{\n    if(n==0||m==0)  return 0;\n    if(n==m)  return n;\n    if(n&lt;m)  swap(n,m);\n    return m*(n/m)+sol(m,n%m);\n\n}\nint main()\n{\n    int n,m;\n    cin&gt;&gt;n&gt;&gt;m;\n    cout&lt;&lt;sol(n,m);\n    return 0;\n}\n</code></pre>\n\n    </div>\n</div>\n<h3 id=\"L-小镜的数学题\"><a href=\"#L-小镜的数学题\" class=\"headerlink\" title=\"L. 小镜的数学题\"></a>L. 小镜的数学题</h3><p><a href=\"https://ac.nowcoder.com/acm/contest/66651/L\">题目链接</a></p>\n<p>从 $x$ 向后暴力找，最坏也不会超过 $2x$，数据比较水就过了。</p>\n<div class='spoiler collapsed'>\n    \n    <div class='spoiler-title'>\n        代码\n    </div>\n    <div class='spoiler-content'>\n        <pre><code class=\"lang-cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\nint main()\n{\n    ll n;\n    cin&gt;&gt;n;\n    for(ll i=n+1;;++i) {\n        if((n&amp;i)==0) {\n            cout&lt;&lt;i;\n            return 0;\n        }\n        n=(n&amp;i);\n    }\n    return 0;\n}\n</code></pre>\n\n    </div>\n</div>\n<h2 id=\"P2017-USACO09DEC-Dizzy-Cows-G\"><a href=\"#P2017-USACO09DEC-Dizzy-Cows-G\" class=\"headerlink\" title=\"P2017 [USACO09DEC] Dizzy Cows G\"></a>P2017 [USACO09DEC] Dizzy Cows G</h2><p><a href=\"https://www.luogu.com.cn/problem/P2017\">题目链接</a></p>\n<p>给定一个图，有无向边和有向边，给每条无向边指定一个方向，并且不出现环。</p>\n<p>考虑拓扑排序判定有向无环图的过程，每次删去出度为 $0$ 的点，若最终能删完则为有向无环图，可以发现，每条边都是由拓扑序大的指向拓扑序小的。因此在本题中先无视无向边对原图进行拓扑排序，再让无向边由拓扑序大的点指向拓扑序小的点，就得到了有向无环图。</p>\n<div class='spoiler collapsed'>\n    \n    <div class='spoiler-title'>\n        代码\n    </div>\n    <div class='spoiler-content'>\n        <pre><code class=\"lang-cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N=1e5+7;\nvector&lt;int&gt; last[N];\nint deg[N],dep[N],cnt=0;\ndeque&lt;int&gt; q;\nint main()\n{\n    int n,m1,m2;\n    cin&gt;&gt;n&gt;&gt;m1&gt;&gt;m2;\n    for(int i=1;i&lt;=m1;++i) {\n        int x,y;\n        scanf(&quot;%d%d&quot;,&amp;x,&amp;y);\n        ++deg[x];\n        last[y].push_back(x);\n    }\n    for(int i=1;i&lt;=n;++i)\n        if(!deg[i])  q.push_back(i);\n    while(q.size()) {\n        int x=q.front();\n        q.pop_front();\n        dep[x]=++cnt;\n        for(int i=0;i&lt;last[x].size();++i) \n            if((--deg[last[x][i]])==0)  q.push_back(last[x][i]);\n\n    }\n    while(m2--) {\n        int x,y;\n        scanf(&quot;%d%d&quot;,&amp;x,&amp;y);\n        if(dep[x]&lt;dep[y])  swap(x,y);\n        printf(&quot;%d %d\\n&quot;,x,y);\n    }\n    return 0;\n}\n</code></pre>\n\n    </div>\n</div>\n<h2 id=\"2023-年华中科技大学程序设计竞赛新生赛（线上同步赛）\"><a href=\"#2023-年华中科技大学程序设计竞赛新生赛（线上同步赛）\" class=\"headerlink\" title=\"2023 年华中科技大学程序设计竞赛新生赛（线上同步赛）\"></a>2023 年华中科技大学程序设计竞赛新生赛（线上同步赛）</h2><p>几乎每道题都会犯sb错误，我是超级罚时王。</p>\n<h3 id=\"P9769-HUSTFC-2023-简单的加法乘法计算题\"><a href=\"#P9769-HUSTFC-2023-简单的加法乘法计算题\" class=\"headerlink\" title=\"P9769 [HUSTFC 2023] 简单的加法乘法计算题\"></a>P9769 [HUSTFC 2023] 简单的加法乘法计算题</h3><p><a href=\"https://www.luogu.com.cn/problem/P9769\">题目链接</a></p>\n<p>设 $f_i$ 表示从 $0$ 到 $i$ 的最小操作次数，考虑最后一次操作，要么是加上 $A$  中的一个数，要么是乘上 $B$ 中的一个数，所以 $f_i=\\min\\{ \\min\\limits_{j=1}^n f_{i-A_j},\\min\\limits_{k=1}^m f_{i/B_k}\\}$，加法用堆来维护，乘法一个个枚举，时间复杂度 $O(ym\\log n)$，如果用单调队列可以降到 $O(ym)$。</p>\n<div class='spoiler collapsed'>\n    \n    <div class='spoiler-title'>\n        代码\n    </div>\n    <div class='spoiler-content'>\n        <pre><code class=\"lang-cpp\">#include &lt;bits/stdc++.h&gt;\n#define mp(x,y) make_pair(x,y)\ntypedef long long ll;\nusing namespace std;\nconst int N=5e6+7;\nint f[N],b[20];\npriority_queue&lt;pair&lt;int,int&gt; &gt; q;\nbool vis[N];\nint main()\n{\n    int x,n,m;\n    cin&gt;&gt;x&gt;&gt;n&gt;&gt;m;\n    for(int i=1;i&lt;=m;++i)  scanf(&quot;%d&quot;,&amp;b[i]);\n    vis[0]=1;q.push(mp(0,0));\n    for(int i=1;i&lt;=x;++i) {\n        int tmp=q.top().second;\n        while(!vis[tmp])  q.pop(),tmp=q.top().second;\n        f[i]=f[tmp]+1;\n        for(int j=1;j&lt;=m;++j)\n            if(i%b[j]==0)  f[i]=min(f[i],f[i/b[j]]+1);\n        q.push(mp(-f[i],i));\n        vis[i]=1;\n        if(i-n-1&gt;=0)  vis[i-n-1]=0;\n    }\n    cout&lt;&lt;f[x];\n    return 0;\n}\n</code></pre>\n\n    </div>\n</div>\n<h3 id=\"P9771-HUSTFC-2023-排列排序问题\"><a href=\"#P9771-HUSTFC-2023-排列排序问题\" class=\"headerlink\" title=\"P9771  [HUSTFC 2023] 排列排序问题\"></a>P9771  [HUSTFC 2023] 排列排序问题</h3><p><a href=\"https://www.luogu.com.cn/problem/P9771\">题目链接</a></p>\n<p>显然切割出来的序列是单调的，并且相邻的两个数相差 $1$，按这个方法切割使每个切出来的序列尽可能大就行了。时间复杂度 $O(n)$。</p>\n<div class='spoiler collapsed'>\n    \n    <div class='spoiler-title'>\n        代码\n    </div>\n    <div class='spoiler-content'>\n        <pre><code class=\"lang-cpp\">#include &lt;bits/stdc++.h&gt;\ntypedef long long ll;\nusing namespace std;\nconst int N=1e6+7;\nint a[N];\nint main()\n{\n    int n;\n    cin&gt;&gt;n;\n    for(int i=1;i&lt;=n;++i)  scanf(&quot;%d&quot;,&amp;a[i]);\n    int flag=-1,last=a[1],ans=0;\n    for(int i=2;i&lt;=n;++i) {\n        if(flag==-1) {\n            if(a[i]==last+1)  flag=1,last=a[i];\n            else  if(a[i]==last-1)  flag=0,last=a[i];\n            else  last=a[i],++ans;\n            continue;\n        }\n        if(a[i]==last+1&amp;&amp;flag==1) {last=a[i];continue;}\n        if(a[i]==last-1&amp;&amp;flag==0) {last=a[i];continue;}\n        last=a[i];++ans;\n        flag=-1;\n    }\n    cout&lt;&lt;ans;\n    return 0;\n}\n</code></pre>\n\n    </div>\n</div>\n<h3 id=\"P9774-HUSTFC-2023-新取模运算\"><a href=\"#P9774-HUSTFC-2023-新取模运算\" class=\"headerlink\" title=\"P9774[HUSTFC 2023] 新取模运算\"></a>P9774[HUSTFC 2023] 新取模运算</h3><p><a href=\"https://www.luogu.com.cn/problem/P9774\">题目链接</a></p>\n<p>显然新定义的运算符满足分配律，于是对于 $n$ 到 $1$ 这 $n$ 个数，可以分为是 $p$ 的倍数和不是 $p$ 的倍数分别计算，最后再相乘。</p>\n<p>对于不是 $p$ 的倍数的数，它们对 $p$ 进行新定义运算等价于直接对 $p$ 取模，这一部分可以通过预处理 $1$ 到 $p$ 的阶乘来求解。</p>\n<p>对于是 $p$ 的倍数的数，例如 $p,2p,3p…kp$，它们对 $p$ 进行新定义运算需要先除以 $p$，变为 $1,2,3…k$，这就成了原问题的子问题，于是可以递归求解，边界是 $ k&lt;p$。时间复杂度 $O(\\log_p n \\times \\log n)$。</p>\n<div class='spoiler collapsed'>\n    \n    <div class='spoiler-title'>\n        代码\n    </div>\n    <div class='spoiler-content'>\n        <pre><code class=\"lang-cpp\">#include &lt;bits/stdc++.h&gt;\ntypedef long long ll;\nusing namespace std;\nconst int N=1e6+7;\nint p;\nll jc[N];\nll qpow(ll x,ll k)\n{;\n    ll ans=1,tmp=x;\n    while(k) {\n        if(k&amp;1)  ans=ans*tmp%p;\n        tmp=tmp*tmp%p;\n        k&gt;&gt;=1;\n    }\n    return ans;\n}\nll sol(ll n)\n{\n    ll tmp=n/p;\n    ll ans=qpow(jc[p-1],tmp)*jc[n%p]%p;\n    if(tmp)  ans=ans*sol(tmp)%p;\n    return ans;\n}\nint main()\n{\n    int T;\n    cin&gt;&gt;T&gt;&gt;p;\n    jc[0]=1;\n    for(int i=1;i&lt;=p;++i)  jc[i]=jc[i-1]*i%p;\n    while(T--) {\n        ll n;\n        scanf(&quot;%lld&quot;,&amp;n);\n        printf(&quot;%lld\\n&quot;,sol(n));\n    }\n    return 0;\n}\n</code></pre>\n\n    </div>\n</div>\n<h3 id=\"P9775-HUSTFC-2023-广义线段树\"><a href=\"#P9775-HUSTFC-2023-广义线段树\" class=\"headerlink\" title=\"P9775 [HUSTFC 2023] 广义线段树\"></a>P9775 [HUSTFC 2023] 广义线段树</h3><p><a href=\"https://www.luogu.com.cn/problem/P9775\">题目链接</a></p>\n<p>给定一棵 $2n-1$ 个节点的树，$1$ 是根节点，$n$ 到 $2n-1$ 是叶子节点，给定叶子节点的点权，其他节点的点权是以它为子树的所有叶子节点的乘积。令每个叶子节点乘上一个数，求最后所有节点的和。</p>\n<p>对叶子节点乘上一个数，则从叶子节点到根节点路径上所有节点都要乘上这个数。所以原问题转化为对树上的一条链乘上一个数，可以用树链剖分，时间复杂度 $O(n\\log^2 n)$。比赛时没细想，但实际上可以先对所有叶子节点做修改，再在 dfs 返回时向上传就可以了，时间复杂度 $O(n)$。</p>\n<div class='spoiler collapsed'>\n    \n    <div class='spoiler-title'>\n        代码\n    </div>\n    <div class='spoiler-content'>\n        <pre><code class=\"lang-cpp\">#include &lt;bits/stdc++.h&gt;\ntypedef long long ll;\nusing namespace std;\nconst int N=2e6+7,mod=998244353;\nstruct tree {\n    ll tag,val;\n}tr[N&lt;&lt;1];\nll a[N],b[N];\nint nx[N][2],fa[N],dep[N],siz[N],top[N],pos[N],son[N],tot=0,rev[N];\nvoid push(int now,ll k)\n{\n    tr[now].val=tr[now].val*k%mod;\n    tr[now].tag=tr[now].tag*k%mod;\n    return ;\n}\nvoid build(int now,int l,int r)\n{\n    tr[now].tag=1;\n    if(l==r) {tr[now].val=a[rev[l]];return ;}\n    int mid=(l+r)&gt;&gt;1;\n    build(now&lt;&lt;1,l,mid);\n    build(now&lt;&lt;1|1,mid+1,r);\n    tr[now].val=(tr[now&lt;&lt;1].val+tr[now&lt;&lt;1|1].val)%mod;\n}\nvoid mul(int now,int l,int r,int x,int y,ll k)\n{\n    if(l&gt;=x&amp;&amp;r&lt;=y) {\n        tr[now].val=tr[now].val*k%mod;\n        tr[now].tag=tr[now].tag*k%mod;\n        return ;\n    }\n    if(tr[now].tag!=1) {\n        push(now&lt;&lt;1,tr[now].tag);\n        push(now&lt;&lt;1|1,tr[now].tag);\n        tr[now].tag=1;\n    }\n\n    int mid=(l+r)&gt;&gt;1;\n    if(x&lt;=mid)  mul(now&lt;&lt;1,l,mid,x,y,k);\n    if(y&gt;mid)  mul(now&lt;&lt;1|1,mid+1,r,x,y,k);\n    tr[now].val=(tr[now&lt;&lt;1].val+tr[now&lt;&lt;1|1].val)%mod;\n}\n\nvoid dfs1(int x,int FA)\n{\n    fa[x]=FA;dep[x]=dep[FA]+1;siz[x]=1;\n    if(nx[x][0]) {\n        dfs1(nx[x][0],x);dfs1(nx[x][1],x);\n        siz[x]+=siz[nx[x][0]]+siz[nx[x][1]];\n        son[x]=siz[nx[x][0]]&gt;siz[nx[x][1]]?nx[x][0]:nx[x][1];\n        a[x]=a[nx[x][0]]*a[nx[x][1]]%mod;\n    }\n}\nvoid dfs2(int x,int tp)\n{\n    top[x]=tp;pos[x]=++tot;rev[tot]=x;\n    if(!son[x])  return ;\n    dfs2(son[x],tp);\n    int tmp=nx[x][0];\n    if(tmp==son[x])  tmp=nx[x][1];\n    dfs2(tmp,tmp);\n}\nvoid chg(int x,ll k)\n{\n    if(k==1)  return ;\n    while(x) {\n        mul(1,1,tot,pos[top[x]],pos[x],k);\n        x=fa[top[x]];\n    }\n}\nint main()\n{\n    int n;\n    cin&gt;&gt;n;\n    for(int i=n;i&lt;=n*2-1;++i)  scanf(&quot;%lld&quot;,&amp;a[i]);\n    for(int i=1;i&lt;=n;++i)  scanf(&quot;%lld&quot;,&amp;b[i]);\n    for(int i=1;i&lt;n;++i)  scanf(&quot;%d%d&quot;,&amp;nx[i][0],&amp;nx[i][1]);\n    dfs1(1,0);\n    dfs2(1,1);\n    build(1,1,tot);\n    for(int i=1;i&lt;=n;++i) {\n        chg(i+n-1,b[i]);\n        printf(&quot;%lld &quot;,tr[1].val);\n    }\n    return 0;\n}\n</code></pre>\n\n    </div>\n</div>\n<h3 id=\"P9777-HUSTFC-2023-Fujisaki-讨厌数学\"><a href=\"#P9777-HUSTFC-2023-Fujisaki-讨厌数学\" class=\"headerlink\" title=\"P9777 [HUSTFC 2023] Fujisaki 讨厌数学\"></a>P9777 [HUSTFC 2023] Fujisaki 讨厌数学</h3><p><a href=\"https://www.luogu.com.cn/problem/P9777\">题目链接</a></p>\n<p>已知 $x^1+x^{-1}=k$，求 $x^n+x^{-n}$。</p>\n<p>可以发现 $(x^a+x^{-a})(x^b+x^{-b})=x^{a+b}+x^{-(a+b)}+x^{(a-b)}+x^{-(a-b)}$。设 $f_n=x^n+x^{-n}$，可以得到 $f_{(a+b)}=f_a \\times f_b-f_{(a-b)}$。因此，若 $n$ 是偶数，有 $f_n=f_{n/2}^2-f_0$，若 $n$ 是奇数，有 $f_n=f_{n/2}\\times f_{n/2+1}-f_1$。</p>\n<p>设 $n$ 在第一层，向下拆分得到第二层，第二层要么有一个数要么有两个数，考虑两个数的情况，这两个数一定相差 $1$，将它们向下拆分，第三层仍然是两个数，并且也是相差 $1$，可以证明每一层都至多两个数。每次拆分都除以 $2$，因此有 $\\log n$ 层。可以用记忆化搜索，但是 $n$ 太大了，要用 $map$ 存，时间复杂度 $O(\\log^2 n)$。</p>\n<div class='spoiler collapsed'>\n    \n    <div class='spoiler-title'>\n        代码\n    </div>\n    <div class='spoiler-content'>\n        <pre><code class=\"lang-cpp\">#include &lt;bits/stdc++.h&gt;\ntypedef long long ll;\nusing namespace std;\nmap&lt;ll,ll&gt; mp;\nconst int N=1e6+7;\nint mod;\nll k;\nll sol(ll n)\n{\n    if(n==1)  return k;\n    if(mp.find(n)!=mp.end())  return mp[n];\n    ll ans=1;\n    if(n&amp;1)  ans=sol(n/2)*sol(n/2+1)%mod-k;\n    else  ans=sol(n/2),ans=ans*ans%mod-2;\n    while(ans&lt;0)  ans+=mod;\n    mp[n]=ans;\n    return ans;\n}\nint main()\n{\n    ll n;\n    cin&gt;&gt;mod&gt;&gt;k&gt;&gt;n;\n    if(n==0)  cout&lt;&lt;&quot;2&quot;;\n    else  printf(&quot;%lld&quot;,sol(n));\n\n    return 0;\n}\n</code></pre>\n\n    </div>\n</div>\n<h3 id=\"P9779-HUSTFC-2023-不定项选择题\"><a href=\"#P9779-HUSTFC-2023-不定项选择题\" class=\"headerlink\" title=\"P9779 [HUSTFC 2023] 不定项选择题\"></a>P9779 [HUSTFC 2023] 不定项选择题</h3><p><a href=\"https://www.luogu.com.cn/problem/P9779\">题目链接</a></p>\n<p>$n$ 道题一共有 $2^n$ 种情况，除去全都不选的情况，最坏情况是最后一次才试出来，即要试 $2^n-1$ 次。<del>其实我是看样例猜出来的结论</del></p>\n<div class='spoiler collapsed'>\n    \n    <div class='spoiler-title'>\n        代码\n    </div>\n    <div class='spoiler-content'>\n        <pre><code class=\"lang-cpp\">#include &lt;bits/stdc++.h&gt;\ntypedef long long ll;\nusing namespace std;\nconst int N=2e5+7;\n\nint main()\n{\n    int n,ans=1;\n    cin&gt;&gt;n;\n    for(int i=1;i&lt;=n;++i)  ans*=2;\n    cout&lt;&lt;ans-1;\n    return 0;\n}\n</code></pre>\n\n    </div>\n</div>\n<h3 id=\"P9780-HUSTFC-2023-Azur-Lane\"><a href=\"#P9780-HUSTFC-2023-Azur-Lane\" class=\"headerlink\" title=\"P9780 [HUSTFC 2023] Azur Lane\"></a>P9780 [HUSTFC 2023] Azur Lane</h3><p><a href=\"https://www.luogu.com.cn/problem/P9780\">题目链接</a></p>\n<p>先考虑怎样使天数最小，一天内放置的喵箱等级是一个不上升序列，因此将序列划分为多个不上升序列，使每个序列尽可能大，就得到了天数最小的情况。</p>\n<p>之后天数每增加一，就需要从已划分的序列中再划分出一个序列，同时使花费最少，显然天数靠前的喵箱越多花费就越多，因此我们希望喵箱尽可能放在后面，于是可以从第一天开始向后找到第一个序列长度大于 $1$ 的序列，将它划分出一个数，最后将答案加上天数增加导致前面喵箱增加的花费。时间复杂度 $O(n)$。</p>\n<div class='spoiler collapsed'>\n    \n    <div class='spoiler-title'>\n        代码\n    </div>\n    <div class='spoiler-content'>\n        <pre><code class=\"lang-cpp\">#include &lt;bits/stdc++.h&gt;\ntypedef long long ll;\nusing namespace std;\nconst int N=1e6+7;\nint a[N];\nll b[N];\nint main()\n{\n    int m,k,tot=1;\n    ll ans=0;\n    cin&gt;&gt;m&gt;&gt;k;\n    for(int i=1;i&lt;=m;++i)  scanf(&quot;%d&quot;,&amp;a[i]);\n    b[1]=1;\n    for(int i=2;i&lt;=m;++i)  {\n        if(a[i]&lt;=a[i-1])  ++b[tot];\n        else  b[++tot]=1;\n    }\n    for(int i=1;i&lt;=tot;++i)  ans+=b[i]*(tot-i+1);\n    int now=1,totlast=0;\n    for(int i=1;i&lt;=m;++i) {\n        if(i&lt;tot)  {printf(&quot;-1 &quot;);continue;}\n        if(i==tot) {printf(&quot;%lld &quot;,ans);continue;}\n        while(b[now]==1)  ++totlast,++now;\n        --b[now];++totlast;\n        ans+=totlast;\n        printf(&quot;%lld &quot;,ans);\n    }\n    return 0;\n}\n</code></pre>\n\n    </div>\n</div>\n<h3 id=\"P9782-HUSTFC-2023-A-B-problem\"><a href=\"#P9782-HUSTFC-2023-A-B-problem\" class=\"headerlink\" title=\"P9782 [HUSTFC 2023] A+B problem\"></a>P9782 [HUSTFC 2023] A+B problem</h3><p><a href=\"https://www.luogu.com.cn/problem/P9782\">题目链接</a></p>\n<p>签到题，$26$ 进制加法。</p>\n<div class='spoiler collapsed'>\n    \n    <div class='spoiler-title'>\n        代码\n    </div>\n    <div class='spoiler-content'>\n        <pre><code class=\"lang-cpp\">#include &lt;bits/stdc++.h&gt;\ntypedef long long ll;\nusing namespace std;\nconst int N=2e5+7;\n\nint main()\n{\n    char ch1,tmp,ch2;\n    scanf(&quot;%c%c%c&quot;,&amp;ch1,&amp;tmp,&amp;ch2);\n\n    int k=ch1-&#39;A&#39;+ch2-&#39;A&#39;;\n    if(k&gt;=26) {\n        k-=26;cout&lt;&lt;&#39;B&#39;;\n    }\n    cout&lt;&lt;char(k+&#39;A&#39;);\n    return 0;\n}\n</code></pre>\n\n    </div>\n</div>\n<link rel=\"stylesheet\" href=\"/css/spoiler.css\" type=\"text/css\"><script src=\"/js/spoiler.js\" type=\"text/javascript\" async></script>","site":{"data":{}},"excerpt":"","more":"<p>加星号表示看了题解。</p>\n<p>摆烂的十月份。</p>\n<h2 id=\"P1709-USACO5-5-隐藏口令-Hidden-Password-＊\"><a href=\"#P1709-USACO5-5-隐藏口令-Hidden-Password-＊\" class=\"headerlink\" title=\"P1709 [USACO5.5] 隐藏口令 Hidden Password ＊\"></a>P1709 [USACO5.5] 隐藏口令 Hidden Password ＊</h2><p> <a href=\"https://www.luogu.com.cn/problem/P1709\">题目链接</a></p>\n<p>最小表示法模板题，设当前比较以 $i$ 和 $j$ 开头的字符串，则对两字符串一位一位向后比较，即每次比较 $i+k$ 和 $j+k$，直到遇到不同的字符，假设 $i$ 开头的字符串更小，则令 $j$ 直接跳到 $j+k+1$，因为对于以 $j$ 到 $j+k$ 开头的字符串，都有对应的以 $i$ 到 $i+k$ 开头的字符串必它小。时间复杂度 $O( n)$。</p>\n<div class='spoiler collapsed'>\n    \n    <div class='spoiler-title'>\n        代码\n    </div>\n    <div class='spoiler-content'>\n        <pre><code class=\"lang-cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N=5e6+7;\nchar a[N];\nint main()\n{\n    int n;\n    cin&gt;&gt;n;\n    for(int i=0;i&lt;n;++i) {\n        char ch=getchar();\n        while(ch&lt;&#39;a&#39;||ch&gt;&#39;z&#39;)  ch=getchar();\n        a[i]=ch;\n    }\n    int i=0,j=1,k=0;\n    while(k&lt;n&amp;&amp;i&lt;n&amp;&amp;j&lt;n) {\n        if(a[(i+k)%n]==a[(j+k)%n])  ++k;\n        else {\n            a[(i+k)%n]&gt;a[(j+k)%n]?i=i+k+1:j=j+k+1;\n            if(i==j)  ++i;\n            k=0;\n        }\n    }\n    cout&lt;&lt;min(i,j);\n    return 0;\n}\n</code></pre>\n\n    </div>\n</div>\n<h2 id=\"P6310-「Wdsr-1」仓库建设\"><a href=\"#P6310-「Wdsr-1」仓库建设\" class=\"headerlink\" title=\"P6310 「Wdsr-1」仓库建设\"></a>P6310 「Wdsr-1」仓库建设</h2><p><a href=\"https://www.luogu.com.cn/problem/P6310\">题目链接</a></p>\n<p>写过题解了，<a href=\"https://a154051.gitee.io/2023/09/25/solution-P6310-cang-ku-jian-she/\">【题解】P6310 [Wdsr-1]仓库建设</a></p>\n<h2 id=\"武汉大学2023年新生程序设计竞赛（同步赛）\"><a href=\"#武汉大学2023年新生程序设计竞赛（同步赛）\" class=\"headerlink\" title=\"武汉大学2023年新生程序设计竞赛（同步赛）\"></a>武汉大学2023年新生程序设计竞赛（同步赛）</h2><h3 id=\"A-教科书般的亵渎\"><a href=\"#A-教科书般的亵渎\" class=\"headerlink\" title=\"A. 教科书般的亵渎\"></a>A. 教科书般的亵渎</h3><p><a href=\"https://ac.nowcoder.com/acm/contest/66651/A\">题目链接</a></p>\n<p>将 $a$ 从大到小排序，若第一项为 $0$ 或 $1$ 且后面每一项与前一项的差小于等于 $1$ 则为 $YES$，否则为 $NO$。</p>\n<div class='spoiler collapsed'>\n    \n    <div class='spoiler-title'>\n        代码\n    </div>\n    <div class='spoiler-content'>\n        <pre><code class=\"lang-cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N=1e6;\nint a[N];\nint main()\n{\n    int n;\n    cin&gt;&gt;n;\n    for(int i=1;i&lt;=n;++i)  scanf(&quot;%d&quot;,&amp;a[i]);\n    sort(a+1,a+1+n);\n    int last=0;\n    for(int i=1;i&lt;=n;++i) {\n        if(a[i]==last||a[i]==last+1) {last=a[i];continue;}\n        cout&lt;&lt;&quot;NO&quot;;\n        return 0;\n    }\n    cout&lt;&lt;&quot;YES&quot;;\n    return 0;\n}\n</code></pre>\n\n    </div>\n</div>\n<h3 id=\"C-覆叶之交\"><a href=\"#C-覆叶之交\" class=\"headerlink\" title=\"C. 覆叶之交\"></a>C. 覆叶之交</h3><p><a href=\"https://ac.nowcoder.com/acm/contest/66651/C\">题目链接</a></p>\n<p>给定三个矩形，求它们的面积并。</p>\n<p>用容斥写，难点在代码实现。</p>\n<div class='spoiler collapsed'>\n    \n    <div class='spoiler-title'>\n        代码\n    </div>\n    <div class='spoiler-content'>\n        <pre><code class=\"lang-cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\nstruct squ {\n    bool flag;\n    ll x1,x2,y1,y2;\n}a[20];\nint tot=3,tmp[10];\n\nvoid sol(squ A,squ B)\n{\n    ++tot;\n    if(A.flag||B.flag) {a[tot].flag=1;return ;}\n    if(A.x2&lt;=B.x1||B.x2&lt;=A.x1||A.y2&lt;=B.y1||B.y2&lt;=A.y1)  {a[tot].flag=1;return ;}\n    tmp[1]=A.x1;tmp[2]=A.x2;tmp[3]=B.x1;tmp[4]=B.x2;\n    sort(tmp+1,tmp+5);\n    a[tot].x2=tmp[3];a[tot].x1=tmp[2];\n\n    tmp[1]=A.y1;tmp[2]=A.y2;tmp[3]=B.y1;tmp[4]=B.y2;\n    sort(tmp+1,tmp+5);\n    a[tot].y1=tmp[2];a[tot].y2=tmp[3];\n}\nint main()\n{\n    ll ans=0;\n    for(int i=1;i&lt;=3;++i) {\n        cin&gt;&gt;a[i].x1&gt;&gt;a[i].y1&gt;&gt;a[i].x2&gt;&gt;a[i].y2;\n        ans+=abs((a[i].x1-a[i].x2)*(a[i].y1-a[i].y2));\n    }\n    for(int i=1;i&lt;=3;++i)\n        for(int j=i+1;j&lt;=3;++j) {\n            sol(a[i],a[j]);\n            if(a[tot].flag==0)  ans-=abs((a[tot].x1-a[tot].x2)*(a[tot].y1-a[tot].y2));\n        }\n    sol(a[4],a[5]);sol(a[6],a[7]);\n    if(a[tot].flag==0)  ans+=abs((a[tot].x1-a[tot].x2)*(a[tot].y1-a[tot].y2));\n    cout&lt;&lt;ans;\n    return 0;\n}\n</code></pre>\n\n    </div>\n</div>\n<h3 id=\"E-不是n皇后问题\"><a href=\"#E-不是n皇后问题\" class=\"headerlink\" title=\"E. 不是n皇后问题\"></a>E. 不是n皇后问题</h3><p><a href=\"https://ac.nowcoder.com/acm/contest/66651/E\">题目链接</a></p>\n<p>看着挺麻烦，实际上就是把 $1$ 到 $n^2$ 按顺序填进格子就行了。</p>\n<div class='spoiler collapsed'>\n    \n    <div class='spoiler-title'>\n        代码\n    </div>\n    <div class='spoiler-content'>\n        <pre><code class=\"lang-cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N=1e6;\nint main()\n{\n    int n,cnt=0;\n    cin&gt;&gt;n;\n    for(int i=1;i&lt;=n;++i) {\n        for(int j=1;j&lt;=n;++j)  printf(&quot;%d &quot;,++cnt);\n        printf(&quot;\\n&quot;);\n    }\n\n\n    return 0;\n}\n</code></pre>\n\n    </div>\n</div>\n<h3 id=\"J-放棋子\"><a href=\"#J-放棋子\" class=\"headerlink\" title=\"J. 放棋子\"></a>J. 放棋子</h3><p><a href=\"https://ac.nowcoder.com/acm/contest/66651/J\">题目链接</a></p>\n<p>行和列可以分开计算，对于同一行，要使分数最大，则每次落子需要相连的旗子尽可能多，因此可以从左至右依次落子，这样就可以得到这一行的最大分数。可以证明，如果从第一行到最后一行操作也可以得到列的最大分数。时间复杂度 $O(n\\times m)$。</p>\n<div class='spoiler collapsed'>\n    \n    <div class='spoiler-title'>\n        代码\n    </div>\n    <div class='spoiler-content'>\n        <pre><code class=\"lang-cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\nconst int N=1e5+7;\nvector&lt;int&gt; a[N];\nint main()\n{\n    int n,m;\n    ll ans=0;\n    cin&gt;&gt;n&gt;&gt;m;\n    for(int i=1;i&lt;=n;++i) {\n        a[i].push_back(0);\n        ll now=0;\n        for(int j=1;j&lt;=m;++j) {\n            char ch=getchar();\n            while(ch!=&#39;#&#39;&amp;&amp;ch!=&#39;.&#39;)  ch=getchar();\n            a[i].push_back(0);\n            if(ch==&#39;#&#39;) {\n                a[i][j]=1;\n                ++now;\n                ans+=now*now;\n            } \n            else  now=0;\n        }\n    }\n    for(int i=1;i&lt;=m;++i) {\n        ll now=0;\n        for(int j=1;j&lt;=n;++j) {\n            if(a[j][i])  ++now,ans+=now*now;\n            else  now=0;\n        }\n    }\n    cout&lt;&lt;ans;\n    return 0;\n}\n</code></pre>\n\n    </div>\n</div>\n<h3 id=\"K-矩形分割\"><a href=\"#K-矩形分割\" class=\"headerlink\" title=\"K. 矩形分割\"></a>K. 矩形分割</h3><p><a href=\"https://ac.nowcoder.com/acm/contest/66651/K\">题目链接</a></p>\n<p>显然我们想要分割出来的正方形边长尽可能大，所以以矩形的短边为正方形边长进行分割直到无法分割，如果还剩下来一个小矩形，就再对这个矩形进行上述操作，直到分割完全。</p>\n<div class='spoiler collapsed'>\n    \n    <div class='spoiler-title'>\n        代码\n    </div>\n    <div class='spoiler-content'>\n        <pre><code class=\"lang-cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\nint sol(int n,int m)\n{\n    if(n==0||m==0)  return 0;\n    if(n==m)  return n;\n    if(n&lt;m)  swap(n,m);\n    return m*(n/m)+sol(m,n%m);\n\n}\nint main()\n{\n    int n,m;\n    cin&gt;&gt;n&gt;&gt;m;\n    cout&lt;&lt;sol(n,m);\n    return 0;\n}\n</code></pre>\n\n    </div>\n</div>\n<h3 id=\"L-小镜的数学题\"><a href=\"#L-小镜的数学题\" class=\"headerlink\" title=\"L. 小镜的数学题\"></a>L. 小镜的数学题</h3><p><a href=\"https://ac.nowcoder.com/acm/contest/66651/L\">题目链接</a></p>\n<p>从 $x$ 向后暴力找，最坏也不会超过 $2x$，数据比较水就过了。</p>\n<div class='spoiler collapsed'>\n    \n    <div class='spoiler-title'>\n        代码\n    </div>\n    <div class='spoiler-content'>\n        <pre><code class=\"lang-cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\nint main()\n{\n    ll n;\n    cin&gt;&gt;n;\n    for(ll i=n+1;;++i) {\n        if((n&amp;i)==0) {\n            cout&lt;&lt;i;\n            return 0;\n        }\n        n=(n&amp;i);\n    }\n    return 0;\n}\n</code></pre>\n\n    </div>\n</div>\n<h2 id=\"P2017-USACO09DEC-Dizzy-Cows-G\"><a href=\"#P2017-USACO09DEC-Dizzy-Cows-G\" class=\"headerlink\" title=\"P2017 [USACO09DEC] Dizzy Cows G\"></a>P2017 [USACO09DEC] Dizzy Cows G</h2><p><a href=\"https://www.luogu.com.cn/problem/P2017\">题目链接</a></p>\n<p>给定一个图，有无向边和有向边，给每条无向边指定一个方向，并且不出现环。</p>\n<p>考虑拓扑排序判定有向无环图的过程，每次删去出度为 $0$ 的点，若最终能删完则为有向无环图，可以发现，每条边都是由拓扑序大的指向拓扑序小的。因此在本题中先无视无向边对原图进行拓扑排序，再让无向边由拓扑序大的点指向拓扑序小的点，就得到了有向无环图。</p>\n<div class='spoiler collapsed'>\n    \n    <div class='spoiler-title'>\n        代码\n    </div>\n    <div class='spoiler-content'>\n        <pre><code class=\"lang-cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N=1e5+7;\nvector&lt;int&gt; last[N];\nint deg[N],dep[N],cnt=0;\ndeque&lt;int&gt; q;\nint main()\n{\n    int n,m1,m2;\n    cin&gt;&gt;n&gt;&gt;m1&gt;&gt;m2;\n    for(int i=1;i&lt;=m1;++i) {\n        int x,y;\n        scanf(&quot;%d%d&quot;,&amp;x,&amp;y);\n        ++deg[x];\n        last[y].push_back(x);\n    }\n    for(int i=1;i&lt;=n;++i)\n        if(!deg[i])  q.push_back(i);\n    while(q.size()) {\n        int x=q.front();\n        q.pop_front();\n        dep[x]=++cnt;\n        for(int i=0;i&lt;last[x].size();++i) \n            if((--deg[last[x][i]])==0)  q.push_back(last[x][i]);\n\n    }\n    while(m2--) {\n        int x,y;\n        scanf(&quot;%d%d&quot;,&amp;x,&amp;y);\n        if(dep[x]&lt;dep[y])  swap(x,y);\n        printf(&quot;%d %d\\n&quot;,x,y);\n    }\n    return 0;\n}\n</code></pre>\n\n    </div>\n</div>\n<h2 id=\"2023-年华中科技大学程序设计竞赛新生赛（线上同步赛）\"><a href=\"#2023-年华中科技大学程序设计竞赛新生赛（线上同步赛）\" class=\"headerlink\" title=\"2023 年华中科技大学程序设计竞赛新生赛（线上同步赛）\"></a>2023 年华中科技大学程序设计竞赛新生赛（线上同步赛）</h2><p>几乎每道题都会犯sb错误，我是超级罚时王。</p>\n<h3 id=\"P9769-HUSTFC-2023-简单的加法乘法计算题\"><a href=\"#P9769-HUSTFC-2023-简单的加法乘法计算题\" class=\"headerlink\" title=\"P9769 [HUSTFC 2023] 简单的加法乘法计算题\"></a>P9769 [HUSTFC 2023] 简单的加法乘法计算题</h3><p><a href=\"https://www.luogu.com.cn/problem/P9769\">题目链接</a></p>\n<p>设 $f_i$ 表示从 $0$ 到 $i$ 的最小操作次数，考虑最后一次操作，要么是加上 $A$  中的一个数，要么是乘上 $B$ 中的一个数，所以 $f_i=\\min\\{ \\min\\limits_{j=1}^n f_{i-A_j},\\min\\limits_{k=1}^m f_{i/B_k}\\}$，加法用堆来维护，乘法一个个枚举，时间复杂度 $O(ym\\log n)$，如果用单调队列可以降到 $O(ym)$。</p>\n<div class='spoiler collapsed'>\n    \n    <div class='spoiler-title'>\n        代码\n    </div>\n    <div class='spoiler-content'>\n        <pre><code class=\"lang-cpp\">#include &lt;bits/stdc++.h&gt;\n#define mp(x,y) make_pair(x,y)\ntypedef long long ll;\nusing namespace std;\nconst int N=5e6+7;\nint f[N],b[20];\npriority_queue&lt;pair&lt;int,int&gt; &gt; q;\nbool vis[N];\nint main()\n{\n    int x,n,m;\n    cin&gt;&gt;x&gt;&gt;n&gt;&gt;m;\n    for(int i=1;i&lt;=m;++i)  scanf(&quot;%d&quot;,&amp;b[i]);\n    vis[0]=1;q.push(mp(0,0));\n    for(int i=1;i&lt;=x;++i) {\n        int tmp=q.top().second;\n        while(!vis[tmp])  q.pop(),tmp=q.top().second;\n        f[i]=f[tmp]+1;\n        for(int j=1;j&lt;=m;++j)\n            if(i%b[j]==0)  f[i]=min(f[i],f[i/b[j]]+1);\n        q.push(mp(-f[i],i));\n        vis[i]=1;\n        if(i-n-1&gt;=0)  vis[i-n-1]=0;\n    }\n    cout&lt;&lt;f[x];\n    return 0;\n}\n</code></pre>\n\n    </div>\n</div>\n<h3 id=\"P9771-HUSTFC-2023-排列排序问题\"><a href=\"#P9771-HUSTFC-2023-排列排序问题\" class=\"headerlink\" title=\"P9771  [HUSTFC 2023] 排列排序问题\"></a>P9771  [HUSTFC 2023] 排列排序问题</h3><p><a href=\"https://www.luogu.com.cn/problem/P9771\">题目链接</a></p>\n<p>显然切割出来的序列是单调的，并且相邻的两个数相差 $1$，按这个方法切割使每个切出来的序列尽可能大就行了。时间复杂度 $O(n)$。</p>\n<div class='spoiler collapsed'>\n    \n    <div class='spoiler-title'>\n        代码\n    </div>\n    <div class='spoiler-content'>\n        <pre><code class=\"lang-cpp\">#include &lt;bits/stdc++.h&gt;\ntypedef long long ll;\nusing namespace std;\nconst int N=1e6+7;\nint a[N];\nint main()\n{\n    int n;\n    cin&gt;&gt;n;\n    for(int i=1;i&lt;=n;++i)  scanf(&quot;%d&quot;,&amp;a[i]);\n    int flag=-1,last=a[1],ans=0;\n    for(int i=2;i&lt;=n;++i) {\n        if(flag==-1) {\n            if(a[i]==last+1)  flag=1,last=a[i];\n            else  if(a[i]==last-1)  flag=0,last=a[i];\n            else  last=a[i],++ans;\n            continue;\n        }\n        if(a[i]==last+1&amp;&amp;flag==1) {last=a[i];continue;}\n        if(a[i]==last-1&amp;&amp;flag==0) {last=a[i];continue;}\n        last=a[i];++ans;\n        flag=-1;\n    }\n    cout&lt;&lt;ans;\n    return 0;\n}\n</code></pre>\n\n    </div>\n</div>\n<h3 id=\"P9774-HUSTFC-2023-新取模运算\"><a href=\"#P9774-HUSTFC-2023-新取模运算\" class=\"headerlink\" title=\"P9774[HUSTFC 2023] 新取模运算\"></a>P9774[HUSTFC 2023] 新取模运算</h3><p><a href=\"https://www.luogu.com.cn/problem/P9774\">题目链接</a></p>\n<p>显然新定义的运算符满足分配律，于是对于 $n$ 到 $1$ 这 $n$ 个数，可以分为是 $p$ 的倍数和不是 $p$ 的倍数分别计算，最后再相乘。</p>\n<p>对于不是 $p$ 的倍数的数，它们对 $p$ 进行新定义运算等价于直接对 $p$ 取模，这一部分可以通过预处理 $1$ 到 $p$ 的阶乘来求解。</p>\n<p>对于是 $p$ 的倍数的数，例如 $p,2p,3p…kp$，它们对 $p$ 进行新定义运算需要先除以 $p$，变为 $1,2,3…k$，这就成了原问题的子问题，于是可以递归求解，边界是 $ k&lt;p$。时间复杂度 $O(\\log_p n \\times \\log n)$。</p>\n<div class='spoiler collapsed'>\n    \n    <div class='spoiler-title'>\n        代码\n    </div>\n    <div class='spoiler-content'>\n        <pre><code class=\"lang-cpp\">#include &lt;bits/stdc++.h&gt;\ntypedef long long ll;\nusing namespace std;\nconst int N=1e6+7;\nint p;\nll jc[N];\nll qpow(ll x,ll k)\n{;\n    ll ans=1,tmp=x;\n    while(k) {\n        if(k&amp;1)  ans=ans*tmp%p;\n        tmp=tmp*tmp%p;\n        k&gt;&gt;=1;\n    }\n    return ans;\n}\nll sol(ll n)\n{\n    ll tmp=n/p;\n    ll ans=qpow(jc[p-1],tmp)*jc[n%p]%p;\n    if(tmp)  ans=ans*sol(tmp)%p;\n    return ans;\n}\nint main()\n{\n    int T;\n    cin&gt;&gt;T&gt;&gt;p;\n    jc[0]=1;\n    for(int i=1;i&lt;=p;++i)  jc[i]=jc[i-1]*i%p;\n    while(T--) {\n        ll n;\n        scanf(&quot;%lld&quot;,&amp;n);\n        printf(&quot;%lld\\n&quot;,sol(n));\n    }\n    return 0;\n}\n</code></pre>\n\n    </div>\n</div>\n<h3 id=\"P9775-HUSTFC-2023-广义线段树\"><a href=\"#P9775-HUSTFC-2023-广义线段树\" class=\"headerlink\" title=\"P9775 [HUSTFC 2023] 广义线段树\"></a>P9775 [HUSTFC 2023] 广义线段树</h3><p><a href=\"https://www.luogu.com.cn/problem/P9775\">题目链接</a></p>\n<p>给定一棵 $2n-1$ 个节点的树，$1$ 是根节点，$n$ 到 $2n-1$ 是叶子节点，给定叶子节点的点权，其他节点的点权是以它为子树的所有叶子节点的乘积。令每个叶子节点乘上一个数，求最后所有节点的和。</p>\n<p>对叶子节点乘上一个数，则从叶子节点到根节点路径上所有节点都要乘上这个数。所以原问题转化为对树上的一条链乘上一个数，可以用树链剖分，时间复杂度 $O(n\\log^2 n)$。比赛时没细想，但实际上可以先对所有叶子节点做修改，再在 dfs 返回时向上传就可以了，时间复杂度 $O(n)$。</p>\n<div class='spoiler collapsed'>\n    \n    <div class='spoiler-title'>\n        代码\n    </div>\n    <div class='spoiler-content'>\n        <pre><code class=\"lang-cpp\">#include &lt;bits/stdc++.h&gt;\ntypedef long long ll;\nusing namespace std;\nconst int N=2e6+7,mod=998244353;\nstruct tree {\n    ll tag,val;\n}tr[N&lt;&lt;1];\nll a[N],b[N];\nint nx[N][2],fa[N],dep[N],siz[N],top[N],pos[N],son[N],tot=0,rev[N];\nvoid push(int now,ll k)\n{\n    tr[now].val=tr[now].val*k%mod;\n    tr[now].tag=tr[now].tag*k%mod;\n    return ;\n}\nvoid build(int now,int l,int r)\n{\n    tr[now].tag=1;\n    if(l==r) {tr[now].val=a[rev[l]];return ;}\n    int mid=(l+r)&gt;&gt;1;\n    build(now&lt;&lt;1,l,mid);\n    build(now&lt;&lt;1|1,mid+1,r);\n    tr[now].val=(tr[now&lt;&lt;1].val+tr[now&lt;&lt;1|1].val)%mod;\n}\nvoid mul(int now,int l,int r,int x,int y,ll k)\n{\n    if(l&gt;=x&amp;&amp;r&lt;=y) {\n        tr[now].val=tr[now].val*k%mod;\n        tr[now].tag=tr[now].tag*k%mod;\n        return ;\n    }\n    if(tr[now].tag!=1) {\n        push(now&lt;&lt;1,tr[now].tag);\n        push(now&lt;&lt;1|1,tr[now].tag);\n        tr[now].tag=1;\n    }\n\n    int mid=(l+r)&gt;&gt;1;\n    if(x&lt;=mid)  mul(now&lt;&lt;1,l,mid,x,y,k);\n    if(y&gt;mid)  mul(now&lt;&lt;1|1,mid+1,r,x,y,k);\n    tr[now].val=(tr[now&lt;&lt;1].val+tr[now&lt;&lt;1|1].val)%mod;\n}\n\nvoid dfs1(int x,int FA)\n{\n    fa[x]=FA;dep[x]=dep[FA]+1;siz[x]=1;\n    if(nx[x][0]) {\n        dfs1(nx[x][0],x);dfs1(nx[x][1],x);\n        siz[x]+=siz[nx[x][0]]+siz[nx[x][1]];\n        son[x]=siz[nx[x][0]]&gt;siz[nx[x][1]]?nx[x][0]:nx[x][1];\n        a[x]=a[nx[x][0]]*a[nx[x][1]]%mod;\n    }\n}\nvoid dfs2(int x,int tp)\n{\n    top[x]=tp;pos[x]=++tot;rev[tot]=x;\n    if(!son[x])  return ;\n    dfs2(son[x],tp);\n    int tmp=nx[x][0];\n    if(tmp==son[x])  tmp=nx[x][1];\n    dfs2(tmp,tmp);\n}\nvoid chg(int x,ll k)\n{\n    if(k==1)  return ;\n    while(x) {\n        mul(1,1,tot,pos[top[x]],pos[x],k);\n        x=fa[top[x]];\n    }\n}\nint main()\n{\n    int n;\n    cin&gt;&gt;n;\n    for(int i=n;i&lt;=n*2-1;++i)  scanf(&quot;%lld&quot;,&amp;a[i]);\n    for(int i=1;i&lt;=n;++i)  scanf(&quot;%lld&quot;,&amp;b[i]);\n    for(int i=1;i&lt;n;++i)  scanf(&quot;%d%d&quot;,&amp;nx[i][0],&amp;nx[i][1]);\n    dfs1(1,0);\n    dfs2(1,1);\n    build(1,1,tot);\n    for(int i=1;i&lt;=n;++i) {\n        chg(i+n-1,b[i]);\n        printf(&quot;%lld &quot;,tr[1].val);\n    }\n    return 0;\n}\n</code></pre>\n\n    </div>\n</div>\n<h3 id=\"P9777-HUSTFC-2023-Fujisaki-讨厌数学\"><a href=\"#P9777-HUSTFC-2023-Fujisaki-讨厌数学\" class=\"headerlink\" title=\"P9777 [HUSTFC 2023] Fujisaki 讨厌数学\"></a>P9777 [HUSTFC 2023] Fujisaki 讨厌数学</h3><p><a href=\"https://www.luogu.com.cn/problem/P9777\">题目链接</a></p>\n<p>已知 $x^1+x^{-1}=k$，求 $x^n+x^{-n}$。</p>\n<p>可以发现 $(x^a+x^{-a})(x^b+x^{-b})=x^{a+b}+x^{-(a+b)}+x^{(a-b)}+x^{-(a-b)}$。设 $f_n=x^n+x^{-n}$，可以得到 $f_{(a+b)}=f_a \\times f_b-f_{(a-b)}$。因此，若 $n$ 是偶数，有 $f_n=f_{n/2}^2-f_0$，若 $n$ 是奇数，有 $f_n=f_{n/2}\\times f_{n/2+1}-f_1$。</p>\n<p>设 $n$ 在第一层，向下拆分得到第二层，第二层要么有一个数要么有两个数，考虑两个数的情况，这两个数一定相差 $1$，将它们向下拆分，第三层仍然是两个数，并且也是相差 $1$，可以证明每一层都至多两个数。每次拆分都除以 $2$，因此有 $\\log n$ 层。可以用记忆化搜索，但是 $n$ 太大了，要用 $map$ 存，时间复杂度 $O(\\log^2 n)$。</p>\n<div class='spoiler collapsed'>\n    \n    <div class='spoiler-title'>\n        代码\n    </div>\n    <div class='spoiler-content'>\n        <pre><code class=\"lang-cpp\">#include &lt;bits/stdc++.h&gt;\ntypedef long long ll;\nusing namespace std;\nmap&lt;ll,ll&gt; mp;\nconst int N=1e6+7;\nint mod;\nll k;\nll sol(ll n)\n{\n    if(n==1)  return k;\n    if(mp.find(n)!=mp.end())  return mp[n];\n    ll ans=1;\n    if(n&amp;1)  ans=sol(n/2)*sol(n/2+1)%mod-k;\n    else  ans=sol(n/2),ans=ans*ans%mod-2;\n    while(ans&lt;0)  ans+=mod;\n    mp[n]=ans;\n    return ans;\n}\nint main()\n{\n    ll n;\n    cin&gt;&gt;mod&gt;&gt;k&gt;&gt;n;\n    if(n==0)  cout&lt;&lt;&quot;2&quot;;\n    else  printf(&quot;%lld&quot;,sol(n));\n\n    return 0;\n}\n</code></pre>\n\n    </div>\n</div>\n<h3 id=\"P9779-HUSTFC-2023-不定项选择题\"><a href=\"#P9779-HUSTFC-2023-不定项选择题\" class=\"headerlink\" title=\"P9779 [HUSTFC 2023] 不定项选择题\"></a>P9779 [HUSTFC 2023] 不定项选择题</h3><p><a href=\"https://www.luogu.com.cn/problem/P9779\">题目链接</a></p>\n<p>$n$ 道题一共有 $2^n$ 种情况，除去全都不选的情况，最坏情况是最后一次才试出来，即要试 $2^n-1$ 次。<del>其实我是看样例猜出来的结论</del></p>\n<div class='spoiler collapsed'>\n    \n    <div class='spoiler-title'>\n        代码\n    </div>\n    <div class='spoiler-content'>\n        <pre><code class=\"lang-cpp\">#include &lt;bits/stdc++.h&gt;\ntypedef long long ll;\nusing namespace std;\nconst int N=2e5+7;\n\nint main()\n{\n    int n,ans=1;\n    cin&gt;&gt;n;\n    for(int i=1;i&lt;=n;++i)  ans*=2;\n    cout&lt;&lt;ans-1;\n    return 0;\n}\n</code></pre>\n\n    </div>\n</div>\n<h3 id=\"P9780-HUSTFC-2023-Azur-Lane\"><a href=\"#P9780-HUSTFC-2023-Azur-Lane\" class=\"headerlink\" title=\"P9780 [HUSTFC 2023] Azur Lane\"></a>P9780 [HUSTFC 2023] Azur Lane</h3><p><a href=\"https://www.luogu.com.cn/problem/P9780\">题目链接</a></p>\n<p>先考虑怎样使天数最小，一天内放置的喵箱等级是一个不上升序列，因此将序列划分为多个不上升序列，使每个序列尽可能大，就得到了天数最小的情况。</p>\n<p>之后天数每增加一，就需要从已划分的序列中再划分出一个序列，同时使花费最少，显然天数靠前的喵箱越多花费就越多，因此我们希望喵箱尽可能放在后面，于是可以从第一天开始向后找到第一个序列长度大于 $1$ 的序列，将它划分出一个数，最后将答案加上天数增加导致前面喵箱增加的花费。时间复杂度 $O(n)$。</p>\n<div class='spoiler collapsed'>\n    \n    <div class='spoiler-title'>\n        代码\n    </div>\n    <div class='spoiler-content'>\n        <pre><code class=\"lang-cpp\">#include &lt;bits/stdc++.h&gt;\ntypedef long long ll;\nusing namespace std;\nconst int N=1e6+7;\nint a[N];\nll b[N];\nint main()\n{\n    int m,k,tot=1;\n    ll ans=0;\n    cin&gt;&gt;m&gt;&gt;k;\n    for(int i=1;i&lt;=m;++i)  scanf(&quot;%d&quot;,&amp;a[i]);\n    b[1]=1;\n    for(int i=2;i&lt;=m;++i)  {\n        if(a[i]&lt;=a[i-1])  ++b[tot];\n        else  b[++tot]=1;\n    }\n    for(int i=1;i&lt;=tot;++i)  ans+=b[i]*(tot-i+1);\n    int now=1,totlast=0;\n    for(int i=1;i&lt;=m;++i) {\n        if(i&lt;tot)  {printf(&quot;-1 &quot;);continue;}\n        if(i==tot) {printf(&quot;%lld &quot;,ans);continue;}\n        while(b[now]==1)  ++totlast,++now;\n        --b[now];++totlast;\n        ans+=totlast;\n        printf(&quot;%lld &quot;,ans);\n    }\n    return 0;\n}\n</code></pre>\n\n    </div>\n</div>\n<h3 id=\"P9782-HUSTFC-2023-A-B-problem\"><a href=\"#P9782-HUSTFC-2023-A-B-problem\" class=\"headerlink\" title=\"P9782 [HUSTFC 2023] A+B problem\"></a>P9782 [HUSTFC 2023] A+B problem</h3><p><a href=\"https://www.luogu.com.cn/problem/P9782\">题目链接</a></p>\n<p>签到题，$26$ 进制加法。</p>\n<div class='spoiler collapsed'>\n    \n    <div class='spoiler-title'>\n        代码\n    </div>\n    <div class='spoiler-content'>\n        <pre><code class=\"lang-cpp\">#include &lt;bits/stdc++.h&gt;\ntypedef long long ll;\nusing namespace std;\nconst int N=2e5+7;\n\nint main()\n{\n    char ch1,tmp,ch2;\n    scanf(&quot;%c%c%c&quot;,&amp;ch1,&amp;tmp,&amp;ch2);\n\n    int k=ch1-&#39;A&#39;+ch2-&#39;A&#39;;\n    if(k&gt;=26) {\n        k-=26;cout&lt;&lt;&#39;B&#39;;\n    }\n    cout&lt;&lt;char(k+&#39;A&#39;);\n    return 0;\n}\n</code></pre>\n\n    </div>\n</div>\n"},{"title":"【学习笔记】模拟退火算法","author":"a154051","avatar":"https://a154051-img-1321592229.cos.ap-beijing.myqcloud.com/img/头像new.jpg","date":"2021-02-08T11:40:00.000Z","mathjax":true,"keywords":"模拟退火笔记","description":"模拟退火笔记","photos":["https://a154051-img-1321592229.cos.ap-beijing.myqcloud.com/img/鬼灭1new.jpg"],"_content":"\n# 简介\n\n模拟退火(Simulated Annealing，SA)是一种随机化算法。它适用于解决方案量极大的问题，如旅行商问题，求解多峰函数极值等问题。\n\n# 原理\n\n> 模拟退火算法来源于固体退火原理，是一种基于概率的算法，将固体加温至充分高，再让其徐徐冷却，加温时，固体内部粒子随温升变为无序状，内能增大，而徐徐冷却时粒子渐趋有序，在每个温度都达到平衡态，最后在常温时达到基态，内能减为最小。\n>\n> ——百度百科\n\n把问题看作固体内部粒子，把最优解看作平衡态，用程序模拟退火的过程，就是模拟退火算法。\n\n# 过程\n\n模拟退火中有三个参数，分别是初始温度 $T_0$、降温系数 $\\Delta$。其中，$\\Delta$ 是一个略小于 $1$ 的数。\n\n令温度 $T=T_0$，然后每次降温时 $T=T*\\Delta$，直到 $T=0$。\n\n在每次降温过程中，都要用当前解产生一个新解，即 $x_1=x_0+\\Delta x$。其中，$\\Delta x \\in R$ 并且 $\\left\\vert \\Delta x\\right\\vert \\propto T$，表示解的变动值，温度越低，它的变化幅度越小，产生的新解也会越来越趋近于最优解，如图，\n\n![模拟退火过程](https://oi-wiki.org/misc/images/simulated-annealing.gif)\n\n这时候我们需要考虑是否用新解替换当前解，定义当前温度为 $T$，某个解 $x$ 的贡献为 $f(x)$（这里的贡献不是指大小，而是这个解的优劣），则修改当前解的概率为 \n\n$$P=\\begin{cases}1&f(x_1)\\geqslant f(x_0)\\\\e^\\frac{-\\left\\vert f(x_1)-f(x_0)\\right\\vert}{T}&f(x_1)<f(x_0)\\end{cases}$$\n\n新解更优时，就一定替换。\n\n新解更劣时，就以一定概率接受它，这样就不会停留在局部最优解，这个概率与两个因素有关（可以结合这两个因素再体会一下上面的式子）：\n\n1. 当前温度。温度越高，接受劣解的概率越大，因为温度越高内部粒子越活跃。\n\n2. 新解和当前解的贡献差。新解的贡献和当前解的贡献相差越大，接受的概率越小。\n\n当温度降为 $0$ 时，就得到了最优解。\n\n**注意**：为了使结果更准确，一般不会直接选取最后的解作为答案，而是在模拟退火的过程中记录遇到的所有解中的最优解。\n\n# 代码\n\n以[P1337 [JSOI2004]平衡点 / 吊打XXX](https://www.luogu.com.cn/problem/P1337)为例。\n\n由~~题解~~物理知识可知，在平衡态时，系统的总能量最小，在该题中，总能量即物体总势能，物体离地面高度越低，势能越小，也就是使绳子在桌子上的长度尽量小。\n\n所以物体的势能与桌子上绳子的长度和物体的质量成正比，也就是找一点使得 $\\sum_{i=1}^n dis_i * w_i$最小（$dis_i$ 是绳结到第 $i$ 个洞口的距离）。\n\n代码如下\n```cpp\n#include <bits/stdc++.h>\n#define rd t*(rand()*2-RAND_MAX)     \n//rand()的范围是 [0,RAND_MAX)。RAND_MAX是一个常量，表示rand()的最大值。\n//这样写是为了使rand()能随机到负数。 \nusing namespace std;\nconst long double eps=1e-13,down=0.993;\nconst int mn=1e3+7;\nint n;\ndouble x[mn],y[mn],w[mn];\nlong double best_x,best_y,minn;  //全局最优解 \nlong double fx(long double x0,long double y0)   //计算贡献 \n{\n\tlong double rs=0,dx,dy;\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tdx=x[i]-x0;dy=y[i]-y0;\n\t\trs+=sqrt(dx*dx+dy*dy)*w[i];\n\t}\n\treturn rs;\n}\nint main()\n{\n\tsrand(154051);  //随机数种子，不要也行。\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tscanf(\"%lf%lf%lf\",&x[i],&y[i],&w[i]);\n\t\tbest_x+=x[i];best_y+=y[i];\n\t}\n\tlong double ans;\n\tbest_x/=n;best_y/=n;\n\tlong double x0=best_x,y0=best_y;\n\t//得到一组初始解 \n\tminn=ans=fx(best_x,best_y);\n\tfor(long double t=7000;t>eps;t*=down)\n\t{\n\t\tlong double x1=x0+rd,y1=y0+rd;  //产生新解 \n\t\tlong double rs=fx(x1,y1);  //计算新解的贡献 \n\t\tif(minn>rs)  //维护全局最优解 \n\t\t{\n\t\t\tminn=rs;\n\t\t\tbest_x=x1;best_y=y1;\n\t\t}\n\t\tif(rs<ans||exp((ans-rs)/t)*RAND_MAX>rand())  //exp()是c++库函数，exp(x)是求e的x次方 \n\t\t//相当于exp((ans-rs)/t)>(double)rand()/RAND_MAX，(double)rand()/RAND_MAX可以得到一个0~1之间的小数。一般会把除法变乘法保证精度。 \n\t\t{\n\t\t\tans=rs;\n\t\t\tx0=x1;y0=y1;\n\t\t}\n\t}\n\tprintf(\"%.3Lf %.3Lf\",best_x,best_y);\n\treturn 0;\n}\n```\n","source":"_posts/mo-ni-tui-huo-bi-ji.md","raw":"---\ntitle: 【学习笔记】模拟退火算法 \nauthor: a154051\navatar: https://a154051-img-1321592229.cos.ap-beijing.myqcloud.com/img/头像new.jpg\ncategories: 笔记\ndate: 2021-02-08 19:40:00\nmathjax: true\ntags: \n - 模拟退火\nkeywords: 模拟退火笔记\ndescription: 模拟退火笔记\nphotos: https://a154051-img-1321592229.cos.ap-beijing.myqcloud.com/img/鬼灭1new.jpg\n---\n\n# 简介\n\n模拟退火(Simulated Annealing，SA)是一种随机化算法。它适用于解决方案量极大的问题，如旅行商问题，求解多峰函数极值等问题。\n\n# 原理\n\n> 模拟退火算法来源于固体退火原理，是一种基于概率的算法，将固体加温至充分高，再让其徐徐冷却，加温时，固体内部粒子随温升变为无序状，内能增大，而徐徐冷却时粒子渐趋有序，在每个温度都达到平衡态，最后在常温时达到基态，内能减为最小。\n>\n> ——百度百科\n\n把问题看作固体内部粒子，把最优解看作平衡态，用程序模拟退火的过程，就是模拟退火算法。\n\n# 过程\n\n模拟退火中有三个参数，分别是初始温度 $T_0$、降温系数 $\\Delta$。其中，$\\Delta$ 是一个略小于 $1$ 的数。\n\n令温度 $T=T_0$，然后每次降温时 $T=T*\\Delta$，直到 $T=0$。\n\n在每次降温过程中，都要用当前解产生一个新解，即 $x_1=x_0+\\Delta x$。其中，$\\Delta x \\in R$ 并且 $\\left\\vert \\Delta x\\right\\vert \\propto T$，表示解的变动值，温度越低，它的变化幅度越小，产生的新解也会越来越趋近于最优解，如图，\n\n![模拟退火过程](https://oi-wiki.org/misc/images/simulated-annealing.gif)\n\n这时候我们需要考虑是否用新解替换当前解，定义当前温度为 $T$，某个解 $x$ 的贡献为 $f(x)$（这里的贡献不是指大小，而是这个解的优劣），则修改当前解的概率为 \n\n$$P=\\begin{cases}1&f(x_1)\\geqslant f(x_0)\\\\e^\\frac{-\\left\\vert f(x_1)-f(x_0)\\right\\vert}{T}&f(x_1)<f(x_0)\\end{cases}$$\n\n新解更优时，就一定替换。\n\n新解更劣时，就以一定概率接受它，这样就不会停留在局部最优解，这个概率与两个因素有关（可以结合这两个因素再体会一下上面的式子）：\n\n1. 当前温度。温度越高，接受劣解的概率越大，因为温度越高内部粒子越活跃。\n\n2. 新解和当前解的贡献差。新解的贡献和当前解的贡献相差越大，接受的概率越小。\n\n当温度降为 $0$ 时，就得到了最优解。\n\n**注意**：为了使结果更准确，一般不会直接选取最后的解作为答案，而是在模拟退火的过程中记录遇到的所有解中的最优解。\n\n# 代码\n\n以[P1337 [JSOI2004]平衡点 / 吊打XXX](https://www.luogu.com.cn/problem/P1337)为例。\n\n由~~题解~~物理知识可知，在平衡态时，系统的总能量最小，在该题中，总能量即物体总势能，物体离地面高度越低，势能越小，也就是使绳子在桌子上的长度尽量小。\n\n所以物体的势能与桌子上绳子的长度和物体的质量成正比，也就是找一点使得 $\\sum_{i=1}^n dis_i * w_i$最小（$dis_i$ 是绳结到第 $i$ 个洞口的距离）。\n\n代码如下\n```cpp\n#include <bits/stdc++.h>\n#define rd t*(rand()*2-RAND_MAX)     \n//rand()的范围是 [0,RAND_MAX)。RAND_MAX是一个常量，表示rand()的最大值。\n//这样写是为了使rand()能随机到负数。 \nusing namespace std;\nconst long double eps=1e-13,down=0.993;\nconst int mn=1e3+7;\nint n;\ndouble x[mn],y[mn],w[mn];\nlong double best_x,best_y,minn;  //全局最优解 \nlong double fx(long double x0,long double y0)   //计算贡献 \n{\n\tlong double rs=0,dx,dy;\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tdx=x[i]-x0;dy=y[i]-y0;\n\t\trs+=sqrt(dx*dx+dy*dy)*w[i];\n\t}\n\treturn rs;\n}\nint main()\n{\n\tsrand(154051);  //随机数种子，不要也行。\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tscanf(\"%lf%lf%lf\",&x[i],&y[i],&w[i]);\n\t\tbest_x+=x[i];best_y+=y[i];\n\t}\n\tlong double ans;\n\tbest_x/=n;best_y/=n;\n\tlong double x0=best_x,y0=best_y;\n\t//得到一组初始解 \n\tminn=ans=fx(best_x,best_y);\n\tfor(long double t=7000;t>eps;t*=down)\n\t{\n\t\tlong double x1=x0+rd,y1=y0+rd;  //产生新解 \n\t\tlong double rs=fx(x1,y1);  //计算新解的贡献 \n\t\tif(minn>rs)  //维护全局最优解 \n\t\t{\n\t\t\tminn=rs;\n\t\t\tbest_x=x1;best_y=y1;\n\t\t}\n\t\tif(rs<ans||exp((ans-rs)/t)*RAND_MAX>rand())  //exp()是c++库函数，exp(x)是求e的x次方 \n\t\t//相当于exp((ans-rs)/t)>(double)rand()/RAND_MAX，(double)rand()/RAND_MAX可以得到一个0~1之间的小数。一般会把除法变乘法保证精度。 \n\t\t{\n\t\t\tans=rs;\n\t\t\tx0=x1;y0=y1;\n\t\t}\n\t}\n\tprintf(\"%.3Lf %.3Lf\",best_x,best_y);\n\treturn 0;\n}\n```\n","slug":"mo-ni-tui-huo-bi-ji","published":1,"updated":"2023-10-13T10:42:06.494Z","comments":1,"layout":"post","link":"","_id":"cloo2ivvk0003r8v3e574fukl","content":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>模拟退火(Simulated Annealing，SA)是一种随机化算法。它适用于解决方案量极大的问题，如旅行商问题，求解多峰函数极值等问题。</p>\n<h1 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h1><blockquote>\n<p>模拟退火算法来源于固体退火原理，是一种基于概率的算法，将固体加温至充分高，再让其徐徐冷却，加温时，固体内部粒子随温升变为无序状，内能增大，而徐徐冷却时粒子渐趋有序，在每个温度都达到平衡态，最后在常温时达到基态，内能减为最小。</p>\n<p>——百度百科</p>\n</blockquote>\n<p>把问题看作固体内部粒子，把最优解看作平衡态，用程序模拟退火的过程，就是模拟退火算法。</p>\n<h1 id=\"过程\"><a href=\"#过程\" class=\"headerlink\" title=\"过程\"></a>过程</h1><p>模拟退火中有三个参数，分别是初始温度 $T_0$、降温系数 $\\Delta$。其中，$\\Delta$ 是一个略小于 $1$ 的数。</p>\n<p>令温度 $T=T_0$，然后每次降温时 $T=T*\\Delta$，直到 $T=0$。</p>\n<p>在每次降温过程中，都要用当前解产生一个新解，即 $x_1=x_0+\\Delta x$。其中，$\\Delta x \\in R$ 并且 $\\left\\vert \\Delta x\\right\\vert \\propto T$，表示解的变动值，温度越低，它的变化幅度越小，产生的新解也会越来越趋近于最优解，如图，</p>\n<p><img src=\"https://oi-wiki.org/misc/images/simulated-annealing.gif\" alt=\"模拟退火过程\"></p>\n<p>这时候我们需要考虑是否用新解替换当前解，定义当前温度为 $T$，某个解 $x$ 的贡献为 $f(x)$（这里的贡献不是指大小，而是这个解的优劣），则修改当前解的概率为 </p>\n<script type=\"math/tex; mode=display\">P=\\begin{cases}1&f(x_1)\\geqslant f(x_0)\\\\e^\\frac{-\\left\\vert f(x_1)-f(x_0)\\right\\vert}{T}&f(x_1)<f(x_0)\\end{cases}</script><p>新解更优时，就一定替换。</p>\n<p>新解更劣时，就以一定概率接受它，这样就不会停留在局部最优解，这个概率与两个因素有关（可以结合这两个因素再体会一下上面的式子）：</p>\n<ol>\n<li><p>当前温度。温度越高，接受劣解的概率越大，因为温度越高内部粒子越活跃。</p>\n</li>\n<li><p>新解和当前解的贡献差。新解的贡献和当前解的贡献相差越大，接受的概率越小。</p>\n</li>\n</ol>\n<p>当温度降为 $0$ 时，就得到了最优解。</p>\n<p><strong>注意</strong>：为了使结果更准确，一般不会直接选取最后的解作为答案，而是在模拟退火的过程中记录遇到的所有解中的最优解。</p>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><p>以<a href=\"https://www.luogu.com.cn/problem/P1337\">P1337 [JSOI2004]平衡点 / 吊打XXX</a>为例。</p>\n<p>由<del>题解</del>物理知识可知，在平衡态时，系统的总能量最小，在该题中，总能量即物体总势能，物体离地面高度越低，势能越小，也就是使绳子在桌子上的长度尽量小。</p>\n<p>所以物体的势能与桌子上绳子的长度和物体的质量成正比，也就是找一点使得 $\\sum_{i=1}^n dis_i * w_i$最小（$dis_i$ 是绳结到第 $i$ 个洞口的距离）。</p>\n<p>代码如下</p>\n<pre><code class=\"lang-cpp\">#include &lt;bits/stdc++.h&gt;\n#define rd t*(rand()*2-RAND_MAX)     \n//rand()的范围是 [0,RAND_MAX)。RAND_MAX是一个常量，表示rand()的最大值。\n//这样写是为了使rand()能随机到负数。 \nusing namespace std;\nconst long double eps=1e-13,down=0.993;\nconst int mn=1e3+7;\nint n;\ndouble x[mn],y[mn],w[mn];\nlong double best_x,best_y,minn;  //全局最优解 \nlong double fx(long double x0,long double y0)   //计算贡献 \n&#123;\n    long double rs=0,dx,dy;\n    for(int i=1;i&lt;=n;++i)\n    &#123;\n        dx=x[i]-x0;dy=y[i]-y0;\n        rs+=sqrt(dx*dx+dy*dy)*w[i];\n    &#125;\n    return rs;\n&#125;\nint main()\n&#123;\n    srand(154051);  //随机数种子，不要也行。\n    scanf(&quot;%d&quot;,&amp;n);\n    for(int i=1;i&lt;=n;++i)\n    &#123;\n        scanf(&quot;%lf%lf%lf&quot;,&amp;x[i],&amp;y[i],&amp;w[i]);\n        best_x+=x[i];best_y+=y[i];\n    &#125;\n    long double ans;\n    best_x/=n;best_y/=n;\n    long double x0=best_x,y0=best_y;\n    //得到一组初始解 \n    minn=ans=fx(best_x,best_y);\n    for(long double t=7000;t&gt;eps;t*=down)\n    &#123;\n        long double x1=x0+rd,y1=y0+rd;  //产生新解 \n        long double rs=fx(x1,y1);  //计算新解的贡献 \n        if(minn&gt;rs)  //维护全局最优解 \n        &#123;\n            minn=rs;\n            best_x=x1;best_y=y1;\n        &#125;\n        if(rs&lt;ans||exp((ans-rs)/t)*RAND_MAX&gt;rand())  //exp()是c++库函数，exp(x)是求e的x次方 \n        //相当于exp((ans-rs)/t)&gt;(double)rand()/RAND_MAX，(double)rand()/RAND_MAX可以得到一个0~1之间的小数。一般会把除法变乘法保证精度。 \n        &#123;\n            ans=rs;\n            x0=x1;y0=y1;\n        &#125;\n    &#125;\n    printf(&quot;%.3Lf %.3Lf&quot;,best_x,best_y);\n    return 0;\n&#125;\n</code></pre>\n<link rel=\"stylesheet\" href=\"/css/spoiler.css\" type=\"text/css\"><script src=\"/js/spoiler.js\" type=\"text/javascript\" async></script>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>模拟退火(Simulated Annealing，SA)是一种随机化算法。它适用于解决方案量极大的问题，如旅行商问题，求解多峰函数极值等问题。</p>\n<h1 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h1><blockquote>\n<p>模拟退火算法来源于固体退火原理，是一种基于概率的算法，将固体加温至充分高，再让其徐徐冷却，加温时，固体内部粒子随温升变为无序状，内能增大，而徐徐冷却时粒子渐趋有序，在每个温度都达到平衡态，最后在常温时达到基态，内能减为最小。</p>\n<p>——百度百科</p>\n</blockquote>\n<p>把问题看作固体内部粒子，把最优解看作平衡态，用程序模拟退火的过程，就是模拟退火算法。</p>\n<h1 id=\"过程\"><a href=\"#过程\" class=\"headerlink\" title=\"过程\"></a>过程</h1><p>模拟退火中有三个参数，分别是初始温度 $T_0$、降温系数 $\\Delta$。其中，$\\Delta$ 是一个略小于 $1$ 的数。</p>\n<p>令温度 $T=T_0$，然后每次降温时 $T=T*\\Delta$，直到 $T=0$。</p>\n<p>在每次降温过程中，都要用当前解产生一个新解，即 $x_1=x_0+\\Delta x$。其中，$\\Delta x \\in R$ 并且 $\\left\\vert \\Delta x\\right\\vert \\propto T$，表示解的变动值，温度越低，它的变化幅度越小，产生的新解也会越来越趋近于最优解，如图，</p>\n<p><img src=\"https://oi-wiki.org/misc/images/simulated-annealing.gif\" alt=\"模拟退火过程\"></p>\n<p>这时候我们需要考虑是否用新解替换当前解，定义当前温度为 $T$，某个解 $x$ 的贡献为 $f(x)$（这里的贡献不是指大小，而是这个解的优劣），则修改当前解的概率为 </p>\n<script type=\"math/tex; mode=display\">P=\\begin{cases}1&f(x_1)\\geqslant f(x_0)\\\\e^\\frac{-\\left\\vert f(x_1)-f(x_0)\\right\\vert}{T}&f(x_1)<f(x_0)\\end{cases}</script><p>新解更优时，就一定替换。</p>\n<p>新解更劣时，就以一定概率接受它，这样就不会停留在局部最优解，这个概率与两个因素有关（可以结合这两个因素再体会一下上面的式子）：</p>\n<ol>\n<li><p>当前温度。温度越高，接受劣解的概率越大，因为温度越高内部粒子越活跃。</p>\n</li>\n<li><p>新解和当前解的贡献差。新解的贡献和当前解的贡献相差越大，接受的概率越小。</p>\n</li>\n</ol>\n<p>当温度降为 $0$ 时，就得到了最优解。</p>\n<p><strong>注意</strong>：为了使结果更准确，一般不会直接选取最后的解作为答案，而是在模拟退火的过程中记录遇到的所有解中的最优解。</p>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><p>以<a href=\"https://www.luogu.com.cn/problem/P1337\">P1337 [JSOI2004]平衡点 / 吊打XXX</a>为例。</p>\n<p>由<del>题解</del>物理知识可知，在平衡态时，系统的总能量最小，在该题中，总能量即物体总势能，物体离地面高度越低，势能越小，也就是使绳子在桌子上的长度尽量小。</p>\n<p>所以物体的势能与桌子上绳子的长度和物体的质量成正比，也就是找一点使得 $\\sum_{i=1}^n dis_i * w_i$最小（$dis_i$ 是绳结到第 $i$ 个洞口的距离）。</p>\n<p>代码如下</p>\n<pre><code class=\"lang-cpp\">#include &lt;bits/stdc++.h&gt;\n#define rd t*(rand()*2-RAND_MAX)     \n//rand()的范围是 [0,RAND_MAX)。RAND_MAX是一个常量，表示rand()的最大值。\n//这样写是为了使rand()能随机到负数。 \nusing namespace std;\nconst long double eps=1e-13,down=0.993;\nconst int mn=1e3+7;\nint n;\ndouble x[mn],y[mn],w[mn];\nlong double best_x,best_y,minn;  //全局最优解 \nlong double fx(long double x0,long double y0)   //计算贡献 \n&#123;\n    long double rs=0,dx,dy;\n    for(int i=1;i&lt;=n;++i)\n    &#123;\n        dx=x[i]-x0;dy=y[i]-y0;\n        rs+=sqrt(dx*dx+dy*dy)*w[i];\n    &#125;\n    return rs;\n&#125;\nint main()\n&#123;\n    srand(154051);  //随机数种子，不要也行。\n    scanf(&quot;%d&quot;,&amp;n);\n    for(int i=1;i&lt;=n;++i)\n    &#123;\n        scanf(&quot;%lf%lf%lf&quot;,&amp;x[i],&amp;y[i],&amp;w[i]);\n        best_x+=x[i];best_y+=y[i];\n    &#125;\n    long double ans;\n    best_x/=n;best_y/=n;\n    long double x0=best_x,y0=best_y;\n    //得到一组初始解 \n    minn=ans=fx(best_x,best_y);\n    for(long double t=7000;t&gt;eps;t*=down)\n    &#123;\n        long double x1=x0+rd,y1=y0+rd;  //产生新解 \n        long double rs=fx(x1,y1);  //计算新解的贡献 \n        if(minn&gt;rs)  //维护全局最优解 \n        &#123;\n            minn=rs;\n            best_x=x1;best_y=y1;\n        &#125;\n        if(rs&lt;ans||exp((ans-rs)/t)*RAND_MAX&gt;rand())  //exp()是c++库函数，exp(x)是求e的x次方 \n        //相当于exp((ans-rs)/t)&gt;(double)rand()/RAND_MAX，(double)rand()/RAND_MAX可以得到一个0~1之间的小数。一般会把除法变乘法保证精度。 \n        &#123;\n            ans=rs;\n            x0=x1;y0=y1;\n        &#125;\n    &#125;\n    printf(&quot;%.3Lf %.3Lf&quot;,best_x,best_y);\n    return 0;\n&#125;\n</code></pre>\n"},{"author":"a154051","avatar":"https://a154051-img-1321592229.cos.ap-beijing.myqcloud.com/img/头像new.jpg","title":"【题解】P2472 [SCOI2007]蜥蜴","mathjax":true,"date":"2021-03-05T08:36:55.000Z","description":"网络瘤，毒瘤的瘤。","photos":["https://a154051-img-1321592229.cos.ap-beijing.myqcloud.com/img/P2472.jpg"],"_content":"\n[P2472 [SCOI2007]蜥蜴](https://www.luogu.com.cn/problem/P2472)\n\n**网络瘤，毒瘤的瘤。**\n\n蒟蒻第一次不看题解写出来网络瘤（~~然而还是逃不过debug半天的命运~~）。{% emoji_coda quyin/hematemesis %}\n\n# 题意\n\n在 $r\\times c$ 的网格中，每个格子都有高度，高度为 $0$ 则不存在，一些格子上有蜥蜴，蜥蜴可以跳到直线距离不超过 $d$ 的格子上，每跳一次，原来的格子高度就会减一，求最少有几只蜥蜴不能逃离。\n\n# 分析\n\n显然，每个格子跳了一定次数后就不能再跳了，那么如何在网络流中加入这个限制呢？\n\n假设原来的点编号为 $i$，高度为 $h$，总共 $n$ 个点，我们可以把这个点拆成两个，编号为 $i$ 和 $i+n$，$i$ 负责原来这个点的入边，$i+n$ 负责出边，再连一条从 $i$ 到 $i+n$ 容量为 $h$ 的边，如图：\n\n![P2472](https://img.imgdb.cn/item/6041e56b360785be54ee87f8.png)\n\n这个思想类似于[最小割点问题](https://www.luogu.com.cn/problem/P1345)。\n\n# 建图\n\n**注：以下说的点都是高度大于 $0$ 的点，高度为 $0$ 的点直接忽略。**\n\n- 对于每个点都将其拆为入点和出点，容量为格子高度。\n\n- 对于能跳出网格的点，从它的出点到汇点连一条容量无穷大的边。\n\n- 对于有蜥蜴的点，从源点到它的入点连一条容量为 $1$ 的边（因为每个点上最多有 $1$ 个蜥蜴）。\n\n其中，源点和汇点都是原图中不存在的，需要另外新建。\n\n最后跑最大流，得到最多能逃离的蜥蜴数，用蜥蜴总数减去最大流即为所求答案。\n\n# 代码\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nconst int mn=407,inf=1e7;\nstruct node{\n\tint x,y;\n};\nvector<node> p;\nint n,m,d,tot=0,num[27][27],q[2*mn],dep[2*mn];\nint fr[2*mn],fr2[2*mn],nx[100*mn],to[100*mn],val[100*mn],tt=1;\nvoid add(int x,int y,int w)\n{\n\t++tt;\n\tnx[tt]=fr[x];\n\tfr[x]=tt;\n\tto[tt]=y;\n\tval[tt]=w;\n}\nbool bfs()\n{\n\tfor(int i=0;i<=n*m*2+1;++i)  dep[i]=0,fr2[i]=fr[i];  //0 为源点，2*n*m+1 为汇点 \n\tint h=1,t=1;\n\tq[1]=0;dep[0]=1;\n\twhile(h<=t)\n\t{\n\t\tint u=q[h];\n\t\tfor(int i=fr[u];i;i=nx[i])\n\t\t{\n\t\t\tint v=to[i];\n\t\t\tif(dep[v]||!val[i])  continue;\n\t\t\tq[++t]=v;\n\t\t\tdep[v]=dep[u]+1;\n\t\t\tif(v==n*m*2+1)  return 1;\n\t\t}\n\t\t++h;\n\t}\n\treturn 0;\n}\nint dfs(int u,int in)\n{\n\tif(u==n*m*2+1)  return in;\n\tint out=0;\n\tfor(int &i=fr2[u];i;i=nx[i])  //当前弧优化，i 是引用，当 i 变化时 fr2 也会跟着变化 \n\t{\n\t\tint v=to[i];\n\t\tif(dep[u]==dep[v]-1&&val[i])\n\t\t{\n\t\t\tint rs=dfs(v,val[i]<in?val[i]:in);\n\t\t\tval[i]-=rs;val[i^1]+=rs;\n\t\t\tout+=rs;in-=rs;\n\t\t\tif(!in)  break;\n\t\t}\n\t}\n\tif(out==0)  dep[u]=0;\n\treturn out;\n}\ninline int dist(node v0,node v1){return (v0.x-v1.x)*(v0.x-v1.x)+(v0.y-v1.y)*(v0.y-v1.y);}  //求两点的直线距离 \nint main()\n{\n\tscanf(\"%d%d%d\",&n,&m,&d);\n\tfor(int i=1;i<=n;++i)\n\t  for(int j=1;j<=m;++j)\n\t  {\n\t  \tnum[i][j]=++tot;\n\t  \tint x;\n\t  \tscanf(\"%1d\",&x);\n\t  \tif(x==0)  continue;\n\t  \tadd(num[i][j],num[i][j]+n*m,x);  //拆点 \n\t  \tadd(num[i][j]+n*m,num[i][j],0);\n\t  \tp.push_back((node){i,j});\n\t  \tif(i-d<1||j-d<1||i+d>n||j+d>m)  add(num[i][j]+n*m,2*n*m+1,inf),add(2*n*m+1,num[i][j]+n*m,0);  //连汇点 \n\t  }\n\tfor(int i=0;i<p.size()-1;++i)  //建图 \n\t  for(int j=i+1;j<p.size();++j)\n\t  {\n\t  \tif(dist(p[i],p[j])>d*d)  continue;\n\t  \tnode v0=p[i],v1=p[j];\n\t  \tadd(num[v0.x][v0.y]+n*m,num[v1.x][v1.y],inf);\n\t  \tadd(num[v1.x][v1.y],num[v0.x][v0.y]+n*m,0);\n\t  \tadd(num[v1.x][v1.y]+n*m,num[v0.x][v0.y],inf);\n\t  \tadd(num[v0.x][v0.y],num[v1.x][v1.y]+n*m,0);\n\t  }\n\tint cnt=0;\n\tfor(int i=1;i<=n;++i)\n\t  for(int j=1;j<=m;++j)\n\t  {\n\t  \tchar ch=getchar();\n\t  \twhile(ch!='.'&&ch!='L')  ch=getchar();\n\t  \tif(ch=='L')  ++cnt,add(0,num[i][j],1),add(num[i][j],0,0);  //连源点 \n\t  }\n\tint ans=0;\n\twhile(bfs())  ans+=dfs(0,inf);\n\tcout<<cnt-ans;\n\treturn 0;\n}\n```\n\n","source":"_posts/solution-P2472-xi-yi.md","raw":"---\nauthor: a154051\navatar: 'https://a154051-img-1321592229.cos.ap-beijing.myqcloud.com/img/头像new.jpg'\ntitle: 【题解】P2472 [SCOI2007]蜥蜴\nmathjax: true\ndate: 2021-03-05 16:36:55\ntags: \n - 网络流\ncategories: 题解\ndescription: 网络瘤，毒瘤的瘤。\nphotos: https://a154051-img-1321592229.cos.ap-beijing.myqcloud.com/img/P2472.jpg\n---\n\n[P2472 [SCOI2007]蜥蜴](https://www.luogu.com.cn/problem/P2472)\n\n**网络瘤，毒瘤的瘤。**\n\n蒟蒻第一次不看题解写出来网络瘤（~~然而还是逃不过debug半天的命运~~）。{% emoji_coda quyin/hematemesis %}\n\n# 题意\n\n在 $r\\times c$ 的网格中，每个格子都有高度，高度为 $0$ 则不存在，一些格子上有蜥蜴，蜥蜴可以跳到直线距离不超过 $d$ 的格子上，每跳一次，原来的格子高度就会减一，求最少有几只蜥蜴不能逃离。\n\n# 分析\n\n显然，每个格子跳了一定次数后就不能再跳了，那么如何在网络流中加入这个限制呢？\n\n假设原来的点编号为 $i$，高度为 $h$，总共 $n$ 个点，我们可以把这个点拆成两个，编号为 $i$ 和 $i+n$，$i$ 负责原来这个点的入边，$i+n$ 负责出边，再连一条从 $i$ 到 $i+n$ 容量为 $h$ 的边，如图：\n\n![P2472](https://img.imgdb.cn/item/6041e56b360785be54ee87f8.png)\n\n这个思想类似于[最小割点问题](https://www.luogu.com.cn/problem/P1345)。\n\n# 建图\n\n**注：以下说的点都是高度大于 $0$ 的点，高度为 $0$ 的点直接忽略。**\n\n- 对于每个点都将其拆为入点和出点，容量为格子高度。\n\n- 对于能跳出网格的点，从它的出点到汇点连一条容量无穷大的边。\n\n- 对于有蜥蜴的点，从源点到它的入点连一条容量为 $1$ 的边（因为每个点上最多有 $1$ 个蜥蜴）。\n\n其中，源点和汇点都是原图中不存在的，需要另外新建。\n\n最后跑最大流，得到最多能逃离的蜥蜴数，用蜥蜴总数减去最大流即为所求答案。\n\n# 代码\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nconst int mn=407,inf=1e7;\nstruct node{\n\tint x,y;\n};\nvector<node> p;\nint n,m,d,tot=0,num[27][27],q[2*mn],dep[2*mn];\nint fr[2*mn],fr2[2*mn],nx[100*mn],to[100*mn],val[100*mn],tt=1;\nvoid add(int x,int y,int w)\n{\n\t++tt;\n\tnx[tt]=fr[x];\n\tfr[x]=tt;\n\tto[tt]=y;\n\tval[tt]=w;\n}\nbool bfs()\n{\n\tfor(int i=0;i<=n*m*2+1;++i)  dep[i]=0,fr2[i]=fr[i];  //0 为源点，2*n*m+1 为汇点 \n\tint h=1,t=1;\n\tq[1]=0;dep[0]=1;\n\twhile(h<=t)\n\t{\n\t\tint u=q[h];\n\t\tfor(int i=fr[u];i;i=nx[i])\n\t\t{\n\t\t\tint v=to[i];\n\t\t\tif(dep[v]||!val[i])  continue;\n\t\t\tq[++t]=v;\n\t\t\tdep[v]=dep[u]+1;\n\t\t\tif(v==n*m*2+1)  return 1;\n\t\t}\n\t\t++h;\n\t}\n\treturn 0;\n}\nint dfs(int u,int in)\n{\n\tif(u==n*m*2+1)  return in;\n\tint out=0;\n\tfor(int &i=fr2[u];i;i=nx[i])  //当前弧优化，i 是引用，当 i 变化时 fr2 也会跟着变化 \n\t{\n\t\tint v=to[i];\n\t\tif(dep[u]==dep[v]-1&&val[i])\n\t\t{\n\t\t\tint rs=dfs(v,val[i]<in?val[i]:in);\n\t\t\tval[i]-=rs;val[i^1]+=rs;\n\t\t\tout+=rs;in-=rs;\n\t\t\tif(!in)  break;\n\t\t}\n\t}\n\tif(out==0)  dep[u]=0;\n\treturn out;\n}\ninline int dist(node v0,node v1){return (v0.x-v1.x)*(v0.x-v1.x)+(v0.y-v1.y)*(v0.y-v1.y);}  //求两点的直线距离 \nint main()\n{\n\tscanf(\"%d%d%d\",&n,&m,&d);\n\tfor(int i=1;i<=n;++i)\n\t  for(int j=1;j<=m;++j)\n\t  {\n\t  \tnum[i][j]=++tot;\n\t  \tint x;\n\t  \tscanf(\"%1d\",&x);\n\t  \tif(x==0)  continue;\n\t  \tadd(num[i][j],num[i][j]+n*m,x);  //拆点 \n\t  \tadd(num[i][j]+n*m,num[i][j],0);\n\t  \tp.push_back((node){i,j});\n\t  \tif(i-d<1||j-d<1||i+d>n||j+d>m)  add(num[i][j]+n*m,2*n*m+1,inf),add(2*n*m+1,num[i][j]+n*m,0);  //连汇点 \n\t  }\n\tfor(int i=0;i<p.size()-1;++i)  //建图 \n\t  for(int j=i+1;j<p.size();++j)\n\t  {\n\t  \tif(dist(p[i],p[j])>d*d)  continue;\n\t  \tnode v0=p[i],v1=p[j];\n\t  \tadd(num[v0.x][v0.y]+n*m,num[v1.x][v1.y],inf);\n\t  \tadd(num[v1.x][v1.y],num[v0.x][v0.y]+n*m,0);\n\t  \tadd(num[v1.x][v1.y]+n*m,num[v0.x][v0.y],inf);\n\t  \tadd(num[v0.x][v0.y],num[v1.x][v1.y]+n*m,0);\n\t  }\n\tint cnt=0;\n\tfor(int i=1;i<=n;++i)\n\t  for(int j=1;j<=m;++j)\n\t  {\n\t  \tchar ch=getchar();\n\t  \twhile(ch!='.'&&ch!='L')  ch=getchar();\n\t  \tif(ch=='L')  ++cnt,add(0,num[i][j],1),add(num[i][j],0,0);  //连源点 \n\t  }\n\tint ans=0;\n\twhile(bfs())  ans+=dfs(0,inf);\n\tcout<<cnt-ans;\n\treturn 0;\n}\n```\n\n","slug":"solution-P2472-xi-yi","published":1,"updated":"2023-10-13T10:42:06.491Z","comments":1,"layout":"post","link":"","_id":"cloo2ivvp0007r8v312upbu62","content":"<p><a href=\"https://www.luogu.com.cn/problem/P2472\">P2472 [SCOI2007]蜥蜴</a></p>\n<p><strong>网络瘤，毒瘤的瘤。</strong></p>\n<p>蒟蒻第一次不看题解写出来网络瘤（<del>然而还是逃不过debug半天的命运</del>）。<img class=\"emoji-coda\" src=\"https://cdn.jsdelivr.net/gh/TomoriCoda/hexo-tag-emojis-bycoda/emojis/quyin/hematemesis.png\"></p>\n<h1 id=\"题意\"><a href=\"#题意\" class=\"headerlink\" title=\"题意\"></a>题意</h1><p>在 $r\\times c$ 的网格中，每个格子都有高度，高度为 $0$ 则不存在，一些格子上有蜥蜴，蜥蜴可以跳到直线距离不超过 $d$ 的格子上，每跳一次，原来的格子高度就会减一，求最少有几只蜥蜴不能逃离。</p>\n<h1 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h1><p>显然，每个格子跳了一定次数后就不能再跳了，那么如何在网络流中加入这个限制呢？</p>\n<p>假设原来的点编号为 $i$，高度为 $h$，总共 $n$ 个点，我们可以把这个点拆成两个，编号为 $i$ 和 $i+n$，$i$ 负责原来这个点的入边，$i+n$ 负责出边，再连一条从 $i$ 到 $i+n$ 容量为 $h$ 的边，如图：</p>\n<p><img src=\"https://img.imgdb.cn/item/6041e56b360785be54ee87f8.png\" alt=\"P2472\"></p>\n<p>这个思想类似于<a href=\"https://www.luogu.com.cn/problem/P1345\">最小割点问题</a>。</p>\n<h1 id=\"建图\"><a href=\"#建图\" class=\"headerlink\" title=\"建图\"></a>建图</h1><p><strong>注：以下说的点都是高度大于 $0$ 的点，高度为 $0$ 的点直接忽略。</strong></p>\n<ul>\n<li><p>对于每个点都将其拆为入点和出点，容量为格子高度。</p>\n</li>\n<li><p>对于能跳出网格的点，从它的出点到汇点连一条容量无穷大的边。</p>\n</li>\n<li><p>对于有蜥蜴的点，从源点到它的入点连一条容量为 $1$ 的边（因为每个点上最多有 $1$ 个蜥蜴）。</p>\n</li>\n</ul>\n<p>其中，源点和汇点都是原图中不存在的，需要另外新建。</p>\n<p>最后跑最大流，得到最多能逃离的蜥蜴数，用蜥蜴总数减去最大流即为所求答案。</p>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><pre><code class=\"lang-cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int mn=407,inf=1e7;\nstruct node&#123;\n    int x,y;\n&#125;;\nvector&lt;node&gt; p;\nint n,m,d,tot=0,num[27][27],q[2*mn],dep[2*mn];\nint fr[2*mn],fr2[2*mn],nx[100*mn],to[100*mn],val[100*mn],tt=1;\nvoid add(int x,int y,int w)\n&#123;\n    ++tt;\n    nx[tt]=fr[x];\n    fr[x]=tt;\n    to[tt]=y;\n    val[tt]=w;\n&#125;\nbool bfs()\n&#123;\n    for(int i=0;i&lt;=n*m*2+1;++i)  dep[i]=0,fr2[i]=fr[i];  //0 为源点，2*n*m+1 为汇点 \n    int h=1,t=1;\n    q[1]=0;dep[0]=1;\n    while(h&lt;=t)\n    &#123;\n        int u=q[h];\n        for(int i=fr[u];i;i=nx[i])\n        &#123;\n            int v=to[i];\n            if(dep[v]||!val[i])  continue;\n            q[++t]=v;\n            dep[v]=dep[u]+1;\n            if(v==n*m*2+1)  return 1;\n        &#125;\n        ++h;\n    &#125;\n    return 0;\n&#125;\nint dfs(int u,int in)\n&#123;\n    if(u==n*m*2+1)  return in;\n    int out=0;\n    for(int &amp;i=fr2[u];i;i=nx[i])  //当前弧优化，i 是引用，当 i 变化时 fr2 也会跟着变化 \n    &#123;\n        int v=to[i];\n        if(dep[u]==dep[v]-1&amp;&amp;val[i])\n        &#123;\n            int rs=dfs(v,val[i]&lt;in?val[i]:in);\n            val[i]-=rs;val[i^1]+=rs;\n            out+=rs;in-=rs;\n            if(!in)  break;\n        &#125;\n    &#125;\n    if(out==0)  dep[u]=0;\n    return out;\n&#125;\ninline int dist(node v0,node v1)&#123;return (v0.x-v1.x)*(v0.x-v1.x)+(v0.y-v1.y)*(v0.y-v1.y);&#125;  //求两点的直线距离 \nint main()\n&#123;\n    scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;d);\n    for(int i=1;i&lt;=n;++i)\n      for(int j=1;j&lt;=m;++j)\n      &#123;\n          num[i][j]=++tot;\n          int x;\n          scanf(&quot;%1d&quot;,&amp;x);\n          if(x==0)  continue;\n          add(num[i][j],num[i][j]+n*m,x);  //拆点 \n          add(num[i][j]+n*m,num[i][j],0);\n          p.push_back((node)&#123;i,j&#125;);\n          if(i-d&lt;1||j-d&lt;1||i+d&gt;n||j+d&gt;m)  add(num[i][j]+n*m,2*n*m+1,inf),add(2*n*m+1,num[i][j]+n*m,0);  //连汇点 \n      &#125;\n    for(int i=0;i&lt;p.size()-1;++i)  //建图 \n      for(int j=i+1;j&lt;p.size();++j)\n      &#123;\n          if(dist(p[i],p[j])&gt;d*d)  continue;\n          node v0=p[i],v1=p[j];\n          add(num[v0.x][v0.y]+n*m,num[v1.x][v1.y],inf);\n          add(num[v1.x][v1.y],num[v0.x][v0.y]+n*m,0);\n          add(num[v1.x][v1.y]+n*m,num[v0.x][v0.y],inf);\n          add(num[v0.x][v0.y],num[v1.x][v1.y]+n*m,0);\n      &#125;\n    int cnt=0;\n    for(int i=1;i&lt;=n;++i)\n      for(int j=1;j&lt;=m;++j)\n      &#123;\n          char ch=getchar();\n          while(ch!=&#39;.&#39;&amp;&amp;ch!=&#39;L&#39;)  ch=getchar();\n          if(ch==&#39;L&#39;)  ++cnt,add(0,num[i][j],1),add(num[i][j],0,0);  //连源点 \n      &#125;\n    int ans=0;\n    while(bfs())  ans+=dfs(0,inf);\n    cout&lt;&lt;cnt-ans;\n    return 0;\n&#125;\n</code></pre>\n<link rel=\"stylesheet\" href=\"/css/spoiler.css\" type=\"text/css\"><script src=\"/js/spoiler.js\" type=\"text/javascript\" async></script>","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://www.luogu.com.cn/problem/P2472\">P2472 [SCOI2007]蜥蜴</a></p>\n<p><strong>网络瘤，毒瘤的瘤。</strong></p>\n<p>蒟蒻第一次不看题解写出来网络瘤（<del>然而还是逃不过debug半天的命运</del>）。<img class=\"emoji-coda\" src=\"https://cdn.jsdelivr.net/gh/TomoriCoda/hexo-tag-emojis-bycoda/emojis/quyin/hematemesis.png\"></p>\n<h1 id=\"题意\"><a href=\"#题意\" class=\"headerlink\" title=\"题意\"></a>题意</h1><p>在 $r\\times c$ 的网格中，每个格子都有高度，高度为 $0$ 则不存在，一些格子上有蜥蜴，蜥蜴可以跳到直线距离不超过 $d$ 的格子上，每跳一次，原来的格子高度就会减一，求最少有几只蜥蜴不能逃离。</p>\n<h1 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h1><p>显然，每个格子跳了一定次数后就不能再跳了，那么如何在网络流中加入这个限制呢？</p>\n<p>假设原来的点编号为 $i$，高度为 $h$，总共 $n$ 个点，我们可以把这个点拆成两个，编号为 $i$ 和 $i+n$，$i$ 负责原来这个点的入边，$i+n$ 负责出边，再连一条从 $i$ 到 $i+n$ 容量为 $h$ 的边，如图：</p>\n<p><img src=\"https://img.imgdb.cn/item/6041e56b360785be54ee87f8.png\" alt=\"P2472\"></p>\n<p>这个思想类似于<a href=\"https://www.luogu.com.cn/problem/P1345\">最小割点问题</a>。</p>\n<h1 id=\"建图\"><a href=\"#建图\" class=\"headerlink\" title=\"建图\"></a>建图</h1><p><strong>注：以下说的点都是高度大于 $0$ 的点，高度为 $0$ 的点直接忽略。</strong></p>\n<ul>\n<li><p>对于每个点都将其拆为入点和出点，容量为格子高度。</p>\n</li>\n<li><p>对于能跳出网格的点，从它的出点到汇点连一条容量无穷大的边。</p>\n</li>\n<li><p>对于有蜥蜴的点，从源点到它的入点连一条容量为 $1$ 的边（因为每个点上最多有 $1$ 个蜥蜴）。</p>\n</li>\n</ul>\n<p>其中，源点和汇点都是原图中不存在的，需要另外新建。</p>\n<p>最后跑最大流，得到最多能逃离的蜥蜴数，用蜥蜴总数减去最大流即为所求答案。</p>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><pre><code class=\"lang-cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int mn=407,inf=1e7;\nstruct node&#123;\n    int x,y;\n&#125;;\nvector&lt;node&gt; p;\nint n,m,d,tot=0,num[27][27],q[2*mn],dep[2*mn];\nint fr[2*mn],fr2[2*mn],nx[100*mn],to[100*mn],val[100*mn],tt=1;\nvoid add(int x,int y,int w)\n&#123;\n    ++tt;\n    nx[tt]=fr[x];\n    fr[x]=tt;\n    to[tt]=y;\n    val[tt]=w;\n&#125;\nbool bfs()\n&#123;\n    for(int i=0;i&lt;=n*m*2+1;++i)  dep[i]=0,fr2[i]=fr[i];  //0 为源点，2*n*m+1 为汇点 \n    int h=1,t=1;\n    q[1]=0;dep[0]=1;\n    while(h&lt;=t)\n    &#123;\n        int u=q[h];\n        for(int i=fr[u];i;i=nx[i])\n        &#123;\n            int v=to[i];\n            if(dep[v]||!val[i])  continue;\n            q[++t]=v;\n            dep[v]=dep[u]+1;\n            if(v==n*m*2+1)  return 1;\n        &#125;\n        ++h;\n    &#125;\n    return 0;\n&#125;\nint dfs(int u,int in)\n&#123;\n    if(u==n*m*2+1)  return in;\n    int out=0;\n    for(int &amp;i=fr2[u];i;i=nx[i])  //当前弧优化，i 是引用，当 i 变化时 fr2 也会跟着变化 \n    &#123;\n        int v=to[i];\n        if(dep[u]==dep[v]-1&amp;&amp;val[i])\n        &#123;\n            int rs=dfs(v,val[i]&lt;in?val[i]:in);\n            val[i]-=rs;val[i^1]+=rs;\n            out+=rs;in-=rs;\n            if(!in)  break;\n        &#125;\n    &#125;\n    if(out==0)  dep[u]=0;\n    return out;\n&#125;\ninline int dist(node v0,node v1)&#123;return (v0.x-v1.x)*(v0.x-v1.x)+(v0.y-v1.y)*(v0.y-v1.y);&#125;  //求两点的直线距离 \nint main()\n&#123;\n    scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;d);\n    for(int i=1;i&lt;=n;++i)\n      for(int j=1;j&lt;=m;++j)\n      &#123;\n          num[i][j]=++tot;\n          int x;\n          scanf(&quot;%1d&quot;,&amp;x);\n          if(x==0)  continue;\n          add(num[i][j],num[i][j]+n*m,x);  //拆点 \n          add(num[i][j]+n*m,num[i][j],0);\n          p.push_back((node)&#123;i,j&#125;);\n          if(i-d&lt;1||j-d&lt;1||i+d&gt;n||j+d&gt;m)  add(num[i][j]+n*m,2*n*m+1,inf),add(2*n*m+1,num[i][j]+n*m,0);  //连汇点 \n      &#125;\n    for(int i=0;i&lt;p.size()-1;++i)  //建图 \n      for(int j=i+1;j&lt;p.size();++j)\n      &#123;\n          if(dist(p[i],p[j])&gt;d*d)  continue;\n          node v0=p[i],v1=p[j];\n          add(num[v0.x][v0.y]+n*m,num[v1.x][v1.y],inf);\n          add(num[v1.x][v1.y],num[v0.x][v0.y]+n*m,0);\n          add(num[v1.x][v1.y]+n*m,num[v0.x][v0.y],inf);\n          add(num[v0.x][v0.y],num[v1.x][v1.y]+n*m,0);\n      &#125;\n    int cnt=0;\n    for(int i=1;i&lt;=n;++i)\n      for(int j=1;j&lt;=m;++j)\n      &#123;\n          char ch=getchar();\n          while(ch!=&#39;.&#39;&amp;&amp;ch!=&#39;L&#39;)  ch=getchar();\n          if(ch==&#39;L&#39;)  ++cnt,add(0,num[i][j],1),add(num[i][j],0,0);  //连源点 \n      &#125;\n    int ans=0;\n    while(bfs())  ans+=dfs(0,inf);\n    cout&lt;&lt;cnt-ans;\n    return 0;\n&#125;\n</code></pre>\n"},{"author":"a154051","avatar":"https://a154051-img-1321592229.cos.ap-beijing.myqcloud.com/img/头像new.jpg","title":"【题解】P2467 [SDOI2010]地精部落","mathjax":true,"date":"2021-03-03T13:40:32.000Z","description":"前缀和优化DP","photos":["https://a154051-img-1321592229.cos.ap-beijing.myqcloud.com/img/03-03.jpg"],"_content":"\n[P2467 [SDOI2010]地精部落](https://www.luogu.com.cn/problem/P2467)\n\n# 题意\n\n给 $n$ 座高度连续的山脉，即高度为 $1,2,3,···,n$，求有几种方案使得山脉的高度一高一低或一低一高（即波动数列）。答案对 $p$ 取模。\n\n# 分析\n\n显然，若要求 $k$ 座山脉的波动数列，无论它们的高度是否连续，只要高度互不相同，方案数都是一样的。\n\n举个例子：求 $3$ 座山脉的波动数列，$(1,2,3)$ 和 $(1,3,5)$ 和 $(15,40,51)$的方案数都是一样的。\n\n定义 $f(i,j,0)$ 表示前 $i$ 座山脉中，排名为 $j$ 的山脉放在最后面并且是山谷的方案数（$1$ 表示是山峰）。则最后答案为 $\\sum_{j=1}^{n} f(n,j,0)+f(n,j,1)$。\n\n若 $j$ 是山谷，则方案为剩下的 $i-1$ 座山脉中排名从 $j$ 到 $i-1$ 的山脉放后面并且做山峰的方案之和。$j$ 是山峰也同理。\n\n所以有状态转移方程：\n\n$$f(i,j,1)=\\sum\\limits_{k=1}^{j-1}f(i-1,k,0)$$\n\n$$f(i,j,0)=\\sum\\limits_{k=j}^{i-1}f(i-1,k,1)$$\n\n时间复杂度为 $O(n^3)$，会超时。\n\n可以发现最里面一层循环可以用前缀和优化。\n\n定义 $sum0(i,j)=\\sum\\limits_{x=1}^{j}f(i,x,0)$，$sum1(i,j)$ 同理，则原转移方程可化为：\n\n$$f(i,j,1)=sum0(i-1,j-1)$$\n\n$$f(i,j,0)=sum1(i-1,i-1)-sum1(i-1,j-1)$$\n\n时间复杂度为 $O(n^2)$。\n\n因为 $f$ 和 $sum$ 只用到了当前一层和上一层，所以只存这两层就好，空间复杂度为 $O(n)$。\n\n# 代码\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nconst int mn=4207;\nlong long f[mn][2],sum0[2][mn],sum1[2][mn];\nint main()\n{\n\tint n,p;\n\tscanf(\"%d%d\",&n,&p);\n\tf[1][1]=f[1][0]=sum0[1][1]=sum1[1][1]=1;\n\tfor(int i=2;i<=n;++i)\n\t{\n\t\tint now=i&1;  //now为当前层，now^1为上一层。这里相当于 now=i%2 \n\t\tfor(int j=1;j<=i;++j)\n\t\t{\n\t\t\tf[j][1]=sum0[now^1][j-1];\n\t\t  \tf[j][0]=(sum1[now^1][i-1]-sum1[now^1][j-1])%p;\n\t\t  \twhile(f[j][0]<0)  f[j][0]+=p;  //避免取模后相减变为负数 \n\t\t  \tsum0[now][j]=(sum0[now][j-1]+f[j][0])%p;\n\t\t  \tsum1[now][j]=(sum1[now][j-1]+f[j][1])%p;\n\t\t}\n\t}\n\t  \n\tlong long ans=0;\n\tfor(int i=1;i<=n;++i)  ans=((ans+f[i][0])%p+f[i][1])%p;\n\tcout<<ans;\n} \n```\n\n","source":"_posts/solution-P2467-bu-luo.md","raw":"---\nauthor: a154051\navatar: https://a154051-img-1321592229.cos.ap-beijing.myqcloud.com/img/头像new.jpg\ntitle: 【题解】P2467 [SDOI2010]地精部落\nmathjax: true\ndate: 2021-03-03 21:40:32\ntags: \n - DP\ncategories: 题解\ndescription: 前缀和优化DP\nphotos: https://a154051-img-1321592229.cos.ap-beijing.myqcloud.com/img/03-03.jpg\n---\n\n[P2467 [SDOI2010]地精部落](https://www.luogu.com.cn/problem/P2467)\n\n# 题意\n\n给 $n$ 座高度连续的山脉，即高度为 $1,2,3,···,n$，求有几种方案使得山脉的高度一高一低或一低一高（即波动数列）。答案对 $p$ 取模。\n\n# 分析\n\n显然，若要求 $k$ 座山脉的波动数列，无论它们的高度是否连续，只要高度互不相同，方案数都是一样的。\n\n举个例子：求 $3$ 座山脉的波动数列，$(1,2,3)$ 和 $(1,3,5)$ 和 $(15,40,51)$的方案数都是一样的。\n\n定义 $f(i,j,0)$ 表示前 $i$ 座山脉中，排名为 $j$ 的山脉放在最后面并且是山谷的方案数（$1$ 表示是山峰）。则最后答案为 $\\sum_{j=1}^{n} f(n,j,0)+f(n,j,1)$。\n\n若 $j$ 是山谷，则方案为剩下的 $i-1$ 座山脉中排名从 $j$ 到 $i-1$ 的山脉放后面并且做山峰的方案之和。$j$ 是山峰也同理。\n\n所以有状态转移方程：\n\n$$f(i,j,1)=\\sum\\limits_{k=1}^{j-1}f(i-1,k,0)$$\n\n$$f(i,j,0)=\\sum\\limits_{k=j}^{i-1}f(i-1,k,1)$$\n\n时间复杂度为 $O(n^3)$，会超时。\n\n可以发现最里面一层循环可以用前缀和优化。\n\n定义 $sum0(i,j)=\\sum\\limits_{x=1}^{j}f(i,x,0)$，$sum1(i,j)$ 同理，则原转移方程可化为：\n\n$$f(i,j,1)=sum0(i-1,j-1)$$\n\n$$f(i,j,0)=sum1(i-1,i-1)-sum1(i-1,j-1)$$\n\n时间复杂度为 $O(n^2)$。\n\n因为 $f$ 和 $sum$ 只用到了当前一层和上一层，所以只存这两层就好，空间复杂度为 $O(n)$。\n\n# 代码\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nconst int mn=4207;\nlong long f[mn][2],sum0[2][mn],sum1[2][mn];\nint main()\n{\n\tint n,p;\n\tscanf(\"%d%d\",&n,&p);\n\tf[1][1]=f[1][0]=sum0[1][1]=sum1[1][1]=1;\n\tfor(int i=2;i<=n;++i)\n\t{\n\t\tint now=i&1;  //now为当前层，now^1为上一层。这里相当于 now=i%2 \n\t\tfor(int j=1;j<=i;++j)\n\t\t{\n\t\t\tf[j][1]=sum0[now^1][j-1];\n\t\t  \tf[j][0]=(sum1[now^1][i-1]-sum1[now^1][j-1])%p;\n\t\t  \twhile(f[j][0]<0)  f[j][0]+=p;  //避免取模后相减变为负数 \n\t\t  \tsum0[now][j]=(sum0[now][j-1]+f[j][0])%p;\n\t\t  \tsum1[now][j]=(sum1[now][j-1]+f[j][1])%p;\n\t\t}\n\t}\n\t  \n\tlong long ans=0;\n\tfor(int i=1;i<=n;++i)  ans=((ans+f[i][0])%p+f[i][1])%p;\n\tcout<<ans;\n} \n```\n\n","slug":"solution-P2467-bu-luo","published":1,"updated":"2023-10-13T10:42:06.491Z","comments":1,"layout":"post","link":"","_id":"cloo2ivvq0009r8v3dudr41ca","content":"<p><a href=\"https://www.luogu.com.cn/problem/P2467\">P2467 [SDOI2010]地精部落</a></p>\n<h1 id=\"题意\"><a href=\"#题意\" class=\"headerlink\" title=\"题意\"></a>题意</h1><p>给 $n$ 座高度连续的山脉，即高度为 $1,2,3,···,n$，求有几种方案使得山脉的高度一高一低或一低一高（即波动数列）。答案对 $p$ 取模。</p>\n<h1 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h1><p>显然，若要求 $k$ 座山脉的波动数列，无论它们的高度是否连续，只要高度互不相同，方案数都是一样的。</p>\n<p>举个例子：求 $3$ 座山脉的波动数列，$(1,2,3)$ 和 $(1,3,5)$ 和 $(15,40,51)$的方案数都是一样的。</p>\n<p>定义 $f(i,j,0)$ 表示前 $i$ 座山脉中，排名为 $j$ 的山脉放在最后面并且是山谷的方案数（$1$ 表示是山峰）。则最后答案为 $\\sum_{j=1}^{n} f(n,j,0)+f(n,j,1)$。</p>\n<p>若 $j$ 是山谷，则方案为剩下的 $i-1$ 座山脉中排名从 $j$ 到 $i-1$ 的山脉放后面并且做山峰的方案之和。$j$ 是山峰也同理。</p>\n<p>所以有状态转移方程：</p>\n<script type=\"math/tex; mode=display\">f(i,j,1)=\\sum\\limits_{k=1}^{j-1}f(i-1,k,0)</script><script type=\"math/tex; mode=display\">f(i,j,0)=\\sum\\limits_{k=j}^{i-1}f(i-1,k,1)</script><p>时间复杂度为 $O(n^3)$，会超时。</p>\n<p>可以发现最里面一层循环可以用前缀和优化。</p>\n<p>定义 $sum0(i,j)=\\sum\\limits_{x=1}^{j}f(i,x,0)$，$sum1(i,j)$ 同理，则原转移方程可化为：</p>\n<script type=\"math/tex; mode=display\">f(i,j,1)=sum0(i-1,j-1)</script><script type=\"math/tex; mode=display\">f(i,j,0)=sum1(i-1,i-1)-sum1(i-1,j-1)</script><p>时间复杂度为 $O(n^2)$。</p>\n<p>因为 $f$ 和 $sum$ 只用到了当前一层和上一层，所以只存这两层就好，空间复杂度为 $O(n)$。</p>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><pre><code class=\"lang-cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int mn=4207;\nlong long f[mn][2],sum0[2][mn],sum1[2][mn];\nint main()\n&#123;\n    int n,p;\n    scanf(&quot;%d%d&quot;,&amp;n,&amp;p);\n    f[1][1]=f[1][0]=sum0[1][1]=sum1[1][1]=1;\n    for(int i=2;i&lt;=n;++i)\n    &#123;\n        int now=i&amp;1;  //now为当前层，now^1为上一层。这里相当于 now=i%2 \n        for(int j=1;j&lt;=i;++j)\n        &#123;\n            f[j][1]=sum0[now^1][j-1];\n              f[j][0]=(sum1[now^1][i-1]-sum1[now^1][j-1])%p;\n              while(f[j][0]&lt;0)  f[j][0]+=p;  //避免取模后相减变为负数 \n              sum0[now][j]=(sum0[now][j-1]+f[j][0])%p;\n              sum1[now][j]=(sum1[now][j-1]+f[j][1])%p;\n        &#125;\n    &#125;\n\n    long long ans=0;\n    for(int i=1;i&lt;=n;++i)  ans=((ans+f[i][0])%p+f[i][1])%p;\n    cout&lt;&lt;ans;\n&#125;\n</code></pre>\n<link rel=\"stylesheet\" href=\"/css/spoiler.css\" type=\"text/css\"><script src=\"/js/spoiler.js\" type=\"text/javascript\" async></script>","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://www.luogu.com.cn/problem/P2467\">P2467 [SDOI2010]地精部落</a></p>\n<h1 id=\"题意\"><a href=\"#题意\" class=\"headerlink\" title=\"题意\"></a>题意</h1><p>给 $n$ 座高度连续的山脉，即高度为 $1,2,3,···,n$，求有几种方案使得山脉的高度一高一低或一低一高（即波动数列）。答案对 $p$ 取模。</p>\n<h1 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h1><p>显然，若要求 $k$ 座山脉的波动数列，无论它们的高度是否连续，只要高度互不相同，方案数都是一样的。</p>\n<p>举个例子：求 $3$ 座山脉的波动数列，$(1,2,3)$ 和 $(1,3,5)$ 和 $(15,40,51)$的方案数都是一样的。</p>\n<p>定义 $f(i,j,0)$ 表示前 $i$ 座山脉中，排名为 $j$ 的山脉放在最后面并且是山谷的方案数（$1$ 表示是山峰）。则最后答案为 $\\sum_{j=1}^{n} f(n,j,0)+f(n,j,1)$。</p>\n<p>若 $j$ 是山谷，则方案为剩下的 $i-1$ 座山脉中排名从 $j$ 到 $i-1$ 的山脉放后面并且做山峰的方案之和。$j$ 是山峰也同理。</p>\n<p>所以有状态转移方程：</p>\n<script type=\"math/tex; mode=display\">f(i,j,1)=\\sum\\limits_{k=1}^{j-1}f(i-1,k,0)</script><script type=\"math/tex; mode=display\">f(i,j,0)=\\sum\\limits_{k=j}^{i-1}f(i-1,k,1)</script><p>时间复杂度为 $O(n^3)$，会超时。</p>\n<p>可以发现最里面一层循环可以用前缀和优化。</p>\n<p>定义 $sum0(i,j)=\\sum\\limits_{x=1}^{j}f(i,x,0)$，$sum1(i,j)$ 同理，则原转移方程可化为：</p>\n<script type=\"math/tex; mode=display\">f(i,j,1)=sum0(i-1,j-1)</script><script type=\"math/tex; mode=display\">f(i,j,0)=sum1(i-1,i-1)-sum1(i-1,j-1)</script><p>时间复杂度为 $O(n^2)$。</p>\n<p>因为 $f$ 和 $sum$ 只用到了当前一层和上一层，所以只存这两层就好，空间复杂度为 $O(n)$。</p>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><pre><code class=\"lang-cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int mn=4207;\nlong long f[mn][2],sum0[2][mn],sum1[2][mn];\nint main()\n&#123;\n    int n,p;\n    scanf(&quot;%d%d&quot;,&amp;n,&amp;p);\n    f[1][1]=f[1][0]=sum0[1][1]=sum1[1][1]=1;\n    for(int i=2;i&lt;=n;++i)\n    &#123;\n        int now=i&amp;1;  //now为当前层，now^1为上一层。这里相当于 now=i%2 \n        for(int j=1;j&lt;=i;++j)\n        &#123;\n            f[j][1]=sum0[now^1][j-1];\n              f[j][0]=(sum1[now^1][i-1]-sum1[now^1][j-1])%p;\n              while(f[j][0]&lt;0)  f[j][0]+=p;  //避免取模后相减变为负数 \n              sum0[now][j]=(sum0[now][j-1]+f[j][0])%p;\n              sum1[now][j]=(sum1[now][j-1]+f[j][1])%p;\n        &#125;\n    &#125;\n\n    long long ans=0;\n    for(int i=1;i&lt;=n;++i)  ans=((ans+f[i][0])%p+f[i][1])%p;\n    cout&lt;&lt;ans;\n&#125;\n</code></pre>\n"},{"author":"a154051","avatar":"https://a154051-img-1321592229.cos.ap-beijing.myqcloud.com/img/头像new.jpg","title":"【题解】P3291 [SCOI2016]妖怪","mathjax":true,"date":"2021-09-01T12:11:16.000Z","description":"玄学又好用的模拟退火","keywords":["P3291","SCOI2016"],"photos":["https://a154051-img-1321592229.cos.ap-beijing.myqcloud.com/img/9-1.jpg"],"_content":"\n蒟蒻不会凸包，于是用**模拟退火**过了这道题。\n\n如果你还不会模拟退火，可以看看我之前写的[学习笔记](https://a154051.gitee.io/2021/02/08/mo-ni-tui-huo-bi-ji/)。\n\n## 题意\n\n来自[辰星凌的题解](https://www.luogu.com.cn/blog/ChenXingLing/solution-p3291)：\n\n> 给出 $n$ 个点 $(x_i,y_i)$，设 $f_i(a,b)=x_i+y_i+\\frac{bx_i}{a}+\\frac{ay_i}{b}$，求出一组 $(a,b)$，使得 $\\max\\{f_{i\\in[1,n]}(a,b)\\}$ 最小，输出这个最小值。\n\n## 做法\n\n正常模拟退火流程，每次随机生成两个数 $(a,b)$，暴力遍历一遍所有点计算出当前的答案，与上一次的答案比较。\n\n蒟蒻一开始只是想骗点分，没想到拿了 $80$ 分，于是就进入了痛苦的调参过程。（注：没有在洛谷提交，洛谷数据不全。）\n\n最初提交时总是第 $7$ 个点错，后来有一次分比较低，但是第 $7$ 个点对了，我比较了一下认为是初始温度的问题，初始温度低会导致生成出来的数的范围小，而那个点最优情况下的 $(a,b)$ 大于这个范围，所以就一直错。\n\n于是稍微修改一下参数就 $A$ 了，最后一共提交了 $172$ 次...\n\n不开 $O2$ 会 $T$，时间复杂度 $O(\\text{玄学})$。\n\n## 代码\n\n```cpp\n#include <bits/stdc++.h>\n#define rd t*(rand()*2-RAND_MAX)\n#define max(x,y) (x<y?y:x)  //这里是个小优化，会快一点\nusing namespace std;\ntypedef long long ll;\nconst double eps=1e-6,down=0.89;\nconst int mn=1e6+7;\nint n;\ndouble x[mn],y[mn];\ndouble sol(double a,double b)  \n{\n    double rs=0;\n    for(int i=1;i<=n;++i)\n    {\n        double tmp=x[i]+y[i]+x[i]/a*b+y[i]/b*a;\n        rs=max(rs,tmp);\n    }\n    return rs;\n}\nint main()\n{\n    srand(154051);\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;++i)  scanf(\"%lf%lf\",&x[i],&y[i]);\n    ll a=1,b=1;\n    double ans,minn;\n    minn=ans=sol(1,1);\n    for(double t=1100000;t>eps;t*=down)\n    {\n        ll aa=a+rd,bb=b+rd;  \n        if(aa==0)  aa++;\n        if(bb==0)  bb++;\n        if(aa<0)  aa=-aa;\n        if(bb<0)  bb=-bb;\n        double rs=sol(aa,bb);  \n        if(minn>rs)  minn=rs;\n        if(rs<ans||exp((ans-rs)/t)*RAND_MAX>rand())  \n        {\n            ans=rs;\n            a=aa;b=bb;\n        }\n    }\n    printf(\"%.4f\",minn);\n    return 0;\n}\n```\n","source":"_posts/solution-P3291-yao-guai.md","raw":"---\nauthor: a154051\navatar: 'https://a154051-img-1321592229.cos.ap-beijing.myqcloud.com/img/头像new.jpg'\ntitle: 【题解】P3291 [SCOI2016]妖怪\ntags:\n  - 模拟退火\nmathjax: true\ndate: 2021-09-01 20:11:16\ncategories: 题解\ndescription: 玄学又好用的模拟退火\nkeywords: \n  - P3291\n  - SCOI2016\nphotos: https://a154051-img-1321592229.cos.ap-beijing.myqcloud.com/img/9-1.jpg\n---\n\n蒟蒻不会凸包，于是用**模拟退火**过了这道题。\n\n如果你还不会模拟退火，可以看看我之前写的[学习笔记](https://a154051.gitee.io/2021/02/08/mo-ni-tui-huo-bi-ji/)。\n\n## 题意\n\n来自[辰星凌的题解](https://www.luogu.com.cn/blog/ChenXingLing/solution-p3291)：\n\n> 给出 $n$ 个点 $(x_i,y_i)$，设 $f_i(a,b)=x_i+y_i+\\frac{bx_i}{a}+\\frac{ay_i}{b}$，求出一组 $(a,b)$，使得 $\\max\\{f_{i\\in[1,n]}(a,b)\\}$ 最小，输出这个最小值。\n\n## 做法\n\n正常模拟退火流程，每次随机生成两个数 $(a,b)$，暴力遍历一遍所有点计算出当前的答案，与上一次的答案比较。\n\n蒟蒻一开始只是想骗点分，没想到拿了 $80$ 分，于是就进入了痛苦的调参过程。（注：没有在洛谷提交，洛谷数据不全。）\n\n最初提交时总是第 $7$ 个点错，后来有一次分比较低，但是第 $7$ 个点对了，我比较了一下认为是初始温度的问题，初始温度低会导致生成出来的数的范围小，而那个点最优情况下的 $(a,b)$ 大于这个范围，所以就一直错。\n\n于是稍微修改一下参数就 $A$ 了，最后一共提交了 $172$ 次...\n\n不开 $O2$ 会 $T$，时间复杂度 $O(\\text{玄学})$。\n\n## 代码\n\n```cpp\n#include <bits/stdc++.h>\n#define rd t*(rand()*2-RAND_MAX)\n#define max(x,y) (x<y?y:x)  //这里是个小优化，会快一点\nusing namespace std;\ntypedef long long ll;\nconst double eps=1e-6,down=0.89;\nconst int mn=1e6+7;\nint n;\ndouble x[mn],y[mn];\ndouble sol(double a,double b)  \n{\n    double rs=0;\n    for(int i=1;i<=n;++i)\n    {\n        double tmp=x[i]+y[i]+x[i]/a*b+y[i]/b*a;\n        rs=max(rs,tmp);\n    }\n    return rs;\n}\nint main()\n{\n    srand(154051);\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;++i)  scanf(\"%lf%lf\",&x[i],&y[i]);\n    ll a=1,b=1;\n    double ans,minn;\n    minn=ans=sol(1,1);\n    for(double t=1100000;t>eps;t*=down)\n    {\n        ll aa=a+rd,bb=b+rd;  \n        if(aa==0)  aa++;\n        if(bb==0)  bb++;\n        if(aa<0)  aa=-aa;\n        if(bb<0)  bb=-bb;\n        double rs=sol(aa,bb);  \n        if(minn>rs)  minn=rs;\n        if(rs<ans||exp((ans-rs)/t)*RAND_MAX>rand())  \n        {\n            ans=rs;\n            a=aa;b=bb;\n        }\n    }\n    printf(\"%.4f\",minn);\n    return 0;\n}\n```\n","slug":"solution-P3291-yao-guai","published":1,"updated":"2023-10-13T10:42:06.494Z","comments":1,"layout":"post","link":"","_id":"cloo2ivvs000br8v3bcac6oz2","content":"<p>蒟蒻不会凸包，于是用<strong>模拟退火</strong>过了这道题。</p>\n<p>如果你还不会模拟退火，可以看看我之前写的<a href=\"https://a154051.gitee.io/2021/02/08/mo-ni-tui-huo-bi-ji/\">学习笔记</a>。</p>\n<h2 id=\"题意\"><a href=\"#题意\" class=\"headerlink\" title=\"题意\"></a>题意</h2><p>来自<a href=\"https://www.luogu.com.cn/blog/ChenXingLing/solution-p3291\">辰星凌的题解</a>：</p>\n<blockquote>\n<p>给出 $n$ 个点 $(x_i,y_i)$，设 $f_i(a,b)=x_i+y_i+\\frac{bx_i}{a}+\\frac{ay_i}{b}$，求出一组 $(a,b)$，使得 $\\max\\{f_{i\\in[1,n]}(a,b)\\}$ 最小，输出这个最小值。</p>\n</blockquote>\n<h2 id=\"做法\"><a href=\"#做法\" class=\"headerlink\" title=\"做法\"></a>做法</h2><p>正常模拟退火流程，每次随机生成两个数 $(a,b)$，暴力遍历一遍所有点计算出当前的答案，与上一次的答案比较。</p>\n<p>蒟蒻一开始只是想骗点分，没想到拿了 $80$ 分，于是就进入了痛苦的调参过程。（注：没有在洛谷提交，洛谷数据不全。）</p>\n<p>最初提交时总是第 $7$ 个点错，后来有一次分比较低，但是第 $7$ 个点对了，我比较了一下认为是初始温度的问题，初始温度低会导致生成出来的数的范围小，而那个点最优情况下的 $(a,b)$ 大于这个范围，所以就一直错。</p>\n<p>于是稍微修改一下参数就 $A$ 了，最后一共提交了 $172$ 次…</p>\n<p>不开 $O2$ 会 $T$，时间复杂度 $O(\\text{玄学})$。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><pre><code class=\"lang-cpp\">#include &lt;bits/stdc++.h&gt;\n#define rd t*(rand()*2-RAND_MAX)\n#define max(x,y) (x&lt;y?y:x)  //这里是个小优化，会快一点\nusing namespace std;\ntypedef long long ll;\nconst double eps=1e-6,down=0.89;\nconst int mn=1e6+7;\nint n;\ndouble x[mn],y[mn];\ndouble sol(double a,double b)  \n&#123;\n    double rs=0;\n    for(int i=1;i&lt;=n;++i)\n    &#123;\n        double tmp=x[i]+y[i]+x[i]/a*b+y[i]/b*a;\n        rs=max(rs,tmp);\n    &#125;\n    return rs;\n&#125;\nint main()\n&#123;\n    srand(154051);\n    scanf(&quot;%d&quot;,&amp;n);\n    for(int i=1;i&lt;=n;++i)  scanf(&quot;%lf%lf&quot;,&amp;x[i],&amp;y[i]);\n    ll a=1,b=1;\n    double ans,minn;\n    minn=ans=sol(1,1);\n    for(double t=1100000;t&gt;eps;t*=down)\n    &#123;\n        ll aa=a+rd,bb=b+rd;  \n        if(aa==0)  aa++;\n        if(bb==0)  bb++;\n        if(aa&lt;0)  aa=-aa;\n        if(bb&lt;0)  bb=-bb;\n        double rs=sol(aa,bb);  \n        if(minn&gt;rs)  minn=rs;\n        if(rs&lt;ans||exp((ans-rs)/t)*RAND_MAX&gt;rand())  \n        &#123;\n            ans=rs;\n            a=aa;b=bb;\n        &#125;\n    &#125;\n    printf(&quot;%.4f&quot;,minn);\n    return 0;\n&#125;\n</code></pre>\n<link rel=\"stylesheet\" href=\"/css/spoiler.css\" type=\"text/css\"><script src=\"/js/spoiler.js\" type=\"text/javascript\" async></script>","site":{"data":{}},"excerpt":"","more":"<p>蒟蒻不会凸包，于是用<strong>模拟退火</strong>过了这道题。</p>\n<p>如果你还不会模拟退火，可以看看我之前写的<a href=\"https://a154051.gitee.io/2021/02/08/mo-ni-tui-huo-bi-ji/\">学习笔记</a>。</p>\n<h2 id=\"题意\"><a href=\"#题意\" class=\"headerlink\" title=\"题意\"></a>题意</h2><p>来自<a href=\"https://www.luogu.com.cn/blog/ChenXingLing/solution-p3291\">辰星凌的题解</a>：</p>\n<blockquote>\n<p>给出 $n$ 个点 $(x_i,y_i)$，设 $f_i(a,b)=x_i+y_i+\\frac{bx_i}{a}+\\frac{ay_i}{b}$，求出一组 $(a,b)$，使得 $\\max\\{f_{i\\in[1,n]}(a,b)\\}$ 最小，输出这个最小值。</p>\n</blockquote>\n<h2 id=\"做法\"><a href=\"#做法\" class=\"headerlink\" title=\"做法\"></a>做法</h2><p>正常模拟退火流程，每次随机生成两个数 $(a,b)$，暴力遍历一遍所有点计算出当前的答案，与上一次的答案比较。</p>\n<p>蒟蒻一开始只是想骗点分，没想到拿了 $80$ 分，于是就进入了痛苦的调参过程。（注：没有在洛谷提交，洛谷数据不全。）</p>\n<p>最初提交时总是第 $7$ 个点错，后来有一次分比较低，但是第 $7$ 个点对了，我比较了一下认为是初始温度的问题，初始温度低会导致生成出来的数的范围小，而那个点最优情况下的 $(a,b)$ 大于这个范围，所以就一直错。</p>\n<p>于是稍微修改一下参数就 $A$ 了，最后一共提交了 $172$ 次…</p>\n<p>不开 $O2$ 会 $T$，时间复杂度 $O(\\text{玄学})$。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><pre><code class=\"lang-cpp\">#include &lt;bits/stdc++.h&gt;\n#define rd t*(rand()*2-RAND_MAX)\n#define max(x,y) (x&lt;y?y:x)  //这里是个小优化，会快一点\nusing namespace std;\ntypedef long long ll;\nconst double eps=1e-6,down=0.89;\nconst int mn=1e6+7;\nint n;\ndouble x[mn],y[mn];\ndouble sol(double a,double b)  \n&#123;\n    double rs=0;\n    for(int i=1;i&lt;=n;++i)\n    &#123;\n        double tmp=x[i]+y[i]+x[i]/a*b+y[i]/b*a;\n        rs=max(rs,tmp);\n    &#125;\n    return rs;\n&#125;\nint main()\n&#123;\n    srand(154051);\n    scanf(&quot;%d&quot;,&amp;n);\n    for(int i=1;i&lt;=n;++i)  scanf(&quot;%lf%lf&quot;,&amp;x[i],&amp;y[i]);\n    ll a=1,b=1;\n    double ans,minn;\n    minn=ans=sol(1,1);\n    for(double t=1100000;t&gt;eps;t*=down)\n    &#123;\n        ll aa=a+rd,bb=b+rd;  \n        if(aa==0)  aa++;\n        if(bb==0)  bb++;\n        if(aa&lt;0)  aa=-aa;\n        if(bb&lt;0)  bb=-bb;\n        double rs=sol(aa,bb);  \n        if(minn&gt;rs)  minn=rs;\n        if(rs&lt;ans||exp((ans-rs)/t)*RAND_MAX&gt;rand())  \n        &#123;\n            ans=rs;\n            a=aa;b=bb;\n        &#125;\n    &#125;\n    printf(&quot;%.4f&quot;,minn);\n    return 0;\n&#125;\n</code></pre>\n"},{"author":"a154051","avatar":"https://a154051-img-1321592229.cos.ap-beijing.myqcloud.com/img/头像new.jpg","title":"【题解】P3761 [TJOI2017]城市","mathjax":true,"date":"2021-08-08T12:31:36.000Z","description":"证明了O(n)做法","keywords":"P3761","photos":["https://a154051-img-1321592229.cos.ap-beijing.myqcloud.com/img/8-8_2.jpg"],"_content":"[P3761 [TJOI2017]城市](https://www.luogu.com.cn/problem/P3761)\n\n**前排提醒：本文着重证明了 $O(n)$ 的做法，$O(n^2)$ 的做法讲得不是很明白。**\n\n## 题意\n\n给一颗有边权的树，删去一条边并加上一条权值相同的边（要求操作后还是一颗树），求树的直径最小是多少。\n\n$n\\le 5000$。\n\n## 题解\n\n很妙的一道题，主要难点在于结论的寻找和证明。\n\n最朴素的做法是枚举每条要删除的边，整棵树被分为了两颗子树，再枚举两颗子树上选的点，计算直径。时间复杂度 $O(n^4)$。\n\n### $O(n^2)$ 做法\n\n新加入一条边后，新树的直径有两种情况：\n\n* 直径在分出来的两颗树中的一个。\n\n* 直径经过了新加入的边。\n\n对于第一种情况，新加入的边不会产生影响。\n\n对于第二种情况，要想办法连边使得新树的直径最小。可以发现两棵树要连的点都是树的中心（即该点到其他节点的最远距离最小）。\n\n考虑 $DP$，第一遍 $\\text{dfs}$ 求出在该节点子树内从它出发的最远和次远距离。\n\n第二遍 $\\text{dfs}$ 根据父亲的信息求出在整棵树中从该节点出发的最远和次远距离，在这个过程中找出树的中心。\n\n所以优化后的做法为枚举每条要删除的边，求出分出来的两颗树的直径和中心，比较这三个值，取最大。时间复杂度 $O(n^2)$。\n\n这个复杂度已经可以通过这道题了，但是还能继续优化到 $O(n)$。\n\n### $O(n)$ 做法\n\n\n时间复杂度的瓶颈主要在 $DP$，考虑优化。\n\n**结论一：树的中心是树的直径的（带权）中点。**\n\n证明：\n\n* 对于直径上任意一点 $u$，显然从 $u$ 出发的最远路径一定在直径上，若要求直径中心则只需比较 $u$ 到直径两端的最远距离，所以直径中点 $mid$ 是该直径的中心。\n\n* 对于不在直径上的点 $v$，从 $v$ 出发到 $mid$，再到直径较远一端的所走路程，必然比直接从 $mid$ 出发的所走路程远。根据定义，树的中心要到其他点的最远距离最小，所以 $v$ 不是树的中心。\n\n综上，$mid$ 是树的中心。证毕。\n\n问题就转化为了如何求树的直径的中点。\n\n对于删边操作，可以发现只有删原树直径上的边才有意义，因为删其他边直径没有变。\n\n所以从直径一端出发到另一端依次删除边。但是每次都要遍历整棵树求直径中点，时间复杂度还是没有变，考虑优化。\n\n以下只针对删边后的两颗树中的一个分析，另一个同理。\n\n**结论二：对于一颗分割出来的树，它直径的一端一定是原树直径的一端。**\n\n证明：\n\n反证法，如图，\n\n![](https://pic.imgdb.cn/item/610f4e4b5132923bf8ccee00.png)\n\n删边后得到了以 $C$ 为根的子树，假设 $EF$ 该树的直径，说明 $\\text{dis}(E,F)>\\text{dis}(A,B)$，$\\text{dis}(E,F)+\\text{dis}(B,E)>\\text{dis}(A,B)$，则 $FD$ 比 $AD$ 更长，与 $AD$ 是原树直径矛盾，该假设不成立，所以 $A$ 一定是删边后树的直径的一端。证毕。\n\n考虑如何快速维护删边后树的直径：\n\n（图片来自[getchar123的题解](https://www.luogu.com.cn/blog/getchar123/solution-p3761)）\n\n![](https://pic.imgdb.cn/item/610f59395132923bf8db329e.png)\n\n（橙色为截掉的边，绿色为直径，右图紫色的点为重复遍历的点，红色为新遍历的点）\n\n在遍历删边的过程中，如果每次都遍历整棵树，会有大量重复节点（紫色点），根据结论二，我们只需要考虑经过新加进来的 原树直径上的点 能否得到更长的路径。\n\n即从 $10$ 号点出发遍历红色点，找到最长路径，加上 $\\text{dis}(1,10)$，与原来的直径比较。\n\n这样每次都只需要遍历新加进来的节点，维护直径的总时间复杂度优化到了 $O(n)$。\n\n但是每次维护直径中点都要遍历一遍直径，时间复杂度还是 $O(n^2)$，继续优化。\n\n**结论三：对于分割出来的树，它的直径中点一定在原树直径上。**\n\n证明：\n\n如图，删边后的树的直径一定是形如这个样子，\n\n![](https://pic.imgdb.cn/item/610f5e3d5132923bf8e19add.png)\n\n分割出来的树的直径和原树的直径的重叠部分一定大于非重叠部分，即 $\\text{dis}(A,B)>\\text{dis}(E,B)$，如果不是，则路径 $ED$ 就会比原树直径还长。\n\n根据直径中点的定义，中点一定在路径 $AB$ 上。证毕。\n\n可以发现删边过程中，分割出来的树的直径是不下降的，新树和原树的重叠部分也是不下降的。\n\n所以每次只需要从上一次的中点开始，在原树直径上向后遍历，直到当前点比上一个点劣时停止（再往后只会更劣）。维护中点的总时间复杂度为 $O(n)$。\n\n综上，该算法的时间复杂度为 $O(n)$。\n\n这里只维护了分割出来的其中一棵树，对于另一棵树可以倒过来重复这些操作。\n\n## 代码\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nconst int mn=5e3+7;\nstruct node {\n    int mid,len_L,len_R;  //分别是中点，直径，半径（中点到其他点的最远距离）\n}ans[3][mn];\nint tt=0,fr[mn],nx[mn*2],to[mn*2],w[mn*2];\nint rt=1,rt2=1,maxlen=0,d[mn],mx=0;\nint q[mn],top=0;  //存直径上所有点\nbool vis[mn];\nvoid add(int x,int y,int v)\n{\n    ++tt;\n    nx[tt]=fr[x];\n    fr[x]=tt;\n    to[tt]=y;\n    w[tt]=v;\n}\nvoid findrt(int x,int fa,int dis)\n{\n    if(dis>maxlen)  maxlen=dis,rt=x;\n    for(int i=fr[x];i;i=nx[i])\n      if(to[i]!=fa)  findrt(to[i],x,dis+w[i]);\n}\nvoid findrt2(int x,int fa,int dis)\n{\n    d[x]=dis;\n    if(dis>maxlen)  maxlen=dis,rt2=x;\n    for(int i=fr[x];i;i=nx[i])\n      if(to[i]!=fa)  findrt2(to[i],x,dis+w[i]);\n}\nvoid deep(int x,int fa,int dis)\n{\n    d[x]=dis;\n    for(int i=fr[x];i;i=nx[i])\n      if(to[i]!=fa)  deep(to[i],x,dis+w[i]);\n}\nbool dfs(int x,int fa,int dis)\n{\n    q[++top]=x;\n    \n    if(x==rt2)  return 1;\n    for(int i=fr[x];i;i=nx[i])\n    {\n        int y=to[i];\n        if(y==fa)  continue;\n        bool flag=dfs(y,x,dis+w[i]);\n        if(flag)  return 1;\n    }\n    --top;\n    return 0;\n}\nvoid dfs2(int x,int dis)\n{\n    vis[x]=1;\n    mx=max(mx,dis);\n    for(int i=fr[x];i;i=nx[i])\n    {\n        int y=to[i];\n        if(vis[y])  continue;\n        dfs2(y,dis+w[i]);\n    }\n}\nvoid sol(int k)\n{\n    memset(vis,0,sizeof(vis));\n    for(int i=1;i<=top;++i)  vis[q[i]]=1;\n    int mid=1,len_L=0,len_R=0;\n    ans[k][1]=(node){mid,len_L,len_R};\n    for(int i=2;i<top;++i)\n    {\n        mx=0;\n        dfs2(q[i],0);  //遍历新加进来的节点\n        if(d[q[i]]-d[q[1]]+mx<=len_L)\n            ans[k][i]=(node){mid,len_L,len_R};\n        else\n        {\n            len_L=d[q[i]]-d[q[1]]+mx;\n            len_R=max(d[q[mid]]-d[q[1]],len_L-d[q[mid]]-d[q[1]]);\n            for(int j=mid+1;j<=i;++j)\n            {\n                int dis=max(d[q[j]]-d[q[1]],len_L-d[q[j]]-d[q[1]]);\n                if(dis>len_R)  break;  //这里就直接跳出，后面只会更劣\n                len_R=dis;mid=j;\n            }\n            ans[k][i]=(node){mid,len_L,len_R};\n        }\n    }\n}\nint main()\n{\n    int n;\n    cin>>n;\n    for(int i=1;i<n;++i)\n    {\n        int x,y,v;\n        scanf(\"%d%d%d\",&x,&y,&v);\n        add(x,y,v);\n        add(y,x,v);\n    }\n    findrt(1,0,0);  //找直径一端\n    maxlen=0;\n    findrt2(rt,0,0);  //找另一端\n    maxlen=0;\n    dfs(rt,0,0);  //存直径\n    sol(1);\n/***************以下为倒过来处理另一棵树***************/\n    memset(d,0,sizeof(d));\n    top=0;\n    swap(rt,rt2);\n    deep(rt,0,0);  //根变了，深度也要重新求\n    dfs(rt,0,0);\n    sol(2);\n\n    int ANS=1e9;\n    for(int i=1;i<top;++i)\n      ANS=min(ANS,max(d[q[i+1]]-d[q[i]]+ans[2][i].len_R+ans[1][top-i].len_R,max(ans[2][i].len_L,ans[1][top-i].len_L)));\n    cout<<ANS;\n    return 0;\n}\n```\n","source":"_posts/solution-P3761-city.md","raw":"---\nauthor: a154051\navatar: 'https://a154051-img-1321592229.cos.ap-beijing.myqcloud.com/img/头像new.jpg'\ntitle: 【题解】P3761 [TJOI2017]城市\ntags:\n  - 树\nmathjax: true\ndate: 2021-08-08 20:31:36\ncategories: 题解\ndescription: 证明了O(n)做法\nkeywords: P3761\nphotos: https://a154051-img-1321592229.cos.ap-beijing.myqcloud.com/img/8-8_2.jpg\n---\n[P3761 [TJOI2017]城市](https://www.luogu.com.cn/problem/P3761)\n\n**前排提醒：本文着重证明了 $O(n)$ 的做法，$O(n^2)$ 的做法讲得不是很明白。**\n\n## 题意\n\n给一颗有边权的树，删去一条边并加上一条权值相同的边（要求操作后还是一颗树），求树的直径最小是多少。\n\n$n\\le 5000$。\n\n## 题解\n\n很妙的一道题，主要难点在于结论的寻找和证明。\n\n最朴素的做法是枚举每条要删除的边，整棵树被分为了两颗子树，再枚举两颗子树上选的点，计算直径。时间复杂度 $O(n^4)$。\n\n### $O(n^2)$ 做法\n\n新加入一条边后，新树的直径有两种情况：\n\n* 直径在分出来的两颗树中的一个。\n\n* 直径经过了新加入的边。\n\n对于第一种情况，新加入的边不会产生影响。\n\n对于第二种情况，要想办法连边使得新树的直径最小。可以发现两棵树要连的点都是树的中心（即该点到其他节点的最远距离最小）。\n\n考虑 $DP$，第一遍 $\\text{dfs}$ 求出在该节点子树内从它出发的最远和次远距离。\n\n第二遍 $\\text{dfs}$ 根据父亲的信息求出在整棵树中从该节点出发的最远和次远距离，在这个过程中找出树的中心。\n\n所以优化后的做法为枚举每条要删除的边，求出分出来的两颗树的直径和中心，比较这三个值，取最大。时间复杂度 $O(n^2)$。\n\n这个复杂度已经可以通过这道题了，但是还能继续优化到 $O(n)$。\n\n### $O(n)$ 做法\n\n\n时间复杂度的瓶颈主要在 $DP$，考虑优化。\n\n**结论一：树的中心是树的直径的（带权）中点。**\n\n证明：\n\n* 对于直径上任意一点 $u$，显然从 $u$ 出发的最远路径一定在直径上，若要求直径中心则只需比较 $u$ 到直径两端的最远距离，所以直径中点 $mid$ 是该直径的中心。\n\n* 对于不在直径上的点 $v$，从 $v$ 出发到 $mid$，再到直径较远一端的所走路程，必然比直接从 $mid$ 出发的所走路程远。根据定义，树的中心要到其他点的最远距离最小，所以 $v$ 不是树的中心。\n\n综上，$mid$ 是树的中心。证毕。\n\n问题就转化为了如何求树的直径的中点。\n\n对于删边操作，可以发现只有删原树直径上的边才有意义，因为删其他边直径没有变。\n\n所以从直径一端出发到另一端依次删除边。但是每次都要遍历整棵树求直径中点，时间复杂度还是没有变，考虑优化。\n\n以下只针对删边后的两颗树中的一个分析，另一个同理。\n\n**结论二：对于一颗分割出来的树，它直径的一端一定是原树直径的一端。**\n\n证明：\n\n反证法，如图，\n\n![](https://pic.imgdb.cn/item/610f4e4b5132923bf8ccee00.png)\n\n删边后得到了以 $C$ 为根的子树，假设 $EF$ 该树的直径，说明 $\\text{dis}(E,F)>\\text{dis}(A,B)$，$\\text{dis}(E,F)+\\text{dis}(B,E)>\\text{dis}(A,B)$，则 $FD$ 比 $AD$ 更长，与 $AD$ 是原树直径矛盾，该假设不成立，所以 $A$ 一定是删边后树的直径的一端。证毕。\n\n考虑如何快速维护删边后树的直径：\n\n（图片来自[getchar123的题解](https://www.luogu.com.cn/blog/getchar123/solution-p3761)）\n\n![](https://pic.imgdb.cn/item/610f59395132923bf8db329e.png)\n\n（橙色为截掉的边，绿色为直径，右图紫色的点为重复遍历的点，红色为新遍历的点）\n\n在遍历删边的过程中，如果每次都遍历整棵树，会有大量重复节点（紫色点），根据结论二，我们只需要考虑经过新加进来的 原树直径上的点 能否得到更长的路径。\n\n即从 $10$ 号点出发遍历红色点，找到最长路径，加上 $\\text{dis}(1,10)$，与原来的直径比较。\n\n这样每次都只需要遍历新加进来的节点，维护直径的总时间复杂度优化到了 $O(n)$。\n\n但是每次维护直径中点都要遍历一遍直径，时间复杂度还是 $O(n^2)$，继续优化。\n\n**结论三：对于分割出来的树，它的直径中点一定在原树直径上。**\n\n证明：\n\n如图，删边后的树的直径一定是形如这个样子，\n\n![](https://pic.imgdb.cn/item/610f5e3d5132923bf8e19add.png)\n\n分割出来的树的直径和原树的直径的重叠部分一定大于非重叠部分，即 $\\text{dis}(A,B)>\\text{dis}(E,B)$，如果不是，则路径 $ED$ 就会比原树直径还长。\n\n根据直径中点的定义，中点一定在路径 $AB$ 上。证毕。\n\n可以发现删边过程中，分割出来的树的直径是不下降的，新树和原树的重叠部分也是不下降的。\n\n所以每次只需要从上一次的中点开始，在原树直径上向后遍历，直到当前点比上一个点劣时停止（再往后只会更劣）。维护中点的总时间复杂度为 $O(n)$。\n\n综上，该算法的时间复杂度为 $O(n)$。\n\n这里只维护了分割出来的其中一棵树，对于另一棵树可以倒过来重复这些操作。\n\n## 代码\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nconst int mn=5e3+7;\nstruct node {\n    int mid,len_L,len_R;  //分别是中点，直径，半径（中点到其他点的最远距离）\n}ans[3][mn];\nint tt=0,fr[mn],nx[mn*2],to[mn*2],w[mn*2];\nint rt=1,rt2=1,maxlen=0,d[mn],mx=0;\nint q[mn],top=0;  //存直径上所有点\nbool vis[mn];\nvoid add(int x,int y,int v)\n{\n    ++tt;\n    nx[tt]=fr[x];\n    fr[x]=tt;\n    to[tt]=y;\n    w[tt]=v;\n}\nvoid findrt(int x,int fa,int dis)\n{\n    if(dis>maxlen)  maxlen=dis,rt=x;\n    for(int i=fr[x];i;i=nx[i])\n      if(to[i]!=fa)  findrt(to[i],x,dis+w[i]);\n}\nvoid findrt2(int x,int fa,int dis)\n{\n    d[x]=dis;\n    if(dis>maxlen)  maxlen=dis,rt2=x;\n    for(int i=fr[x];i;i=nx[i])\n      if(to[i]!=fa)  findrt2(to[i],x,dis+w[i]);\n}\nvoid deep(int x,int fa,int dis)\n{\n    d[x]=dis;\n    for(int i=fr[x];i;i=nx[i])\n      if(to[i]!=fa)  deep(to[i],x,dis+w[i]);\n}\nbool dfs(int x,int fa,int dis)\n{\n    q[++top]=x;\n    \n    if(x==rt2)  return 1;\n    for(int i=fr[x];i;i=nx[i])\n    {\n        int y=to[i];\n        if(y==fa)  continue;\n        bool flag=dfs(y,x,dis+w[i]);\n        if(flag)  return 1;\n    }\n    --top;\n    return 0;\n}\nvoid dfs2(int x,int dis)\n{\n    vis[x]=1;\n    mx=max(mx,dis);\n    for(int i=fr[x];i;i=nx[i])\n    {\n        int y=to[i];\n        if(vis[y])  continue;\n        dfs2(y,dis+w[i]);\n    }\n}\nvoid sol(int k)\n{\n    memset(vis,0,sizeof(vis));\n    for(int i=1;i<=top;++i)  vis[q[i]]=1;\n    int mid=1,len_L=0,len_R=0;\n    ans[k][1]=(node){mid,len_L,len_R};\n    for(int i=2;i<top;++i)\n    {\n        mx=0;\n        dfs2(q[i],0);  //遍历新加进来的节点\n        if(d[q[i]]-d[q[1]]+mx<=len_L)\n            ans[k][i]=(node){mid,len_L,len_R};\n        else\n        {\n            len_L=d[q[i]]-d[q[1]]+mx;\n            len_R=max(d[q[mid]]-d[q[1]],len_L-d[q[mid]]-d[q[1]]);\n            for(int j=mid+1;j<=i;++j)\n            {\n                int dis=max(d[q[j]]-d[q[1]],len_L-d[q[j]]-d[q[1]]);\n                if(dis>len_R)  break;  //这里就直接跳出，后面只会更劣\n                len_R=dis;mid=j;\n            }\n            ans[k][i]=(node){mid,len_L,len_R};\n        }\n    }\n}\nint main()\n{\n    int n;\n    cin>>n;\n    for(int i=1;i<n;++i)\n    {\n        int x,y,v;\n        scanf(\"%d%d%d\",&x,&y,&v);\n        add(x,y,v);\n        add(y,x,v);\n    }\n    findrt(1,0,0);  //找直径一端\n    maxlen=0;\n    findrt2(rt,0,0);  //找另一端\n    maxlen=0;\n    dfs(rt,0,0);  //存直径\n    sol(1);\n/***************以下为倒过来处理另一棵树***************/\n    memset(d,0,sizeof(d));\n    top=0;\n    swap(rt,rt2);\n    deep(rt,0,0);  //根变了，深度也要重新求\n    dfs(rt,0,0);\n    sol(2);\n\n    int ANS=1e9;\n    for(int i=1;i<top;++i)\n      ANS=min(ANS,max(d[q[i+1]]-d[q[i]]+ans[2][i].len_R+ans[1][top-i].len_R,max(ans[2][i].len_L,ans[1][top-i].len_L)));\n    cout<<ANS;\n    return 0;\n}\n```\n","slug":"solution-P3761-city","published":1,"updated":"2023-10-13T10:42:06.491Z","comments":1,"layout":"post","link":"","_id":"cloo2ivvu000gr8v36ik8azbw","content":"<p><a href=\"https://www.luogu.com.cn/problem/P3761\">P3761 [TJOI2017]城市</a></p>\n<p><strong>前排提醒：本文着重证明了 $O(n)$ 的做法，$O(n^2)$ 的做法讲得不是很明白。</strong></p>\n<h2 id=\"题意\"><a href=\"#题意\" class=\"headerlink\" title=\"题意\"></a>题意</h2><p>给一颗有边权的树，删去一条边并加上一条权值相同的边（要求操作后还是一颗树），求树的直径最小是多少。</p>\n<p>$n\\le 5000$。</p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>很妙的一道题，主要难点在于结论的寻找和证明。</p>\n<p>最朴素的做法是枚举每条要删除的边，整棵树被分为了两颗子树，再枚举两颗子树上选的点，计算直径。时间复杂度 $O(n^4)$。</p>\n<h3 id=\"O-n-2-做法\"><a href=\"#O-n-2-做法\" class=\"headerlink\" title=\"$O(n^2)$ 做法\"></a>$O(n^2)$ 做法</h3><p>新加入一条边后，新树的直径有两种情况：</p>\n<ul>\n<li><p>直径在分出来的两颗树中的一个。</p>\n</li>\n<li><p>直径经过了新加入的边。</p>\n</li>\n</ul>\n<p>对于第一种情况，新加入的边不会产生影响。</p>\n<p>对于第二种情况，要想办法连边使得新树的直径最小。可以发现两棵树要连的点都是树的中心（即该点到其他节点的最远距离最小）。</p>\n<p>考虑 $DP$，第一遍 $\\text{dfs}$ 求出在该节点子树内从它出发的最远和次远距离。</p>\n<p>第二遍 $\\text{dfs}$ 根据父亲的信息求出在整棵树中从该节点出发的最远和次远距离，在这个过程中找出树的中心。</p>\n<p>所以优化后的做法为枚举每条要删除的边，求出分出来的两颗树的直径和中心，比较这三个值，取最大。时间复杂度 $O(n^2)$。</p>\n<p>这个复杂度已经可以通过这道题了，但是还能继续优化到 $O(n)$。</p>\n<h3 id=\"O-n-做法\"><a href=\"#O-n-做法\" class=\"headerlink\" title=\"$O(n)$ 做法\"></a>$O(n)$ 做法</h3><p>时间复杂度的瓶颈主要在 $DP$，考虑优化。</p>\n<p><strong>结论一：树的中心是树的直径的（带权）中点。</strong></p>\n<p>证明：</p>\n<ul>\n<li><p>对于直径上任意一点 $u$，显然从 $u$ 出发的最远路径一定在直径上，若要求直径中心则只需比较 $u$ 到直径两端的最远距离，所以直径中点 $mid$ 是该直径的中心。</p>\n</li>\n<li><p>对于不在直径上的点 $v$，从 $v$ 出发到 $mid$，再到直径较远一端的所走路程，必然比直接从 $mid$ 出发的所走路程远。根据定义，树的中心要到其他点的最远距离最小，所以 $v$ 不是树的中心。</p>\n</li>\n</ul>\n<p>综上，$mid$ 是树的中心。证毕。</p>\n<p>问题就转化为了如何求树的直径的中点。</p>\n<p>对于删边操作，可以发现只有删原树直径上的边才有意义，因为删其他边直径没有变。</p>\n<p>所以从直径一端出发到另一端依次删除边。但是每次都要遍历整棵树求直径中点，时间复杂度还是没有变，考虑优化。</p>\n<p>以下只针对删边后的两颗树中的一个分析，另一个同理。</p>\n<p><strong>结论二：对于一颗分割出来的树，它直径的一端一定是原树直径的一端。</strong></p>\n<p>证明：</p>\n<p>反证法，如图，</p>\n<p><img src=\"https://pic.imgdb.cn/item/610f4e4b5132923bf8ccee00.png\" alt=\"\"></p>\n<p>删边后得到了以 $C$ 为根的子树，假设 $EF$ 该树的直径，说明 $\\text{dis}(E,F)&gt;\\text{dis}(A,B)$，$\\text{dis}(E,F)+\\text{dis}(B,E)&gt;\\text{dis}(A,B)$，则 $FD$ 比 $AD$ 更长，与 $AD$ 是原树直径矛盾，该假设不成立，所以 $A$ 一定是删边后树的直径的一端。证毕。</p>\n<p>考虑如何快速维护删边后树的直径：</p>\n<p>（图片来自<a href=\"https://www.luogu.com.cn/blog/getchar123/solution-p3761\">getchar123的题解</a>）</p>\n<p><img src=\"https://pic.imgdb.cn/item/610f59395132923bf8db329e.png\" alt=\"\"></p>\n<p>（橙色为截掉的边，绿色为直径，右图紫色的点为重复遍历的点，红色为新遍历的点）</p>\n<p>在遍历删边的过程中，如果每次都遍历整棵树，会有大量重复节点（紫色点），根据结论二，我们只需要考虑经过新加进来的 原树直径上的点 能否得到更长的路径。</p>\n<p>即从 $10$ 号点出发遍历红色点，找到最长路径，加上 $\\text{dis}(1,10)$，与原来的直径比较。</p>\n<p>这样每次都只需要遍历新加进来的节点，维护直径的总时间复杂度优化到了 $O(n)$。</p>\n<p>但是每次维护直径中点都要遍历一遍直径，时间复杂度还是 $O(n^2)$，继续优化。</p>\n<p><strong>结论三：对于分割出来的树，它的直径中点一定在原树直径上。</strong></p>\n<p>证明：</p>\n<p>如图，删边后的树的直径一定是形如这个样子，</p>\n<p><img src=\"https://pic.imgdb.cn/item/610f5e3d5132923bf8e19add.png\" alt=\"\"></p>\n<p>分割出来的树的直径和原树的直径的重叠部分一定大于非重叠部分，即 $\\text{dis}(A,B)&gt;\\text{dis}(E,B)$，如果不是，则路径 $ED$ 就会比原树直径还长。</p>\n<p>根据直径中点的定义，中点一定在路径 $AB$ 上。证毕。</p>\n<p>可以发现删边过程中，分割出来的树的直径是不下降的，新树和原树的重叠部分也是不下降的。</p>\n<p>所以每次只需要从上一次的中点开始，在原树直径上向后遍历，直到当前点比上一个点劣时停止（再往后只会更劣）。维护中点的总时间复杂度为 $O(n)$。</p>\n<p>综上，该算法的时间复杂度为 $O(n)$。</p>\n<p>这里只维护了分割出来的其中一棵树，对于另一棵树可以倒过来重复这些操作。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><pre><code class=\"lang-cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int mn=5e3+7;\nstruct node &#123;\n    int mid,len_L,len_R;  //分别是中点，直径，半径（中点到其他点的最远距离）\n&#125;ans[3][mn];\nint tt=0,fr[mn],nx[mn*2],to[mn*2],w[mn*2];\nint rt=1,rt2=1,maxlen=0,d[mn],mx=0;\nint q[mn],top=0;  //存直径上所有点\nbool vis[mn];\nvoid add(int x,int y,int v)\n&#123;\n    ++tt;\n    nx[tt]=fr[x];\n    fr[x]=tt;\n    to[tt]=y;\n    w[tt]=v;\n&#125;\nvoid findrt(int x,int fa,int dis)\n&#123;\n    if(dis&gt;maxlen)  maxlen=dis,rt=x;\n    for(int i=fr[x];i;i=nx[i])\n      if(to[i]!=fa)  findrt(to[i],x,dis+w[i]);\n&#125;\nvoid findrt2(int x,int fa,int dis)\n&#123;\n    d[x]=dis;\n    if(dis&gt;maxlen)  maxlen=dis,rt2=x;\n    for(int i=fr[x];i;i=nx[i])\n      if(to[i]!=fa)  findrt2(to[i],x,dis+w[i]);\n&#125;\nvoid deep(int x,int fa,int dis)\n&#123;\n    d[x]=dis;\n    for(int i=fr[x];i;i=nx[i])\n      if(to[i]!=fa)  deep(to[i],x,dis+w[i]);\n&#125;\nbool dfs(int x,int fa,int dis)\n&#123;\n    q[++top]=x;\n\n    if(x==rt2)  return 1;\n    for(int i=fr[x];i;i=nx[i])\n    &#123;\n        int y=to[i];\n        if(y==fa)  continue;\n        bool flag=dfs(y,x,dis+w[i]);\n        if(flag)  return 1;\n    &#125;\n    --top;\n    return 0;\n&#125;\nvoid dfs2(int x,int dis)\n&#123;\n    vis[x]=1;\n    mx=max(mx,dis);\n    for(int i=fr[x];i;i=nx[i])\n    &#123;\n        int y=to[i];\n        if(vis[y])  continue;\n        dfs2(y,dis+w[i]);\n    &#125;\n&#125;\nvoid sol(int k)\n&#123;\n    memset(vis,0,sizeof(vis));\n    for(int i=1;i&lt;=top;++i)  vis[q[i]]=1;\n    int mid=1,len_L=0,len_R=0;\n    ans[k][1]=(node)&#123;mid,len_L,len_R&#125;;\n    for(int i=2;i&lt;top;++i)\n    &#123;\n        mx=0;\n        dfs2(q[i],0);  //遍历新加进来的节点\n        if(d[q[i]]-d[q[1]]+mx&lt;=len_L)\n            ans[k][i]=(node)&#123;mid,len_L,len_R&#125;;\n        else\n        &#123;\n            len_L=d[q[i]]-d[q[1]]+mx;\n            len_R=max(d[q[mid]]-d[q[1]],len_L-d[q[mid]]-d[q[1]]);\n            for(int j=mid+1;j&lt;=i;++j)\n            &#123;\n                int dis=max(d[q[j]]-d[q[1]],len_L-d[q[j]]-d[q[1]]);\n                if(dis&gt;len_R)  break;  //这里就直接跳出，后面只会更劣\n                len_R=dis;mid=j;\n            &#125;\n            ans[k][i]=(node)&#123;mid,len_L,len_R&#125;;\n        &#125;\n    &#125;\n&#125;\nint main()\n&#123;\n    int n;\n    cin&gt;&gt;n;\n    for(int i=1;i&lt;n;++i)\n    &#123;\n        int x,y,v;\n        scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;v);\n        add(x,y,v);\n        add(y,x,v);\n    &#125;\n    findrt(1,0,0);  //找直径一端\n    maxlen=0;\n    findrt2(rt,0,0);  //找另一端\n    maxlen=0;\n    dfs(rt,0,0);  //存直径\n    sol(1);\n/***************以下为倒过来处理另一棵树***************/\n    memset(d,0,sizeof(d));\n    top=0;\n    swap(rt,rt2);\n    deep(rt,0,0);  //根变了，深度也要重新求\n    dfs(rt,0,0);\n    sol(2);\n\n    int ANS=1e9;\n    for(int i=1;i&lt;top;++i)\n      ANS=min(ANS,max(d[q[i+1]]-d[q[i]]+ans[2][i].len_R+ans[1][top-i].len_R,max(ans[2][i].len_L,ans[1][top-i].len_L)));\n    cout&lt;&lt;ANS;\n    return 0;\n&#125;\n</code></pre>\n<link rel=\"stylesheet\" href=\"/css/spoiler.css\" type=\"text/css\"><script src=\"/js/spoiler.js\" type=\"text/javascript\" async></script>","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://www.luogu.com.cn/problem/P3761\">P3761 [TJOI2017]城市</a></p>\n<p><strong>前排提醒：本文着重证明了 $O(n)$ 的做法，$O(n^2)$ 的做法讲得不是很明白。</strong></p>\n<h2 id=\"题意\"><a href=\"#题意\" class=\"headerlink\" title=\"题意\"></a>题意</h2><p>给一颗有边权的树，删去一条边并加上一条权值相同的边（要求操作后还是一颗树），求树的直径最小是多少。</p>\n<p>$n\\le 5000$。</p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>很妙的一道题，主要难点在于结论的寻找和证明。</p>\n<p>最朴素的做法是枚举每条要删除的边，整棵树被分为了两颗子树，再枚举两颗子树上选的点，计算直径。时间复杂度 $O(n^4)$。</p>\n<h3 id=\"O-n-2-做法\"><a href=\"#O-n-2-做法\" class=\"headerlink\" title=\"$O(n^2)$ 做法\"></a>$O(n^2)$ 做法</h3><p>新加入一条边后，新树的直径有两种情况：</p>\n<ul>\n<li><p>直径在分出来的两颗树中的一个。</p>\n</li>\n<li><p>直径经过了新加入的边。</p>\n</li>\n</ul>\n<p>对于第一种情况，新加入的边不会产生影响。</p>\n<p>对于第二种情况，要想办法连边使得新树的直径最小。可以发现两棵树要连的点都是树的中心（即该点到其他节点的最远距离最小）。</p>\n<p>考虑 $DP$，第一遍 $\\text{dfs}$ 求出在该节点子树内从它出发的最远和次远距离。</p>\n<p>第二遍 $\\text{dfs}$ 根据父亲的信息求出在整棵树中从该节点出发的最远和次远距离，在这个过程中找出树的中心。</p>\n<p>所以优化后的做法为枚举每条要删除的边，求出分出来的两颗树的直径和中心，比较这三个值，取最大。时间复杂度 $O(n^2)$。</p>\n<p>这个复杂度已经可以通过这道题了，但是还能继续优化到 $O(n)$。</p>\n<h3 id=\"O-n-做法\"><a href=\"#O-n-做法\" class=\"headerlink\" title=\"$O(n)$ 做法\"></a>$O(n)$ 做法</h3><p>时间复杂度的瓶颈主要在 $DP$，考虑优化。</p>\n<p><strong>结论一：树的中心是树的直径的（带权）中点。</strong></p>\n<p>证明：</p>\n<ul>\n<li><p>对于直径上任意一点 $u$，显然从 $u$ 出发的最远路径一定在直径上，若要求直径中心则只需比较 $u$ 到直径两端的最远距离，所以直径中点 $mid$ 是该直径的中心。</p>\n</li>\n<li><p>对于不在直径上的点 $v$，从 $v$ 出发到 $mid$，再到直径较远一端的所走路程，必然比直接从 $mid$ 出发的所走路程远。根据定义，树的中心要到其他点的最远距离最小，所以 $v$ 不是树的中心。</p>\n</li>\n</ul>\n<p>综上，$mid$ 是树的中心。证毕。</p>\n<p>问题就转化为了如何求树的直径的中点。</p>\n<p>对于删边操作，可以发现只有删原树直径上的边才有意义，因为删其他边直径没有变。</p>\n<p>所以从直径一端出发到另一端依次删除边。但是每次都要遍历整棵树求直径中点，时间复杂度还是没有变，考虑优化。</p>\n<p>以下只针对删边后的两颗树中的一个分析，另一个同理。</p>\n<p><strong>结论二：对于一颗分割出来的树，它直径的一端一定是原树直径的一端。</strong></p>\n<p>证明：</p>\n<p>反证法，如图，</p>\n<p><img src=\"https://pic.imgdb.cn/item/610f4e4b5132923bf8ccee00.png\" alt=\"\"></p>\n<p>删边后得到了以 $C$ 为根的子树，假设 $EF$ 该树的直径，说明 $\\text{dis}(E,F)&gt;\\text{dis}(A,B)$，$\\text{dis}(E,F)+\\text{dis}(B,E)&gt;\\text{dis}(A,B)$，则 $FD$ 比 $AD$ 更长，与 $AD$ 是原树直径矛盾，该假设不成立，所以 $A$ 一定是删边后树的直径的一端。证毕。</p>\n<p>考虑如何快速维护删边后树的直径：</p>\n<p>（图片来自<a href=\"https://www.luogu.com.cn/blog/getchar123/solution-p3761\">getchar123的题解</a>）</p>\n<p><img src=\"https://pic.imgdb.cn/item/610f59395132923bf8db329e.png\" alt=\"\"></p>\n<p>（橙色为截掉的边，绿色为直径，右图紫色的点为重复遍历的点，红色为新遍历的点）</p>\n<p>在遍历删边的过程中，如果每次都遍历整棵树，会有大量重复节点（紫色点），根据结论二，我们只需要考虑经过新加进来的 原树直径上的点 能否得到更长的路径。</p>\n<p>即从 $10$ 号点出发遍历红色点，找到最长路径，加上 $\\text{dis}(1,10)$，与原来的直径比较。</p>\n<p>这样每次都只需要遍历新加进来的节点，维护直径的总时间复杂度优化到了 $O(n)$。</p>\n<p>但是每次维护直径中点都要遍历一遍直径，时间复杂度还是 $O(n^2)$，继续优化。</p>\n<p><strong>结论三：对于分割出来的树，它的直径中点一定在原树直径上。</strong></p>\n<p>证明：</p>\n<p>如图，删边后的树的直径一定是形如这个样子，</p>\n<p><img src=\"https://pic.imgdb.cn/item/610f5e3d5132923bf8e19add.png\" alt=\"\"></p>\n<p>分割出来的树的直径和原树的直径的重叠部分一定大于非重叠部分，即 $\\text{dis}(A,B)&gt;\\text{dis}(E,B)$，如果不是，则路径 $ED$ 就会比原树直径还长。</p>\n<p>根据直径中点的定义，中点一定在路径 $AB$ 上。证毕。</p>\n<p>可以发现删边过程中，分割出来的树的直径是不下降的，新树和原树的重叠部分也是不下降的。</p>\n<p>所以每次只需要从上一次的中点开始，在原树直径上向后遍历，直到当前点比上一个点劣时停止（再往后只会更劣）。维护中点的总时间复杂度为 $O(n)$。</p>\n<p>综上，该算法的时间复杂度为 $O(n)$。</p>\n<p>这里只维护了分割出来的其中一棵树，对于另一棵树可以倒过来重复这些操作。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><pre><code class=\"lang-cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int mn=5e3+7;\nstruct node &#123;\n    int mid,len_L,len_R;  //分别是中点，直径，半径（中点到其他点的最远距离）\n&#125;ans[3][mn];\nint tt=0,fr[mn],nx[mn*2],to[mn*2],w[mn*2];\nint rt=1,rt2=1,maxlen=0,d[mn],mx=0;\nint q[mn],top=0;  //存直径上所有点\nbool vis[mn];\nvoid add(int x,int y,int v)\n&#123;\n    ++tt;\n    nx[tt]=fr[x];\n    fr[x]=tt;\n    to[tt]=y;\n    w[tt]=v;\n&#125;\nvoid findrt(int x,int fa,int dis)\n&#123;\n    if(dis&gt;maxlen)  maxlen=dis,rt=x;\n    for(int i=fr[x];i;i=nx[i])\n      if(to[i]!=fa)  findrt(to[i],x,dis+w[i]);\n&#125;\nvoid findrt2(int x,int fa,int dis)\n&#123;\n    d[x]=dis;\n    if(dis&gt;maxlen)  maxlen=dis,rt2=x;\n    for(int i=fr[x];i;i=nx[i])\n      if(to[i]!=fa)  findrt2(to[i],x,dis+w[i]);\n&#125;\nvoid deep(int x,int fa,int dis)\n&#123;\n    d[x]=dis;\n    for(int i=fr[x];i;i=nx[i])\n      if(to[i]!=fa)  deep(to[i],x,dis+w[i]);\n&#125;\nbool dfs(int x,int fa,int dis)\n&#123;\n    q[++top]=x;\n\n    if(x==rt2)  return 1;\n    for(int i=fr[x];i;i=nx[i])\n    &#123;\n        int y=to[i];\n        if(y==fa)  continue;\n        bool flag=dfs(y,x,dis+w[i]);\n        if(flag)  return 1;\n    &#125;\n    --top;\n    return 0;\n&#125;\nvoid dfs2(int x,int dis)\n&#123;\n    vis[x]=1;\n    mx=max(mx,dis);\n    for(int i=fr[x];i;i=nx[i])\n    &#123;\n        int y=to[i];\n        if(vis[y])  continue;\n        dfs2(y,dis+w[i]);\n    &#125;\n&#125;\nvoid sol(int k)\n&#123;\n    memset(vis,0,sizeof(vis));\n    for(int i=1;i&lt;=top;++i)  vis[q[i]]=1;\n    int mid=1,len_L=0,len_R=0;\n    ans[k][1]=(node)&#123;mid,len_L,len_R&#125;;\n    for(int i=2;i&lt;top;++i)\n    &#123;\n        mx=0;\n        dfs2(q[i],0);  //遍历新加进来的节点\n        if(d[q[i]]-d[q[1]]+mx&lt;=len_L)\n            ans[k][i]=(node)&#123;mid,len_L,len_R&#125;;\n        else\n        &#123;\n            len_L=d[q[i]]-d[q[1]]+mx;\n            len_R=max(d[q[mid]]-d[q[1]],len_L-d[q[mid]]-d[q[1]]);\n            for(int j=mid+1;j&lt;=i;++j)\n            &#123;\n                int dis=max(d[q[j]]-d[q[1]],len_L-d[q[j]]-d[q[1]]);\n                if(dis&gt;len_R)  break;  //这里就直接跳出，后面只会更劣\n                len_R=dis;mid=j;\n            &#125;\n            ans[k][i]=(node)&#123;mid,len_L,len_R&#125;;\n        &#125;\n    &#125;\n&#125;\nint main()\n&#123;\n    int n;\n    cin&gt;&gt;n;\n    for(int i=1;i&lt;n;++i)\n    &#123;\n        int x,y,v;\n        scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;v);\n        add(x,y,v);\n        add(y,x,v);\n    &#125;\n    findrt(1,0,0);  //找直径一端\n    maxlen=0;\n    findrt2(rt,0,0);  //找另一端\n    maxlen=0;\n    dfs(rt,0,0);  //存直径\n    sol(1);\n/***************以下为倒过来处理另一棵树***************/\n    memset(d,0,sizeof(d));\n    top=0;\n    swap(rt,rt2);\n    deep(rt,0,0);  //根变了，深度也要重新求\n    dfs(rt,0,0);\n    sol(2);\n\n    int ANS=1e9;\n    for(int i=1;i&lt;top;++i)\n      ANS=min(ANS,max(d[q[i+1]]-d[q[i]]+ans[2][i].len_R+ans[1][top-i].len_R,max(ans[2][i].len_L,ans[1][top-i].len_L)));\n    cout&lt;&lt;ANS;\n    return 0;\n&#125;\n</code></pre>\n"},{"author":"a154051","avatar":"https://a154051-img-1321592229.cos.ap-beijing.myqcloud.com/img/头像new.jpg","title":"【题解】P4248 [AHOI2013]差异","mathjax":true,"date":"2021-07-17T11:49:52.000Z","description":"后缀自动机求最长公共后缀","keywords":"后缀自动机","photos":["https://a154051-img-1321592229.cos.ap-beijing.myqcloud.com/img/7-17.jpg"],"_content":"\n## 题意\n\n给一个长度为 $n$ 的字符串，求 \n\n$$\\sum\\limits_{1\\le i<j\\le n} \\operatorname{len}(suf_i)+\\operatorname{len}(suf_j)-2\\times \\operatorname{lcp}(suf_i,suf_j)$$\n\n其中，$\\text{lcp}$ 表示最长公共前缀。\n\n## 题解\n\n后缀的最长公共前缀不太好求，我们把给的字符串翻转，再将原式变一下，就成了\n\n$$\\sum\\limits_{1\\le i<j\\le n}\\operatorname{len}(pre_i)+\\operatorname{len}(pre_j)-\\sum\\limits_{1\\le i<j\\le n}2\\times \\operatorname{lcs}(pre_i,pre_j)$$\n\n其中，$\\operatorname{lcs}$ 表示最长公共后缀。\n\n前一部分很好求，即 $n\\times (n+1)\\times (n-1)/2$。\n\n后一部分可以对原串建 $SAM$，对于 $SAM$ 上的一个结点，它的祖先都是它的后缀，所以求最长公共后缀即在 $parent\\ \\ tree$ 上求这两个结点的 $LCA$。\n\n但是 $n$ 太大，不能直接枚举 $i$ 和 $j$，考虑对每个 $parent\\ \\ tree$ 上的结点求该结点是多少个点对的 $LCA$，具体做法为每遍历一个儿子，就把该儿子的子树大小乘上前面已经遍历过的子树大小，再乘上 $longest$ 的二倍累加到答案中。时间复杂度为 $O(n)$。\n\n其实题面上也有提示，原式很像树上求两点之间的路径长度，于是可以联想到 $parent\\ \\ tree$ 上求 $LCA$。\n~~（谁会联想这个啊）~~\n\n## 代码\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int mn=2e6+7;\nstruct node {\n    int ch[26],fa;\n    ll len;\n}sam[mn];\nint last=1,tot=1;\nchar tmp[mn],s[mn];\nint fr[mn],nx[mn],to[mn],tt=0;\nll ans=0,cnt[mn];\nvoid add(int x)\n{\n    int p=last,now=last=++tot;cnt[tot]=1;\n    sam[now].len=sam[p].len+1;\n    for(;p&&!sam[p].ch[x];p=sam[p].fa)  sam[p].ch[x]=now;\n    if(!p)  sam[now].fa=1;\n    else\n    {\n        int son1=sam[p].ch[x];\n        if(sam[son1].len==sam[p].len+1)  sam[now].fa=son1;\n        else\n        {\n            int son2=++tot;\n            sam[son2]=sam[son1];\n            sam[son2].len=sam[p].len+1;\n            sam[son1].fa=sam[now].fa=son2;\n            for(;p&&sam[p].ch[x]==son1;p=sam[p].fa)  sam[p].ch[x]=son2;\n        }\n    }\n}\nvoid link(int x,int y)\n{\n    ++tt;\n    nx[tt]=fr[x];\n    fr[x]=tt;\n    to[tt]=y;\n}\nvoid dfs(int x)\n{\n    ll sum=0;\n    for(int i=fr[x];i;i=nx[i])\n    {\n        int y=to[i];\n        dfs(y);\n        sum+=sam[x].len*cnt[x]*cnt[y]*2;  //这里不开 long long 会乘炸\n        cnt[x]+=cnt[y];\n    }\n    ans-=sum;\n}\nint main()\n{\n    scanf(\"%s\",tmp+1);\n    int n=strlen(tmp+1);\n    for(int i=1;i<=n;++i)\n      s[n-i+1]=tmp[i];\n    for(int i=1;i<=n;++i)  add(s[i]-'a');\n    for(int i=2;i<=tot;++i)  link(sam[i].fa,i);\n    ans=(ll)n*(n+1)*(n-1)/2;  //这里也会乘炸\n    dfs(1);\n    cout<<ans;\n    return 0;\n}\n```","source":"_posts/solution-P4248-cha-yi.md","raw":"---\nauthor: a154051\navatar: 'https://a154051-img-1321592229.cos.ap-beijing.myqcloud.com/img/头像new.jpg'\ntitle: 【题解】P4248 [AHOI2013]差异\ntags:\n  - 字符串\n  - 后缀自动机-SAM\nmathjax: true\ndate: 2021-07-17 19:49:52\ncategories: 题解\ndescription: 后缀自动机求最长公共后缀\nkeywords: 后缀自动机\nphotos: https://a154051-img-1321592229.cos.ap-beijing.myqcloud.com/img/7-17.jpg\n---\n\n## 题意\n\n给一个长度为 $n$ 的字符串，求 \n\n$$\\sum\\limits_{1\\le i<j\\le n} \\operatorname{len}(suf_i)+\\operatorname{len}(suf_j)-2\\times \\operatorname{lcp}(suf_i,suf_j)$$\n\n其中，$\\text{lcp}$ 表示最长公共前缀。\n\n## 题解\n\n后缀的最长公共前缀不太好求，我们把给的字符串翻转，再将原式变一下，就成了\n\n$$\\sum\\limits_{1\\le i<j\\le n}\\operatorname{len}(pre_i)+\\operatorname{len}(pre_j)-\\sum\\limits_{1\\le i<j\\le n}2\\times \\operatorname{lcs}(pre_i,pre_j)$$\n\n其中，$\\operatorname{lcs}$ 表示最长公共后缀。\n\n前一部分很好求，即 $n\\times (n+1)\\times (n-1)/2$。\n\n后一部分可以对原串建 $SAM$，对于 $SAM$ 上的一个结点，它的祖先都是它的后缀，所以求最长公共后缀即在 $parent\\ \\ tree$ 上求这两个结点的 $LCA$。\n\n但是 $n$ 太大，不能直接枚举 $i$ 和 $j$，考虑对每个 $parent\\ \\ tree$ 上的结点求该结点是多少个点对的 $LCA$，具体做法为每遍历一个儿子，就把该儿子的子树大小乘上前面已经遍历过的子树大小，再乘上 $longest$ 的二倍累加到答案中。时间复杂度为 $O(n)$。\n\n其实题面上也有提示，原式很像树上求两点之间的路径长度，于是可以联想到 $parent\\ \\ tree$ 上求 $LCA$。\n~~（谁会联想这个啊）~~\n\n## 代码\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int mn=2e6+7;\nstruct node {\n    int ch[26],fa;\n    ll len;\n}sam[mn];\nint last=1,tot=1;\nchar tmp[mn],s[mn];\nint fr[mn],nx[mn],to[mn],tt=0;\nll ans=0,cnt[mn];\nvoid add(int x)\n{\n    int p=last,now=last=++tot;cnt[tot]=1;\n    sam[now].len=sam[p].len+1;\n    for(;p&&!sam[p].ch[x];p=sam[p].fa)  sam[p].ch[x]=now;\n    if(!p)  sam[now].fa=1;\n    else\n    {\n        int son1=sam[p].ch[x];\n        if(sam[son1].len==sam[p].len+1)  sam[now].fa=son1;\n        else\n        {\n            int son2=++tot;\n            sam[son2]=sam[son1];\n            sam[son2].len=sam[p].len+1;\n            sam[son1].fa=sam[now].fa=son2;\n            for(;p&&sam[p].ch[x]==son1;p=sam[p].fa)  sam[p].ch[x]=son2;\n        }\n    }\n}\nvoid link(int x,int y)\n{\n    ++tt;\n    nx[tt]=fr[x];\n    fr[x]=tt;\n    to[tt]=y;\n}\nvoid dfs(int x)\n{\n    ll sum=0;\n    for(int i=fr[x];i;i=nx[i])\n    {\n        int y=to[i];\n        dfs(y);\n        sum+=sam[x].len*cnt[x]*cnt[y]*2;  //这里不开 long long 会乘炸\n        cnt[x]+=cnt[y];\n    }\n    ans-=sum;\n}\nint main()\n{\n    scanf(\"%s\",tmp+1);\n    int n=strlen(tmp+1);\n    for(int i=1;i<=n;++i)\n      s[n-i+1]=tmp[i];\n    for(int i=1;i<=n;++i)  add(s[i]-'a');\n    for(int i=2;i<=tot;++i)  link(sam[i].fa,i);\n    ans=(ll)n*(n+1)*(n-1)/2;  //这里也会乘炸\n    dfs(1);\n    cout<<ans;\n    return 0;\n}\n```","slug":"solution-P4248-cha-yi","published":1,"updated":"2023-10-13T10:42:06.493Z","comments":1,"layout":"post","link":"","_id":"cloo2ivvv000ir8v31s8i2ic5","content":"<h2 id=\"题意\"><a href=\"#题意\" class=\"headerlink\" title=\"题意\"></a>题意</h2><p>给一个长度为 $n$ 的字符串，求 </p>\n<script type=\"math/tex; mode=display\">\\sum\\limits_{1\\le i<j\\le n} \\operatorname{len}(suf_i)+\\operatorname{len}(suf_j)-2\\times \\operatorname{lcp}(suf_i,suf_j)</script><p>其中，$\\text{lcp}$ 表示最长公共前缀。</p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>后缀的最长公共前缀不太好求，我们把给的字符串翻转，再将原式变一下，就成了</p>\n<script type=\"math/tex; mode=display\">\\sum\\limits_{1\\le i<j\\le n}\\operatorname{len}(pre_i)+\\operatorname{len}(pre_j)-\\sum\\limits_{1\\le i<j\\le n}2\\times \\operatorname{lcs}(pre_i,pre_j)</script><p>其中，$\\operatorname{lcs}$ 表示最长公共后缀。</p>\n<p>前一部分很好求，即 $n\\times (n+1)\\times (n-1)/2$。</p>\n<p>后一部分可以对原串建 $SAM$，对于 $SAM$ 上的一个结点，它的祖先都是它的后缀，所以求最长公共后缀即在 $parent\\ \\ tree$ 上求这两个结点的 $LCA$。</p>\n<p>但是 $n$ 太大，不能直接枚举 $i$ 和 $j$，考虑对每个 $parent\\ \\ tree$ 上的结点求该结点是多少个点对的 $LCA$，具体做法为每遍历一个儿子，就把该儿子的子树大小乘上前面已经遍历过的子树大小，再乘上 $longest$ 的二倍累加到答案中。时间复杂度为 $O(n)$。</p>\n<p>其实题面上也有提示，原式很像树上求两点之间的路径长度，于是可以联想到 $parent\\ \\ tree$ 上求 $LCA$。<br><del>（谁会联想这个啊）</del></p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><pre><code class=\"lang-cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\nconst int mn=2e6+7;\nstruct node &#123;\n    int ch[26],fa;\n    ll len;\n&#125;sam[mn];\nint last=1,tot=1;\nchar tmp[mn],s[mn];\nint fr[mn],nx[mn],to[mn],tt=0;\nll ans=0,cnt[mn];\nvoid add(int x)\n&#123;\n    int p=last,now=last=++tot;cnt[tot]=1;\n    sam[now].len=sam[p].len+1;\n    for(;p&amp;&amp;!sam[p].ch[x];p=sam[p].fa)  sam[p].ch[x]=now;\n    if(!p)  sam[now].fa=1;\n    else\n    &#123;\n        int son1=sam[p].ch[x];\n        if(sam[son1].len==sam[p].len+1)  sam[now].fa=son1;\n        else\n        &#123;\n            int son2=++tot;\n            sam[son2]=sam[son1];\n            sam[son2].len=sam[p].len+1;\n            sam[son1].fa=sam[now].fa=son2;\n            for(;p&amp;&amp;sam[p].ch[x]==son1;p=sam[p].fa)  sam[p].ch[x]=son2;\n        &#125;\n    &#125;\n&#125;\nvoid link(int x,int y)\n&#123;\n    ++tt;\n    nx[tt]=fr[x];\n    fr[x]=tt;\n    to[tt]=y;\n&#125;\nvoid dfs(int x)\n&#123;\n    ll sum=0;\n    for(int i=fr[x];i;i=nx[i])\n    &#123;\n        int y=to[i];\n        dfs(y);\n        sum+=sam[x].len*cnt[x]*cnt[y]*2;  //这里不开 long long 会乘炸\n        cnt[x]+=cnt[y];\n    &#125;\n    ans-=sum;\n&#125;\nint main()\n&#123;\n    scanf(&quot;%s&quot;,tmp+1);\n    int n=strlen(tmp+1);\n    for(int i=1;i&lt;=n;++i)\n      s[n-i+1]=tmp[i];\n    for(int i=1;i&lt;=n;++i)  add(s[i]-&#39;a&#39;);\n    for(int i=2;i&lt;=tot;++i)  link(sam[i].fa,i);\n    ans=(ll)n*(n+1)*(n-1)/2;  //这里也会乘炸\n    dfs(1);\n    cout&lt;&lt;ans;\n    return 0;\n&#125;\n</code></pre>\n<link rel=\"stylesheet\" href=\"/css/spoiler.css\" type=\"text/css\"><script src=\"/js/spoiler.js\" type=\"text/javascript\" async></script>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"题意\"><a href=\"#题意\" class=\"headerlink\" title=\"题意\"></a>题意</h2><p>给一个长度为 $n$ 的字符串，求 </p>\n<script type=\"math/tex; mode=display\">\\sum\\limits_{1\\le i<j\\le n} \\operatorname{len}(suf_i)+\\operatorname{len}(suf_j)-2\\times \\operatorname{lcp}(suf_i,suf_j)</script><p>其中，$\\text{lcp}$ 表示最长公共前缀。</p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>后缀的最长公共前缀不太好求，我们把给的字符串翻转，再将原式变一下，就成了</p>\n<script type=\"math/tex; mode=display\">\\sum\\limits_{1\\le i<j\\le n}\\operatorname{len}(pre_i)+\\operatorname{len}(pre_j)-\\sum\\limits_{1\\le i<j\\le n}2\\times \\operatorname{lcs}(pre_i,pre_j)</script><p>其中，$\\operatorname{lcs}$ 表示最长公共后缀。</p>\n<p>前一部分很好求，即 $n\\times (n+1)\\times (n-1)/2$。</p>\n<p>后一部分可以对原串建 $SAM$，对于 $SAM$ 上的一个结点，它的祖先都是它的后缀，所以求最长公共后缀即在 $parent\\ \\ tree$ 上求这两个结点的 $LCA$。</p>\n<p>但是 $n$ 太大，不能直接枚举 $i$ 和 $j$，考虑对每个 $parent\\ \\ tree$ 上的结点求该结点是多少个点对的 $LCA$，具体做法为每遍历一个儿子，就把该儿子的子树大小乘上前面已经遍历过的子树大小，再乘上 $longest$ 的二倍累加到答案中。时间复杂度为 $O(n)$。</p>\n<p>其实题面上也有提示，原式很像树上求两点之间的路径长度，于是可以联想到 $parent\\ \\ tree$ 上求 $LCA$。<br><del>（谁会联想这个啊）</del></p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><pre><code class=\"lang-cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\nconst int mn=2e6+7;\nstruct node &#123;\n    int ch[26],fa;\n    ll len;\n&#125;sam[mn];\nint last=1,tot=1;\nchar tmp[mn],s[mn];\nint fr[mn],nx[mn],to[mn],tt=0;\nll ans=0,cnt[mn];\nvoid add(int x)\n&#123;\n    int p=last,now=last=++tot;cnt[tot]=1;\n    sam[now].len=sam[p].len+1;\n    for(;p&amp;&amp;!sam[p].ch[x];p=sam[p].fa)  sam[p].ch[x]=now;\n    if(!p)  sam[now].fa=1;\n    else\n    &#123;\n        int son1=sam[p].ch[x];\n        if(sam[son1].len==sam[p].len+1)  sam[now].fa=son1;\n        else\n        &#123;\n            int son2=++tot;\n            sam[son2]=sam[son1];\n            sam[son2].len=sam[p].len+1;\n            sam[son1].fa=sam[now].fa=son2;\n            for(;p&amp;&amp;sam[p].ch[x]==son1;p=sam[p].fa)  sam[p].ch[x]=son2;\n        &#125;\n    &#125;\n&#125;\nvoid link(int x,int y)\n&#123;\n    ++tt;\n    nx[tt]=fr[x];\n    fr[x]=tt;\n    to[tt]=y;\n&#125;\nvoid dfs(int x)\n&#123;\n    ll sum=0;\n    for(int i=fr[x];i;i=nx[i])\n    &#123;\n        int y=to[i];\n        dfs(y);\n        sum+=sam[x].len*cnt[x]*cnt[y]*2;  //这里不开 long long 会乘炸\n        cnt[x]+=cnt[y];\n    &#125;\n    ans-=sum;\n&#125;\nint main()\n&#123;\n    scanf(&quot;%s&quot;,tmp+1);\n    int n=strlen(tmp+1);\n    for(int i=1;i&lt;=n;++i)\n      s[n-i+1]=tmp[i];\n    for(int i=1;i&lt;=n;++i)  add(s[i]-&#39;a&#39;);\n    for(int i=2;i&lt;=tot;++i)  link(sam[i].fa,i);\n    ans=(ll)n*(n+1)*(n-1)/2;  //这里也会乘炸\n    dfs(1);\n    cout&lt;&lt;ans;\n    return 0;\n&#125;\n</code></pre>\n"},{"author":"a154051","avatar":"https://a154051-img-1321592229.cos.ap-beijing.myqcloud.com/img/头像new.jpg","title":"【题解】P4331 [BalticOI 2004]Sequence","mathjax":true,"date":"2021-09-25T08:35:02.000Z","description":"贪心加数据结构","keywords":"贪心","photos":["https://a154051-img-1321592229.cos.ap-beijing.myqcloud.com/img/9-25-2.jpg"],"_content":"[P4331 [BalticOI 2004]Sequence 数字序列](https://www.luogu.com.cn/problem/P4331)\n\n好多题解都是用的中位数做法，其实贪心就可以直接做。\n\n## 题意\n\n给定一个长度为 $n$ 的整数序列 $a$，求出一个严格递增整数序列 $b$，使得 $\\sum^n_{i=1}\\left\\vert a_i-b_i\\right\\vert$ 最小。\n\n## 做法\n\n首先给 $b$ 赋一个初值，使得 $b_i\\le a_i(i\\in n)$ 并且 $b_i=b_{i-1}+1(i\\in [2,n])$。\n\n在这种情况下，要想使答案更优只能增大 $b$ 序列或不变。\n\n因为 $b$ 严格递增，并且 $b_i=b_{i-1}+1$，所以要想使 $b_i$ 增加 $x$，就要对 $[i,n]$ 整个区间加上 $x$。\n\n定义 $val_i=\\begin{cases}1&a_i>b_i \\\\ -1&a_i\\le b_i\\end{cases}$，$sum_i=\\sum\\limits_{j=i}^n val_j$。\n\n然后重复执行下列操作：\n\n1. 在 $[1,n]$ 中找到最大的 $sum$ 的位置 $k$，可以发现 $b_i=b_{i-1}+1(i\\in[k+1,n])$，证明在下面。\n\n2. 设 $x=\\min\\{a_i-b_i \\}(i\\in[k,n],a_i-b_i>0)$，令 $b_i+x(i\\in[k,n])$。\n\n3. 更新 $val$ 和 $sum$。\n\n直到所有的 $sum$ 都小于等于 $0$。\n\n正确性证明：\n\n对初始序列 $b$ 执行一遍该操作显然正确。\n\n记 $last$ 为上一次操作中最大的 $sum$ 的位置，$k$ 为这次操作中最大的 $sum$ 的位置。\n\n可以得到，对于任意的 $i\\in [1,last-1]$，都有 $sum_i\\le sum_{last}$。\n\n在上一次操作中，$[last,n]$ 中至少会有一个位置的 $val$ 变为 $-1$，则 $sum_i(i\\in[1,last-1])$ 只会变得更小，所以 $k$ 不可能在 $[1,last-1]$ 中，$k$ 只会越来越靠右，因此 $b_i=b_{i-1}+1(i\\in[k+1,n])$，所以对 $b_i(i\\in [k,n])$ 执行该操作显然也正确。\n\n证毕。\n\n用线段树维护 $sum$，$set$ 维护 $[k,n]$ 中 $a_i-b_i(i\\in[k,n])$ 大于 $0$ 的元素。 \n\n每次操作用线段树求出 $[1,n]$ 中最大的 $sum$ 的位置 $k$，将 $set$ 中位置在 $[1,k-1]$ 的元素删除，在 $set$ 中查询此时 $a_i-b_i$ 的最小值，将等于该值的元素删除，并在线段树上将区间 $[1,\\text{该元素位置}]$ 中所有 $sum$ 减 $1$。\n\n由于不会添加元素，所以 $set$ 至多有 $n$ 次删除操作，线段树至多有 $n$ 次修改操作。\n\n时间复杂度为 $O(n\\log n)$。\n\n复杂度虽然正确，但常数有点大，时间卡得很紧，要开 $O2$ 才能过。\n\n## 代码\n\n```cpp\n#include <bits/stdc++.h>\n#define mk(x,y) make_pair(x,y)\n#define ls now<<1\n#define rs now<<1|1\nusing namespace std;\ntypedef long long ll;\nconst int mn=1e6+7;\nstruct tree {\n    int ans,mx,tag;\n}tr[mn<<2];\nint a[mn],sum[mn],val[mn];\nll b[mn];\nset<pair<ll,int> > st;\nint in()\n{\n    int x=0;\n    char c=getchar();\n    while(!isdigit(c))  c=getchar();\n    while(isdigit(c))\n    {\n        x=x*10+c-'0';\n        c=getchar();\n    }\n    return x;\n}\nvoid upd(int now)\n{\n    if(tr[rs].mx>=tr[ls].mx)\n      tr[now].mx=tr[rs].mx,tr[now].ans=tr[rs].ans;\n    else\n      tr[now].mx=tr[ls].mx,tr[now].ans=tr[ls].ans;\n}\nvoid build(int now,int l,int r)\n{\n    if(l==r)\n    {\n        tr[now].mx=sum[l];\n        tr[now].ans=l;\n        return ;\n    }\n    int mid=(l+r)>>1;\n    build(now<<1,l,mid);\n    build(now<<1|1,mid+1,r);\n    upd(now);\n}\nvoid push(int now)\n{\n    if(!tr[now].tag)  return ;\n    tr[now<<1].mx+=tr[now].tag;\n    tr[now<<1].tag+=tr[now].tag;\n\n    tr[now<<1|1].mx+=tr[now].tag;\n    tr[now<<1|1].tag+=tr[now].tag;\n    tr[now].tag=0;\n}\nvoid add(int now,int l,int r,int x,int v)\n{\n    if(r<=x)\n    {\n        tr[now].mx+=v;\n        tr[now].tag+=v;\n        return ;\n    }\n    push(now);\n    int mid=(l+r)>>1;\n    if(x>mid)  add(now<<1|1,mid+1,r,x,v);\n    add(now<<1,l,mid,x,v);\n    upd(now);\n}\n\nint main()\n{\n    int n,mi=1;\n    n=in();\n    ll ans=0;\n    for(int i=1;i<=n;++i)\n    {\n        a[i]=in();\n        mi=min(mi,a[i]-i+1);\n    }\n    for(int i=1;i<=n;++i)\n    {\n    \tb[i]=mi+i-1;\n    \tans+=abs(b[i]-a[i]);\n    \tif(b[i]<a[i])  val[i]=1,st.insert(mk(a[i]-b[i],i));\n    \telse  val[i]=-1;\n\t}\n    sum[n]=val[n];\n    for(int i=n-1;i>=1;--i)  sum[i]=sum[i+1]+val[i];\n    build(1,1,n);\n    int last=1,cnt=0;\n    while(1)\n    {\n        if(tr[1].mx<=0){  //终止条件\n            for(int i=last;i<=n;++i)  b[i]+=cnt;\n            break;\n        }\n        int now=tr[1].ans;  //最大的 sum 的位置\n        for(int i=last;i<now;++i){  //删除 set 中多余的元素\n            b[i]+=cnt;\n            if(a[i]-b[i]-cnt>0)  st.erase(mk(a[i]-b[i],i));\n        }\n        last=now;\n        ans-=tr[1].mx*((*st.begin()).first-cnt);\n        cnt=(*st.begin()).first;\n        while(st.size())  //删除 a-b 等于 0 的元素\n        {\n            pair<ll,int> it=*st.begin();\n            if(it.first!=cnt)  break;\n            add(1,1,n,it.second,-2);  //维护 sum\n            st.erase(st.begin());\n        }\n    }\n    printf(\"%lld\\n\",ans);\n    for(int i=1;i<=n;++i)  printf(\"%lld \",b[i]);\n    return 0;\n}\n```\n","source":"_posts/solution-P4331-sequence.md","raw":"---\nauthor: a154051\navatar: 'https://a154051-img-1321592229.cos.ap-beijing.myqcloud.com/img/头像new.jpg'\ntitle: 【题解】P4331 [BalticOI 2004]Sequence\ntags:\n  - 贪心\nmathjax: true\ndate: 2021-09-25 16:35:02\ncategories: 题解\ndescription: 贪心加数据结构\nkeywords: 贪心\nphotos: https://a154051-img-1321592229.cos.ap-beijing.myqcloud.com/img/9-25-2.jpg\n---\n[P4331 [BalticOI 2004]Sequence 数字序列](https://www.luogu.com.cn/problem/P4331)\n\n好多题解都是用的中位数做法，其实贪心就可以直接做。\n\n## 题意\n\n给定一个长度为 $n$ 的整数序列 $a$，求出一个严格递增整数序列 $b$，使得 $\\sum^n_{i=1}\\left\\vert a_i-b_i\\right\\vert$ 最小。\n\n## 做法\n\n首先给 $b$ 赋一个初值，使得 $b_i\\le a_i(i\\in n)$ 并且 $b_i=b_{i-1}+1(i\\in [2,n])$。\n\n在这种情况下，要想使答案更优只能增大 $b$ 序列或不变。\n\n因为 $b$ 严格递增，并且 $b_i=b_{i-1}+1$，所以要想使 $b_i$ 增加 $x$，就要对 $[i,n]$ 整个区间加上 $x$。\n\n定义 $val_i=\\begin{cases}1&a_i>b_i \\\\ -1&a_i\\le b_i\\end{cases}$，$sum_i=\\sum\\limits_{j=i}^n val_j$。\n\n然后重复执行下列操作：\n\n1. 在 $[1,n]$ 中找到最大的 $sum$ 的位置 $k$，可以发现 $b_i=b_{i-1}+1(i\\in[k+1,n])$，证明在下面。\n\n2. 设 $x=\\min\\{a_i-b_i \\}(i\\in[k,n],a_i-b_i>0)$，令 $b_i+x(i\\in[k,n])$。\n\n3. 更新 $val$ 和 $sum$。\n\n直到所有的 $sum$ 都小于等于 $0$。\n\n正确性证明：\n\n对初始序列 $b$ 执行一遍该操作显然正确。\n\n记 $last$ 为上一次操作中最大的 $sum$ 的位置，$k$ 为这次操作中最大的 $sum$ 的位置。\n\n可以得到，对于任意的 $i\\in [1,last-1]$，都有 $sum_i\\le sum_{last}$。\n\n在上一次操作中，$[last,n]$ 中至少会有一个位置的 $val$ 变为 $-1$，则 $sum_i(i\\in[1,last-1])$ 只会变得更小，所以 $k$ 不可能在 $[1,last-1]$ 中，$k$ 只会越来越靠右，因此 $b_i=b_{i-1}+1(i\\in[k+1,n])$，所以对 $b_i(i\\in [k,n])$ 执行该操作显然也正确。\n\n证毕。\n\n用线段树维护 $sum$，$set$ 维护 $[k,n]$ 中 $a_i-b_i(i\\in[k,n])$ 大于 $0$ 的元素。 \n\n每次操作用线段树求出 $[1,n]$ 中最大的 $sum$ 的位置 $k$，将 $set$ 中位置在 $[1,k-1]$ 的元素删除，在 $set$ 中查询此时 $a_i-b_i$ 的最小值，将等于该值的元素删除，并在线段树上将区间 $[1,\\text{该元素位置}]$ 中所有 $sum$ 减 $1$。\n\n由于不会添加元素，所以 $set$ 至多有 $n$ 次删除操作，线段树至多有 $n$ 次修改操作。\n\n时间复杂度为 $O(n\\log n)$。\n\n复杂度虽然正确，但常数有点大，时间卡得很紧，要开 $O2$ 才能过。\n\n## 代码\n\n```cpp\n#include <bits/stdc++.h>\n#define mk(x,y) make_pair(x,y)\n#define ls now<<1\n#define rs now<<1|1\nusing namespace std;\ntypedef long long ll;\nconst int mn=1e6+7;\nstruct tree {\n    int ans,mx,tag;\n}tr[mn<<2];\nint a[mn],sum[mn],val[mn];\nll b[mn];\nset<pair<ll,int> > st;\nint in()\n{\n    int x=0;\n    char c=getchar();\n    while(!isdigit(c))  c=getchar();\n    while(isdigit(c))\n    {\n        x=x*10+c-'0';\n        c=getchar();\n    }\n    return x;\n}\nvoid upd(int now)\n{\n    if(tr[rs].mx>=tr[ls].mx)\n      tr[now].mx=tr[rs].mx,tr[now].ans=tr[rs].ans;\n    else\n      tr[now].mx=tr[ls].mx,tr[now].ans=tr[ls].ans;\n}\nvoid build(int now,int l,int r)\n{\n    if(l==r)\n    {\n        tr[now].mx=sum[l];\n        tr[now].ans=l;\n        return ;\n    }\n    int mid=(l+r)>>1;\n    build(now<<1,l,mid);\n    build(now<<1|1,mid+1,r);\n    upd(now);\n}\nvoid push(int now)\n{\n    if(!tr[now].tag)  return ;\n    tr[now<<1].mx+=tr[now].tag;\n    tr[now<<1].tag+=tr[now].tag;\n\n    tr[now<<1|1].mx+=tr[now].tag;\n    tr[now<<1|1].tag+=tr[now].tag;\n    tr[now].tag=0;\n}\nvoid add(int now,int l,int r,int x,int v)\n{\n    if(r<=x)\n    {\n        tr[now].mx+=v;\n        tr[now].tag+=v;\n        return ;\n    }\n    push(now);\n    int mid=(l+r)>>1;\n    if(x>mid)  add(now<<1|1,mid+1,r,x,v);\n    add(now<<1,l,mid,x,v);\n    upd(now);\n}\n\nint main()\n{\n    int n,mi=1;\n    n=in();\n    ll ans=0;\n    for(int i=1;i<=n;++i)\n    {\n        a[i]=in();\n        mi=min(mi,a[i]-i+1);\n    }\n    for(int i=1;i<=n;++i)\n    {\n    \tb[i]=mi+i-1;\n    \tans+=abs(b[i]-a[i]);\n    \tif(b[i]<a[i])  val[i]=1,st.insert(mk(a[i]-b[i],i));\n    \telse  val[i]=-1;\n\t}\n    sum[n]=val[n];\n    for(int i=n-1;i>=1;--i)  sum[i]=sum[i+1]+val[i];\n    build(1,1,n);\n    int last=1,cnt=0;\n    while(1)\n    {\n        if(tr[1].mx<=0){  //终止条件\n            for(int i=last;i<=n;++i)  b[i]+=cnt;\n            break;\n        }\n        int now=tr[1].ans;  //最大的 sum 的位置\n        for(int i=last;i<now;++i){  //删除 set 中多余的元素\n            b[i]+=cnt;\n            if(a[i]-b[i]-cnt>0)  st.erase(mk(a[i]-b[i],i));\n        }\n        last=now;\n        ans-=tr[1].mx*((*st.begin()).first-cnt);\n        cnt=(*st.begin()).first;\n        while(st.size())  //删除 a-b 等于 0 的元素\n        {\n            pair<ll,int> it=*st.begin();\n            if(it.first!=cnt)  break;\n            add(1,1,n,it.second,-2);  //维护 sum\n            st.erase(st.begin());\n        }\n    }\n    printf(\"%lld\\n\",ans);\n    for(int i=1;i<=n;++i)  printf(\"%lld \",b[i]);\n    return 0;\n}\n```\n","slug":"solution-P4331-sequence","published":1,"updated":"2023-10-13T10:42:06.491Z","comments":1,"layout":"post","link":"","_id":"cloo2ivvx000nr8v347tm0fyg","content":"<p><a href=\"https://www.luogu.com.cn/problem/P4331\">P4331 [BalticOI 2004]Sequence 数字序列</a></p>\n<p>好多题解都是用的中位数做法，其实贪心就可以直接做。</p>\n<h2 id=\"题意\"><a href=\"#题意\" class=\"headerlink\" title=\"题意\"></a>题意</h2><p>给定一个长度为 $n$ 的整数序列 $a$，求出一个严格递增整数序列 $b$，使得 $\\sum^n_{i=1}\\left\\vert a_i-b_i\\right\\vert$ 最小。</p>\n<h2 id=\"做法\"><a href=\"#做法\" class=\"headerlink\" title=\"做法\"></a>做法</h2><p>首先给 $b$ 赋一个初值，使得 $b_i\\le a_i(i\\in n)$ 并且 $b_i=b_{i-1}+1(i\\in [2,n])$。</p>\n<p>在这种情况下，要想使答案更优只能增大 $b$ 序列或不变。</p>\n<p>因为 $b$ 严格递增，并且 $b_i=b_{i-1}+1$，所以要想使 $b_i$ 增加 $x$，就要对 $[i,n]$ 整个区间加上 $x$。</p>\n<p>定义 $val_i=\\begin{cases}1&amp;a_i&gt;b_i \\\\ -1&amp;a_i\\le b_i\\end{cases}$，$sum_i=\\sum\\limits_{j=i}^n val_j$。</p>\n<p>然后重复执行下列操作：</p>\n<ol>\n<li><p>在 $[1,n]$ 中找到最大的 $sum$ 的位置 $k$，可以发现 $b_i=b_{i-1}+1(i\\in[k+1,n])$，证明在下面。</p>\n</li>\n<li><p>设 $x=\\min\\{a_i-b_i \\}(i\\in[k,n],a_i-b_i&gt;0)$，令 $b_i+x(i\\in[k,n])$。</p>\n</li>\n<li><p>更新 $val$ 和 $sum$。</p>\n</li>\n</ol>\n<p>直到所有的 $sum$ 都小于等于 $0$。</p>\n<p>正确性证明：</p>\n<p>对初始序列 $b$ 执行一遍该操作显然正确。</p>\n<p>记 $last$ 为上一次操作中最大的 $sum$ 的位置，$k$ 为这次操作中最大的 $sum$ 的位置。</p>\n<p>可以得到，对于任意的 $i\\in [1,last-1]$，都有 $sum_i\\le sum_{last}$。</p>\n<p>在上一次操作中，$[last,n]$ 中至少会有一个位置的 $val$ 变为 $-1$，则 $sum_i(i\\in[1,last-1])$ 只会变得更小，所以 $k$ 不可能在 $[1,last-1]$ 中，$k$ 只会越来越靠右，因此 $b_i=b_{i-1}+1(i\\in[k+1,n])$，所以对 $b_i(i\\in [k,n])$ 执行该操作显然也正确。</p>\n<p>证毕。</p>\n<p>用线段树维护 $sum$，$set$ 维护 $[k,n]$ 中 $a_i-b_i(i\\in[k,n])$ 大于 $0$ 的元素。 </p>\n<p>每次操作用线段树求出 $[1,n]$ 中最大的 $sum$ 的位置 $k$，将 $set$ 中位置在 $[1,k-1]$ 的元素删除，在 $set$ 中查询此时 $a_i-b_i$ 的最小值，将等于该值的元素删除，并在线段树上将区间 $[1,\\text{该元素位置}]$ 中所有 $sum$ 减 $1$。</p>\n<p>由于不会添加元素，所以 $set$ 至多有 $n$ 次删除操作，线段树至多有 $n$ 次修改操作。</p>\n<p>时间复杂度为 $O(n\\log n)$。</p>\n<p>复杂度虽然正确，但常数有点大，时间卡得很紧，要开 $O2$ 才能过。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><pre><code class=\"lang-cpp\">#include &lt;bits/stdc++.h&gt;\n#define mk(x,y) make_pair(x,y)\n#define ls now&lt;&lt;1\n#define rs now&lt;&lt;1|1\nusing namespace std;\ntypedef long long ll;\nconst int mn=1e6+7;\nstruct tree &#123;\n    int ans,mx,tag;\n&#125;tr[mn&lt;&lt;2];\nint a[mn],sum[mn],val[mn];\nll b[mn];\nset&lt;pair&lt;ll,int&gt; &gt; st;\nint in()\n&#123;\n    int x=0;\n    char c=getchar();\n    while(!isdigit(c))  c=getchar();\n    while(isdigit(c))\n    &#123;\n        x=x*10+c-&#39;0&#39;;\n        c=getchar();\n    &#125;\n    return x;\n&#125;\nvoid upd(int now)\n&#123;\n    if(tr[rs].mx&gt;=tr[ls].mx)\n      tr[now].mx=tr[rs].mx,tr[now].ans=tr[rs].ans;\n    else\n      tr[now].mx=tr[ls].mx,tr[now].ans=tr[ls].ans;\n&#125;\nvoid build(int now,int l,int r)\n&#123;\n    if(l==r)\n    &#123;\n        tr[now].mx=sum[l];\n        tr[now].ans=l;\n        return ;\n    &#125;\n    int mid=(l+r)&gt;&gt;1;\n    build(now&lt;&lt;1,l,mid);\n    build(now&lt;&lt;1|1,mid+1,r);\n    upd(now);\n&#125;\nvoid push(int now)\n&#123;\n    if(!tr[now].tag)  return ;\n    tr[now&lt;&lt;1].mx+=tr[now].tag;\n    tr[now&lt;&lt;1].tag+=tr[now].tag;\n\n    tr[now&lt;&lt;1|1].mx+=tr[now].tag;\n    tr[now&lt;&lt;1|1].tag+=tr[now].tag;\n    tr[now].tag=0;\n&#125;\nvoid add(int now,int l,int r,int x,int v)\n&#123;\n    if(r&lt;=x)\n    &#123;\n        tr[now].mx+=v;\n        tr[now].tag+=v;\n        return ;\n    &#125;\n    push(now);\n    int mid=(l+r)&gt;&gt;1;\n    if(x&gt;mid)  add(now&lt;&lt;1|1,mid+1,r,x,v);\n    add(now&lt;&lt;1,l,mid,x,v);\n    upd(now);\n&#125;\n\nint main()\n&#123;\n    int n,mi=1;\n    n=in();\n    ll ans=0;\n    for(int i=1;i&lt;=n;++i)\n    &#123;\n        a[i]=in();\n        mi=min(mi,a[i]-i+1);\n    &#125;\n    for(int i=1;i&lt;=n;++i)\n    &#123;\n        b[i]=mi+i-1;\n        ans+=abs(b[i]-a[i]);\n        if(b[i]&lt;a[i])  val[i]=1,st.insert(mk(a[i]-b[i],i));\n        else  val[i]=-1;\n    &#125;\n    sum[n]=val[n];\n    for(int i=n-1;i&gt;=1;--i)  sum[i]=sum[i+1]+val[i];\n    build(1,1,n);\n    int last=1,cnt=0;\n    while(1)\n    &#123;\n        if(tr[1].mx&lt;=0)&#123;  //终止条件\n            for(int i=last;i&lt;=n;++i)  b[i]+=cnt;\n            break;\n        &#125;\n        int now=tr[1].ans;  //最大的 sum 的位置\n        for(int i=last;i&lt;now;++i)&#123;  //删除 set 中多余的元素\n            b[i]+=cnt;\n            if(a[i]-b[i]-cnt&gt;0)  st.erase(mk(a[i]-b[i],i));\n        &#125;\n        last=now;\n        ans-=tr[1].mx*((*st.begin()).first-cnt);\n        cnt=(*st.begin()).first;\n        while(st.size())  //删除 a-b 等于 0 的元素\n        &#123;\n            pair&lt;ll,int&gt; it=*st.begin();\n            if(it.first!=cnt)  break;\n            add(1,1,n,it.second,-2);  //维护 sum\n            st.erase(st.begin());\n        &#125;\n    &#125;\n    printf(&quot;%lld\\n&quot;,ans);\n    for(int i=1;i&lt;=n;++i)  printf(&quot;%lld &quot;,b[i]);\n    return 0;\n&#125;\n</code></pre>\n<link rel=\"stylesheet\" href=\"/css/spoiler.css\" type=\"text/css\"><script src=\"/js/spoiler.js\" type=\"text/javascript\" async></script>","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://www.luogu.com.cn/problem/P4331\">P4331 [BalticOI 2004]Sequence 数字序列</a></p>\n<p>好多题解都是用的中位数做法，其实贪心就可以直接做。</p>\n<h2 id=\"题意\"><a href=\"#题意\" class=\"headerlink\" title=\"题意\"></a>题意</h2><p>给定一个长度为 $n$ 的整数序列 $a$，求出一个严格递增整数序列 $b$，使得 $\\sum^n_{i=1}\\left\\vert a_i-b_i\\right\\vert$ 最小。</p>\n<h2 id=\"做法\"><a href=\"#做法\" class=\"headerlink\" title=\"做法\"></a>做法</h2><p>首先给 $b$ 赋一个初值，使得 $b_i\\le a_i(i\\in n)$ 并且 $b_i=b_{i-1}+1(i\\in [2,n])$。</p>\n<p>在这种情况下，要想使答案更优只能增大 $b$ 序列或不变。</p>\n<p>因为 $b$ 严格递增，并且 $b_i=b_{i-1}+1$，所以要想使 $b_i$ 增加 $x$，就要对 $[i,n]$ 整个区间加上 $x$。</p>\n<p>定义 $val_i=\\begin{cases}1&amp;a_i&gt;b_i \\\\ -1&amp;a_i\\le b_i\\end{cases}$，$sum_i=\\sum\\limits_{j=i}^n val_j$。</p>\n<p>然后重复执行下列操作：</p>\n<ol>\n<li><p>在 $[1,n]$ 中找到最大的 $sum$ 的位置 $k$，可以发现 $b_i=b_{i-1}+1(i\\in[k+1,n])$，证明在下面。</p>\n</li>\n<li><p>设 $x=\\min\\{a_i-b_i \\}(i\\in[k,n],a_i-b_i&gt;0)$，令 $b_i+x(i\\in[k,n])$。</p>\n</li>\n<li><p>更新 $val$ 和 $sum$。</p>\n</li>\n</ol>\n<p>直到所有的 $sum$ 都小于等于 $0$。</p>\n<p>正确性证明：</p>\n<p>对初始序列 $b$ 执行一遍该操作显然正确。</p>\n<p>记 $last$ 为上一次操作中最大的 $sum$ 的位置，$k$ 为这次操作中最大的 $sum$ 的位置。</p>\n<p>可以得到，对于任意的 $i\\in [1,last-1]$，都有 $sum_i\\le sum_{last}$。</p>\n<p>在上一次操作中，$[last,n]$ 中至少会有一个位置的 $val$ 变为 $-1$，则 $sum_i(i\\in[1,last-1])$ 只会变得更小，所以 $k$ 不可能在 $[1,last-1]$ 中，$k$ 只会越来越靠右，因此 $b_i=b_{i-1}+1(i\\in[k+1,n])$，所以对 $b_i(i\\in [k,n])$ 执行该操作显然也正确。</p>\n<p>证毕。</p>\n<p>用线段树维护 $sum$，$set$ 维护 $[k,n]$ 中 $a_i-b_i(i\\in[k,n])$ 大于 $0$ 的元素。 </p>\n<p>每次操作用线段树求出 $[1,n]$ 中最大的 $sum$ 的位置 $k$，将 $set$ 中位置在 $[1,k-1]$ 的元素删除，在 $set$ 中查询此时 $a_i-b_i$ 的最小值，将等于该值的元素删除，并在线段树上将区间 $[1,\\text{该元素位置}]$ 中所有 $sum$ 减 $1$。</p>\n<p>由于不会添加元素，所以 $set$ 至多有 $n$ 次删除操作，线段树至多有 $n$ 次修改操作。</p>\n<p>时间复杂度为 $O(n\\log n)$。</p>\n<p>复杂度虽然正确，但常数有点大，时间卡得很紧，要开 $O2$ 才能过。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><pre><code class=\"lang-cpp\">#include &lt;bits/stdc++.h&gt;\n#define mk(x,y) make_pair(x,y)\n#define ls now&lt;&lt;1\n#define rs now&lt;&lt;1|1\nusing namespace std;\ntypedef long long ll;\nconst int mn=1e6+7;\nstruct tree &#123;\n    int ans,mx,tag;\n&#125;tr[mn&lt;&lt;2];\nint a[mn],sum[mn],val[mn];\nll b[mn];\nset&lt;pair&lt;ll,int&gt; &gt; st;\nint in()\n&#123;\n    int x=0;\n    char c=getchar();\n    while(!isdigit(c))  c=getchar();\n    while(isdigit(c))\n    &#123;\n        x=x*10+c-&#39;0&#39;;\n        c=getchar();\n    &#125;\n    return x;\n&#125;\nvoid upd(int now)\n&#123;\n    if(tr[rs].mx&gt;=tr[ls].mx)\n      tr[now].mx=tr[rs].mx,tr[now].ans=tr[rs].ans;\n    else\n      tr[now].mx=tr[ls].mx,tr[now].ans=tr[ls].ans;\n&#125;\nvoid build(int now,int l,int r)\n&#123;\n    if(l==r)\n    &#123;\n        tr[now].mx=sum[l];\n        tr[now].ans=l;\n        return ;\n    &#125;\n    int mid=(l+r)&gt;&gt;1;\n    build(now&lt;&lt;1,l,mid);\n    build(now&lt;&lt;1|1,mid+1,r);\n    upd(now);\n&#125;\nvoid push(int now)\n&#123;\n    if(!tr[now].tag)  return ;\n    tr[now&lt;&lt;1].mx+=tr[now].tag;\n    tr[now&lt;&lt;1].tag+=tr[now].tag;\n\n    tr[now&lt;&lt;1|1].mx+=tr[now].tag;\n    tr[now&lt;&lt;1|1].tag+=tr[now].tag;\n    tr[now].tag=0;\n&#125;\nvoid add(int now,int l,int r,int x,int v)\n&#123;\n    if(r&lt;=x)\n    &#123;\n        tr[now].mx+=v;\n        tr[now].tag+=v;\n        return ;\n    &#125;\n    push(now);\n    int mid=(l+r)&gt;&gt;1;\n    if(x&gt;mid)  add(now&lt;&lt;1|1,mid+1,r,x,v);\n    add(now&lt;&lt;1,l,mid,x,v);\n    upd(now);\n&#125;\n\nint main()\n&#123;\n    int n,mi=1;\n    n=in();\n    ll ans=0;\n    for(int i=1;i&lt;=n;++i)\n    &#123;\n        a[i]=in();\n        mi=min(mi,a[i]-i+1);\n    &#125;\n    for(int i=1;i&lt;=n;++i)\n    &#123;\n        b[i]=mi+i-1;\n        ans+=abs(b[i]-a[i]);\n        if(b[i]&lt;a[i])  val[i]=1,st.insert(mk(a[i]-b[i],i));\n        else  val[i]=-1;\n    &#125;\n    sum[n]=val[n];\n    for(int i=n-1;i&gt;=1;--i)  sum[i]=sum[i+1]+val[i];\n    build(1,1,n);\n    int last=1,cnt=0;\n    while(1)\n    &#123;\n        if(tr[1].mx&lt;=0)&#123;  //终止条件\n            for(int i=last;i&lt;=n;++i)  b[i]+=cnt;\n            break;\n        &#125;\n        int now=tr[1].ans;  //最大的 sum 的位置\n        for(int i=last;i&lt;now;++i)&#123;  //删除 set 中多余的元素\n            b[i]+=cnt;\n            if(a[i]-b[i]-cnt&gt;0)  st.erase(mk(a[i]-b[i],i));\n        &#125;\n        last=now;\n        ans-=tr[1].mx*((*st.begin()).first-cnt);\n        cnt=(*st.begin()).first;\n        while(st.size())  //删除 a-b 等于 0 的元素\n        &#123;\n            pair&lt;ll,int&gt; it=*st.begin();\n            if(it.first!=cnt)  break;\n            add(1,1,n,it.second,-2);  //维护 sum\n            st.erase(st.begin());\n        &#125;\n    &#125;\n    printf(&quot;%lld\\n&quot;,ans);\n    for(int i=1;i&lt;=n;++i)  printf(&quot;%lld &quot;,b[i]);\n    return 0;\n&#125;\n</code></pre>\n"},{"author":"a154051","avatar":"https://a154051-img-1321592229.cos.ap-beijing.myqcloud.com/img/头像new.jpg","title":"【题解】P6310 [Wdsr-1]仓库建设","mathjax":true,"date":"2023-09-25T15:17:51.000Z","description":"Kruskal重构树好题","keywords":"Kruskal重构树","photos":["https://a154051-img-1321592229.cos.ap-beijing.myqcloud.com/img/23-9-26.jpg"],"_content":"\n[P6310 「Wdsr-1」仓库建设 ](https://www.luogu.com.cn/problem/P6310)\n\n两年没写题解了，本来想找个蓝题练练手，结果被狠狠薄纱了，硬刚了半天才写出来。变量名极为抽象，写到后面我自己都搞混了。\n\n## 题意\n\n给定一张无向联通图，边有边权，可以选择一些城市发出粮车，第 $i$ 座城市的粮车的油量可以行驶的路程为 $x_i$，每到一个城市都会加满油，第一问为求最少选择几个城市可以覆盖所有城市，第二问为当第 $i$ 个城市无法选择时最少选择多少城市才能满足条件，如果不能则输出 $-1$。\n\n## 题解\n\n显然我们希望路径中最大的边权最小，自然想到了 Kruskal 重构树，重构树的叶子节点为原图的 $n$ 个节点，其他节点代表原图的一条边，点权即是边权，深度越浅的点点权越大。\n\n设 $val$ 表示点权，从某个叶子节点 $i$ 向上找到最浅的节点 $j$ 满足 $val_j \\le x_i$，记为 $fa_i$，如果选择了 $i$，则以 $fa_i$ 为根的子树的叶子节点都可以被覆盖。显然如果某条路径上有多个 $fa_i$ 我们要选择深度最浅的那个，则该子树内的其他点都不用选。\n\n所以第一问只需要从根节点向下遍历，遇到 $fa$ 节点就将计数器加一，并直接返回，不用遍历该子树。\n\n对于第二问，假设当前无法选择的节点为 $i$，如果 $fa_i$ 不是第一问选择的节点，则答案不变。\n\n如果从 $i$ 到根的路径上只有 $fa_i$，若 $\\exists j \\neq i,fa_j = fa_i$ 则答案不变，若这样的 $j$ 不存在，则无法到达 $i$，答案为 $-1$。\n\n如果 $fa_i$ 是第一问选择的节点且从 $i$ 到根的路径上还有其他的 $fa$，则只需要在 $fa_i$ 子树内选择深度最浅的几个 $fa$ 节点就能覆盖所有点，像第一问一样在 $fa_i$ 的子树内遍历，遇到 $fa$ 节点就将计数器加一，并直接返回，不用遍历该子树，最后将第一问的答案减一再加上计数器就是最终答案。\n\n向上找 $fa$ 用倍增实现，其他值都可以一次 dfs 求出来，总时间复杂度为 $O(n \\log n)$。\n\n## 代码\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nconst int N=3e5+7;\nstruct edge {\n    int u,v,w;\n}e[N];\nint a[N],fa[N],val[N<<1],f[N<<1][21],dep[N<<1],cnt[N<<1],num[N],leaf[N<<1],up[N<<1];\n//cnt是统计某个fa节点的子树内有多少个深度最浅的fa节点，num是从叶子节点到根有多少fa节点\n//leaf是某个fa节点对应的叶子节点有几个，up是距离fa节点最近的祖先fa节点\nbool vis[N<<1];\nvector<int> son[N<<1];\nbool cmp(edge x,edge y){return x.w<y.w;}\nint fd(int x) {\n    if(!fa[x])  return x;\n    return fa[x]=fd(fa[x]);\n}\nvoid dfs1(int x,int FA)\n{\n    dep[x]=dep[FA]+1;f[x][0]=FA;\n    for(int i=0;i<son[x].size();++i)  dfs1(son[x][i],x);\n}\nvoid dfs2(int x,int FA,int CNT)\n{\n    if(vis[x])  ++cnt[FA],++CNT,up[x]=FA;\n    for(int i=0;i<son[x].size();++i) {\n        if(vis[x])  dfs2(son[x][i],x,CNT);\n        else  dfs2(son[x][i],FA,CNT);\n    }\n    if(!son[x].size())  num[x]=CNT;\n}\nint main()\n{\n    int n,m;\n    cin>>n>>m;\n    int tot=n;\n    for(int i=1;i<=m;++i)  scanf(\"%d%d%d\",&e[i].u,&e[i].v,&e[i].w);\n    sort(e+1,e+1+m,cmp);\n    for(int i=1;i<=m;++i) {\n        int x=fd(e[i].u),y=fd(e[i].v);\n        if(x!=y) {\n            fa[x]=fa[y]=++tot;\n            son[tot].push_back(x);\n            son[tot].push_back(y);\n            val[tot]=e[i].w;\n        }\n    }\n    for(int i=1;i<=n;++i)  scanf(\"%d\",&a[i]);\n    dfs1(tot,0);\n    for(int j=1;j<=20;++j)\n        for(int i=1;i<=tot;++i)\n            f[i][j]=f[f[i][j-1]][j-1];\n    for(int i=1;i<=n;++i) {\n        int now=i;\n        for(int j=20;j>=0;--j)\n            if(f[now][j]&&a[i]>=val[f[now][j]])  now=f[now][j];\n        vis[now]=1;\n        fa[i]=now;\n        ++leaf[now];\n    }\n    dfs2(tot,0,0);\n    printf(\"%d \",cnt[0]);\n    for(int i=1;i<=n;++i) {\n        if(num[i]==1&&leaf[fa[i]]<=1)  printf(\"-1 \");\n        else if(up[fa[i]]||leaf[fa[i]]>1)  printf(\"%d \",cnt[0]);\n        else printf(\"%d \",cnt[0]-1+cnt[fa[i]]);\n    }\n    return 0;\n}\n```\n\n","source":"_posts/solution-P6310-cang-ku-jian-she.md","raw":"---\nauthor: a154051\navatar: 'https://a154051-img-1321592229.cos.ap-beijing.myqcloud.com/img/头像new.jpg'\ntitle: 【题解】P6310 [Wdsr-1]仓库建设\ntags:\n  - Kruskal重构树\nmathjax: true\ndate: 2023-09-25 23:17:51\ncategories: 题解\ndescription: Kruskal重构树好题\nkeywords: Kruskal重构树\nphotos: https://a154051-img-1321592229.cos.ap-beijing.myqcloud.com/img/23-9-26.jpg\n---\n\n[P6310 「Wdsr-1」仓库建设 ](https://www.luogu.com.cn/problem/P6310)\n\n两年没写题解了，本来想找个蓝题练练手，结果被狠狠薄纱了，硬刚了半天才写出来。变量名极为抽象，写到后面我自己都搞混了。\n\n## 题意\n\n给定一张无向联通图，边有边权，可以选择一些城市发出粮车，第 $i$ 座城市的粮车的油量可以行驶的路程为 $x_i$，每到一个城市都会加满油，第一问为求最少选择几个城市可以覆盖所有城市，第二问为当第 $i$ 个城市无法选择时最少选择多少城市才能满足条件，如果不能则输出 $-1$。\n\n## 题解\n\n显然我们希望路径中最大的边权最小，自然想到了 Kruskal 重构树，重构树的叶子节点为原图的 $n$ 个节点，其他节点代表原图的一条边，点权即是边权，深度越浅的点点权越大。\n\n设 $val$ 表示点权，从某个叶子节点 $i$ 向上找到最浅的节点 $j$ 满足 $val_j \\le x_i$，记为 $fa_i$，如果选择了 $i$，则以 $fa_i$ 为根的子树的叶子节点都可以被覆盖。显然如果某条路径上有多个 $fa_i$ 我们要选择深度最浅的那个，则该子树内的其他点都不用选。\n\n所以第一问只需要从根节点向下遍历，遇到 $fa$ 节点就将计数器加一，并直接返回，不用遍历该子树。\n\n对于第二问，假设当前无法选择的节点为 $i$，如果 $fa_i$ 不是第一问选择的节点，则答案不变。\n\n如果从 $i$ 到根的路径上只有 $fa_i$，若 $\\exists j \\neq i,fa_j = fa_i$ 则答案不变，若这样的 $j$ 不存在，则无法到达 $i$，答案为 $-1$。\n\n如果 $fa_i$ 是第一问选择的节点且从 $i$ 到根的路径上还有其他的 $fa$，则只需要在 $fa_i$ 子树内选择深度最浅的几个 $fa$ 节点就能覆盖所有点，像第一问一样在 $fa_i$ 的子树内遍历，遇到 $fa$ 节点就将计数器加一，并直接返回，不用遍历该子树，最后将第一问的答案减一再加上计数器就是最终答案。\n\n向上找 $fa$ 用倍增实现，其他值都可以一次 dfs 求出来，总时间复杂度为 $O(n \\log n)$。\n\n## 代码\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nconst int N=3e5+7;\nstruct edge {\n    int u,v,w;\n}e[N];\nint a[N],fa[N],val[N<<1],f[N<<1][21],dep[N<<1],cnt[N<<1],num[N],leaf[N<<1],up[N<<1];\n//cnt是统计某个fa节点的子树内有多少个深度最浅的fa节点，num是从叶子节点到根有多少fa节点\n//leaf是某个fa节点对应的叶子节点有几个，up是距离fa节点最近的祖先fa节点\nbool vis[N<<1];\nvector<int> son[N<<1];\nbool cmp(edge x,edge y){return x.w<y.w;}\nint fd(int x) {\n    if(!fa[x])  return x;\n    return fa[x]=fd(fa[x]);\n}\nvoid dfs1(int x,int FA)\n{\n    dep[x]=dep[FA]+1;f[x][0]=FA;\n    for(int i=0;i<son[x].size();++i)  dfs1(son[x][i],x);\n}\nvoid dfs2(int x,int FA,int CNT)\n{\n    if(vis[x])  ++cnt[FA],++CNT,up[x]=FA;\n    for(int i=0;i<son[x].size();++i) {\n        if(vis[x])  dfs2(son[x][i],x,CNT);\n        else  dfs2(son[x][i],FA,CNT);\n    }\n    if(!son[x].size())  num[x]=CNT;\n}\nint main()\n{\n    int n,m;\n    cin>>n>>m;\n    int tot=n;\n    for(int i=1;i<=m;++i)  scanf(\"%d%d%d\",&e[i].u,&e[i].v,&e[i].w);\n    sort(e+1,e+1+m,cmp);\n    for(int i=1;i<=m;++i) {\n        int x=fd(e[i].u),y=fd(e[i].v);\n        if(x!=y) {\n            fa[x]=fa[y]=++tot;\n            son[tot].push_back(x);\n            son[tot].push_back(y);\n            val[tot]=e[i].w;\n        }\n    }\n    for(int i=1;i<=n;++i)  scanf(\"%d\",&a[i]);\n    dfs1(tot,0);\n    for(int j=1;j<=20;++j)\n        for(int i=1;i<=tot;++i)\n            f[i][j]=f[f[i][j-1]][j-1];\n    for(int i=1;i<=n;++i) {\n        int now=i;\n        for(int j=20;j>=0;--j)\n            if(f[now][j]&&a[i]>=val[f[now][j]])  now=f[now][j];\n        vis[now]=1;\n        fa[i]=now;\n        ++leaf[now];\n    }\n    dfs2(tot,0,0);\n    printf(\"%d \",cnt[0]);\n    for(int i=1;i<=n;++i) {\n        if(num[i]==1&&leaf[fa[i]]<=1)  printf(\"-1 \");\n        else if(up[fa[i]]||leaf[fa[i]]>1)  printf(\"%d \",cnt[0]);\n        else printf(\"%d \",cnt[0]-1+cnt[fa[i]]);\n    }\n    return 0;\n}\n```\n\n","slug":"solution-P6310-cang-ku-jian-she","published":1,"updated":"2023-10-13T12:58:30.089Z","comments":1,"layout":"post","link":"","_id":"cloo2ivvy000rr8v35cpr66j1","content":"<p><a href=\"https://www.luogu.com.cn/problem/P6310\">P6310 「Wdsr-1」仓库建设 </a></p>\n<p>两年没写题解了，本来想找个蓝题练练手，结果被狠狠薄纱了，硬刚了半天才写出来。变量名极为抽象，写到后面我自己都搞混了。</p>\n<h2 id=\"题意\"><a href=\"#题意\" class=\"headerlink\" title=\"题意\"></a>题意</h2><p>给定一张无向联通图，边有边权，可以选择一些城市发出粮车，第 $i$ 座城市的粮车的油量可以行驶的路程为 $x_i$，每到一个城市都会加满油，第一问为求最少选择几个城市可以覆盖所有城市，第二问为当第 $i$ 个城市无法选择时最少选择多少城市才能满足条件，如果不能则输出 $-1$。</p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>显然我们希望路径中最大的边权最小，自然想到了 Kruskal 重构树，重构树的叶子节点为原图的 $n$ 个节点，其他节点代表原图的一条边，点权即是边权，深度越浅的点点权越大。</p>\n<p>设 $val$ 表示点权，从某个叶子节点 $i$ 向上找到最浅的节点 $j$ 满足 $val_j \\le x_i$，记为 $fa_i$，如果选择了 $i$，则以 $fa_i$ 为根的子树的叶子节点都可以被覆盖。显然如果某条路径上有多个 $fa_i$ 我们要选择深度最浅的那个，则该子树内的其他点都不用选。</p>\n<p>所以第一问只需要从根节点向下遍历，遇到 $fa$ 节点就将计数器加一，并直接返回，不用遍历该子树。</p>\n<p>对于第二问，假设当前无法选择的节点为 $i$，如果 $fa_i$ 不是第一问选择的节点，则答案不变。</p>\n<p>如果从 $i$ 到根的路径上只有 $fa_i$，若 $\\exists j \\neq i,fa_j = fa_i$ 则答案不变，若这样的 $j$ 不存在，则无法到达 $i$，答案为 $-1$。</p>\n<p>如果 $fa_i$ 是第一问选择的节点且从 $i$ 到根的路径上还有其他的 $fa$，则只需要在 $fa_i$ 子树内选择深度最浅的几个 $fa$ 节点就能覆盖所有点，像第一问一样在 $fa_i$ 的子树内遍历，遇到 $fa$ 节点就将计数器加一，并直接返回，不用遍历该子树，最后将第一问的答案减一再加上计数器就是最终答案。</p>\n<p>向上找 $fa$ 用倍增实现，其他值都可以一次 dfs 求出来，总时间复杂度为 $O(n \\log n)$。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><pre><code class=\"lang-cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N=3e5+7;\nstruct edge &#123;\n    int u,v,w;\n&#125;e[N];\nint a[N],fa[N],val[N&lt;&lt;1],f[N&lt;&lt;1][21],dep[N&lt;&lt;1],cnt[N&lt;&lt;1],num[N],leaf[N&lt;&lt;1],up[N&lt;&lt;1];\n//cnt是统计某个fa节点的子树内有多少个深度最浅的fa节点，num是从叶子节点到根有多少fa节点\n//leaf是某个fa节点对应的叶子节点有几个，up是距离fa节点最近的祖先fa节点\nbool vis[N&lt;&lt;1];\nvector&lt;int&gt; son[N&lt;&lt;1];\nbool cmp(edge x,edge y)&#123;return x.w&lt;y.w;&#125;\nint fd(int x) &#123;\n    if(!fa[x])  return x;\n    return fa[x]=fd(fa[x]);\n&#125;\nvoid dfs1(int x,int FA)\n&#123;\n    dep[x]=dep[FA]+1;f[x][0]=FA;\n    for(int i=0;i&lt;son[x].size();++i)  dfs1(son[x][i],x);\n&#125;\nvoid dfs2(int x,int FA,int CNT)\n&#123;\n    if(vis[x])  ++cnt[FA],++CNT,up[x]=FA;\n    for(int i=0;i&lt;son[x].size();++i) &#123;\n        if(vis[x])  dfs2(son[x][i],x,CNT);\n        else  dfs2(son[x][i],FA,CNT);\n    &#125;\n    if(!son[x].size())  num[x]=CNT;\n&#125;\nint main()\n&#123;\n    int n,m;\n    cin&gt;&gt;n&gt;&gt;m;\n    int tot=n;\n    for(int i=1;i&lt;=m;++i)  scanf(&quot;%d%d%d&quot;,&amp;e[i].u,&amp;e[i].v,&amp;e[i].w);\n    sort(e+1,e+1+m,cmp);\n    for(int i=1;i&lt;=m;++i) &#123;\n        int x=fd(e[i].u),y=fd(e[i].v);\n        if(x!=y) &#123;\n            fa[x]=fa[y]=++tot;\n            son[tot].push_back(x);\n            son[tot].push_back(y);\n            val[tot]=e[i].w;\n        &#125;\n    &#125;\n    for(int i=1;i&lt;=n;++i)  scanf(&quot;%d&quot;,&amp;a[i]);\n    dfs1(tot,0);\n    for(int j=1;j&lt;=20;++j)\n        for(int i=1;i&lt;=tot;++i)\n            f[i][j]=f[f[i][j-1]][j-1];\n    for(int i=1;i&lt;=n;++i) &#123;\n        int now=i;\n        for(int j=20;j&gt;=0;--j)\n            if(f[now][j]&amp;&amp;a[i]&gt;=val[f[now][j]])  now=f[now][j];\n        vis[now]=1;\n        fa[i]=now;\n        ++leaf[now];\n    &#125;\n    dfs2(tot,0,0);\n    printf(&quot;%d &quot;,cnt[0]);\n    for(int i=1;i&lt;=n;++i) &#123;\n        if(num[i]==1&amp;&amp;leaf[fa[i]]&lt;=1)  printf(&quot;-1 &quot;);\n        else if(up[fa[i]]||leaf[fa[i]]&gt;1)  printf(&quot;%d &quot;,cnt[0]);\n        else printf(&quot;%d &quot;,cnt[0]-1+cnt[fa[i]]);\n    &#125;\n    return 0;\n&#125;\n</code></pre>\n<link rel=\"stylesheet\" href=\"/css/spoiler.css\" type=\"text/css\"><script src=\"/js/spoiler.js\" type=\"text/javascript\" async></script>","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://www.luogu.com.cn/problem/P6310\">P6310 「Wdsr-1」仓库建设 </a></p>\n<p>两年没写题解了，本来想找个蓝题练练手，结果被狠狠薄纱了，硬刚了半天才写出来。变量名极为抽象，写到后面我自己都搞混了。</p>\n<h2 id=\"题意\"><a href=\"#题意\" class=\"headerlink\" title=\"题意\"></a>题意</h2><p>给定一张无向联通图，边有边权，可以选择一些城市发出粮车，第 $i$ 座城市的粮车的油量可以行驶的路程为 $x_i$，每到一个城市都会加满油，第一问为求最少选择几个城市可以覆盖所有城市，第二问为当第 $i$ 个城市无法选择时最少选择多少城市才能满足条件，如果不能则输出 $-1$。</p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>显然我们希望路径中最大的边权最小，自然想到了 Kruskal 重构树，重构树的叶子节点为原图的 $n$ 个节点，其他节点代表原图的一条边，点权即是边权，深度越浅的点点权越大。</p>\n<p>设 $val$ 表示点权，从某个叶子节点 $i$ 向上找到最浅的节点 $j$ 满足 $val_j \\le x_i$，记为 $fa_i$，如果选择了 $i$，则以 $fa_i$ 为根的子树的叶子节点都可以被覆盖。显然如果某条路径上有多个 $fa_i$ 我们要选择深度最浅的那个，则该子树内的其他点都不用选。</p>\n<p>所以第一问只需要从根节点向下遍历，遇到 $fa$ 节点就将计数器加一，并直接返回，不用遍历该子树。</p>\n<p>对于第二问，假设当前无法选择的节点为 $i$，如果 $fa_i$ 不是第一问选择的节点，则答案不变。</p>\n<p>如果从 $i$ 到根的路径上只有 $fa_i$，若 $\\exists j \\neq i,fa_j = fa_i$ 则答案不变，若这样的 $j$ 不存在，则无法到达 $i$，答案为 $-1$。</p>\n<p>如果 $fa_i$ 是第一问选择的节点且从 $i$ 到根的路径上还有其他的 $fa$，则只需要在 $fa_i$ 子树内选择深度最浅的几个 $fa$ 节点就能覆盖所有点，像第一问一样在 $fa_i$ 的子树内遍历，遇到 $fa$ 节点就将计数器加一，并直接返回，不用遍历该子树，最后将第一问的答案减一再加上计数器就是最终答案。</p>\n<p>向上找 $fa$ 用倍增实现，其他值都可以一次 dfs 求出来，总时间复杂度为 $O(n \\log n)$。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><pre><code class=\"lang-cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N=3e5+7;\nstruct edge &#123;\n    int u,v,w;\n&#125;e[N];\nint a[N],fa[N],val[N&lt;&lt;1],f[N&lt;&lt;1][21],dep[N&lt;&lt;1],cnt[N&lt;&lt;1],num[N],leaf[N&lt;&lt;1],up[N&lt;&lt;1];\n//cnt是统计某个fa节点的子树内有多少个深度最浅的fa节点，num是从叶子节点到根有多少fa节点\n//leaf是某个fa节点对应的叶子节点有几个，up是距离fa节点最近的祖先fa节点\nbool vis[N&lt;&lt;1];\nvector&lt;int&gt; son[N&lt;&lt;1];\nbool cmp(edge x,edge y)&#123;return x.w&lt;y.w;&#125;\nint fd(int x) &#123;\n    if(!fa[x])  return x;\n    return fa[x]=fd(fa[x]);\n&#125;\nvoid dfs1(int x,int FA)\n&#123;\n    dep[x]=dep[FA]+1;f[x][0]=FA;\n    for(int i=0;i&lt;son[x].size();++i)  dfs1(son[x][i],x);\n&#125;\nvoid dfs2(int x,int FA,int CNT)\n&#123;\n    if(vis[x])  ++cnt[FA],++CNT,up[x]=FA;\n    for(int i=0;i&lt;son[x].size();++i) &#123;\n        if(vis[x])  dfs2(son[x][i],x,CNT);\n        else  dfs2(son[x][i],FA,CNT);\n    &#125;\n    if(!son[x].size())  num[x]=CNT;\n&#125;\nint main()\n&#123;\n    int n,m;\n    cin&gt;&gt;n&gt;&gt;m;\n    int tot=n;\n    for(int i=1;i&lt;=m;++i)  scanf(&quot;%d%d%d&quot;,&amp;e[i].u,&amp;e[i].v,&amp;e[i].w);\n    sort(e+1,e+1+m,cmp);\n    for(int i=1;i&lt;=m;++i) &#123;\n        int x=fd(e[i].u),y=fd(e[i].v);\n        if(x!=y) &#123;\n            fa[x]=fa[y]=++tot;\n            son[tot].push_back(x);\n            son[tot].push_back(y);\n            val[tot]=e[i].w;\n        &#125;\n    &#125;\n    for(int i=1;i&lt;=n;++i)  scanf(&quot;%d&quot;,&amp;a[i]);\n    dfs1(tot,0);\n    for(int j=1;j&lt;=20;++j)\n        for(int i=1;i&lt;=tot;++i)\n            f[i][j]=f[f[i][j-1]][j-1];\n    for(int i=1;i&lt;=n;++i) &#123;\n        int now=i;\n        for(int j=20;j&gt;=0;--j)\n            if(f[now][j]&amp;&amp;a[i]&gt;=val[f[now][j]])  now=f[now][j];\n        vis[now]=1;\n        fa[i]=now;\n        ++leaf[now];\n    &#125;\n    dfs2(tot,0,0);\n    printf(&quot;%d &quot;,cnt[0]);\n    for(int i=1;i&lt;=n;++i) &#123;\n        if(num[i]==1&amp;&amp;leaf[fa[i]]&lt;=1)  printf(&quot;-1 &quot;);\n        else if(up[fa[i]]||leaf[fa[i]]&gt;1)  printf(&quot;%d &quot;,cnt[0]);\n        else printf(&quot;%d &quot;,cnt[0]-1+cnt[fa[i]]);\n    &#125;\n    return 0;\n&#125;\n</code></pre>\n"},{"title":"【题解】P6394樱花，还有你","author":"a154051","avatar":"https://a154051-img-1321592229.cos.ap-beijing.myqcloud.com/img/头像new.jpg","date":"2021-02-27T03:14:00.000Z","mathjax":true,"keywords":"题解P6394樱花，还有你","description":"基础DP优化好题","photos":["https://a154051-img-1321592229.cos.ap-beijing.myqcloud.com/img/SakuraAndYou.jpg"],"_content":"[P6394 樱花，还有你](https://www.luogu.com.cn/problem/P6394)\n\n题面好浪漫，~~可惜我是11月11日写的这题~~。\n\n# 题意\n\n有 $k$ 棵树，每棵树上有 $s_i$ 朵花，有几种方案能恰好取 $n$ 朵花，若收集不到 $n$ 朵花，输出**impossible**。\n\n**注意**：用 $(a_1,a_2,⋯)$ 表示一种方案，则 $(1,1,1)$ 和 $(1,1,1,0)$ 是两种不同的方案。\n\n# 分析\n## Subtask 1\n\n$\\sum s_i<n$\n\n白给，直接输出**impossible**即可。\n\n## Subtask 2&3\n\n$n,k \\le 5\\times10^2$\n\n定义 $f(i,j)$ 表示前 $i$ 棵树收集 $j$ 朵花的方案数。\n\n显然有状态转移方程：\n\n$$f(i,j)=\\sum\\limits_{x=0}^{\\min(j,s_i)}f(i-1,j-x)$$\n\n最终答案为 $\\sum_{i=1}^{k}f(i,n)$。\n\n时间复杂度：$O(n^2k)$，空间复杂度：$O(nk)$。\n\n## Subtask 4\n\n$n,k \\le 5\\times10^3$\n\n$O(n^2k)$ 的复杂度会超时，需要优化。\n\n发现可以用前缀和优化掉最里面一层循环。\n\n定义 $sum(i,j)=\\sum_{x=0}^j f(i,x)$。\n\n所以\n\n$$f(i,j)=sum(i-1,j)-sum(i-1,j-\\min(j,s_i)-1)$$\n\n为了避免数组下标为负数，应改为\n\n$$f(i,j)=sum(i-1,j)-sum(i-1,j-\\min(j,s_i))+f(i-1,j-\\min(j,s_i)$$\n\n时间复杂度：$O(nk)$。\n\n这时候发现~~无耻~~出题人只给了 $64MB$，内存会炸。\n\n观察上述转移方程，发现 $f$ 数组和 $sum$ 数组只用到了这一层和上一层，所以只存这两层就好。\n\n空间复杂度：$O(n)$。\n\n# 代码\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nconst int mn=5e3+7,mod=10086001;\nint s[mn],f[2][mn],sum[2][mn];\nint now;  //now为当前这一层，now^1为上一层 \nint min1(int x,int y)\n{\n\treturn x<y?x:y;\n}\nint main()\n{\n\tint n,k,cnt=0;\n\tcin>>n>>k;\n\tf[0][0]=sum[0][0]=f[1][0]=sum[1][0]=1;\n\tfor(int i=1;i<=k;++i)\n\t  scanf(\"%d\",&s[i]),cnt+=s[i];\n\tif(cnt<n)\n\t{\n\t\tcout<<\"impossible\";\n\t\treturn 0;\n\t}\n\tint ans=0;\n\tfor(int i=1;i<=k;++i)\n\t{\n\t\tnow=i&1;  //相当于now=i%2 \n\t\tfor(int j=1;j<=n;++j)\n\t\t{\n\t\t\tsum[now^1][j]=(sum[now^1][j-1]+f[now^1][j])%mod;\n\t\t\tf[now][j]=(sum[now^1][j]-sum[now^1][j-min1(j,s[i])]+f[now^1][j-min1(j,s[i])])%mod;\n\t\t\twhile(f[now][j]<0)  f[now][j]+=mod;  //取模后相减有可能出现负数 \n\t\t}\n\t\tans=(ans+f[now][n])%mod;\n\t}\n\tcout<<ans;\n\treturn 0;\n}\n```\n","source":"_posts/solution-P6394-ying-hua.md","raw":"---\ntitle: 【题解】P6394樱花，还有你\nauthor: a154051\navatar: https://a154051-img-1321592229.cos.ap-beijing.myqcloud.com/img/头像new.jpg\ncategories: 题解\ndate: 2021-02-27 11:14:00\nmathjax: true\ntags: \n - DP\nkeywords: 题解P6394樱花，还有你\ndescription: 基础DP优化好题\nphotos: https://a154051-img-1321592229.cos.ap-beijing.myqcloud.com/img/SakuraAndYou.jpg\n---\n[P6394 樱花，还有你](https://www.luogu.com.cn/problem/P6394)\n\n题面好浪漫，~~可惜我是11月11日写的这题~~。\n\n# 题意\n\n有 $k$ 棵树，每棵树上有 $s_i$ 朵花，有几种方案能恰好取 $n$ 朵花，若收集不到 $n$ 朵花，输出**impossible**。\n\n**注意**：用 $(a_1,a_2,⋯)$ 表示一种方案，则 $(1,1,1)$ 和 $(1,1,1,0)$ 是两种不同的方案。\n\n# 分析\n## Subtask 1\n\n$\\sum s_i<n$\n\n白给，直接输出**impossible**即可。\n\n## Subtask 2&3\n\n$n,k \\le 5\\times10^2$\n\n定义 $f(i,j)$ 表示前 $i$ 棵树收集 $j$ 朵花的方案数。\n\n显然有状态转移方程：\n\n$$f(i,j)=\\sum\\limits_{x=0}^{\\min(j,s_i)}f(i-1,j-x)$$\n\n最终答案为 $\\sum_{i=1}^{k}f(i,n)$。\n\n时间复杂度：$O(n^2k)$，空间复杂度：$O(nk)$。\n\n## Subtask 4\n\n$n,k \\le 5\\times10^3$\n\n$O(n^2k)$ 的复杂度会超时，需要优化。\n\n发现可以用前缀和优化掉最里面一层循环。\n\n定义 $sum(i,j)=\\sum_{x=0}^j f(i,x)$。\n\n所以\n\n$$f(i,j)=sum(i-1,j)-sum(i-1,j-\\min(j,s_i)-1)$$\n\n为了避免数组下标为负数，应改为\n\n$$f(i,j)=sum(i-1,j)-sum(i-1,j-\\min(j,s_i))+f(i-1,j-\\min(j,s_i)$$\n\n时间复杂度：$O(nk)$。\n\n这时候发现~~无耻~~出题人只给了 $64MB$，内存会炸。\n\n观察上述转移方程，发现 $f$ 数组和 $sum$ 数组只用到了这一层和上一层，所以只存这两层就好。\n\n空间复杂度：$O(n)$。\n\n# 代码\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nconst int mn=5e3+7,mod=10086001;\nint s[mn],f[2][mn],sum[2][mn];\nint now;  //now为当前这一层，now^1为上一层 \nint min1(int x,int y)\n{\n\treturn x<y?x:y;\n}\nint main()\n{\n\tint n,k,cnt=0;\n\tcin>>n>>k;\n\tf[0][0]=sum[0][0]=f[1][0]=sum[1][0]=1;\n\tfor(int i=1;i<=k;++i)\n\t  scanf(\"%d\",&s[i]),cnt+=s[i];\n\tif(cnt<n)\n\t{\n\t\tcout<<\"impossible\";\n\t\treturn 0;\n\t}\n\tint ans=0;\n\tfor(int i=1;i<=k;++i)\n\t{\n\t\tnow=i&1;  //相当于now=i%2 \n\t\tfor(int j=1;j<=n;++j)\n\t\t{\n\t\t\tsum[now^1][j]=(sum[now^1][j-1]+f[now^1][j])%mod;\n\t\t\tf[now][j]=(sum[now^1][j]-sum[now^1][j-min1(j,s[i])]+f[now^1][j-min1(j,s[i])])%mod;\n\t\t\twhile(f[now][j]<0)  f[now][j]+=mod;  //取模后相减有可能出现负数 \n\t\t}\n\t\tans=(ans+f[now][n])%mod;\n\t}\n\tcout<<ans;\n\treturn 0;\n}\n```\n","slug":"solution-P6394-ying-hua","published":1,"updated":"2023-10-13T10:42:06.493Z","comments":1,"layout":"post","link":"","_id":"cloo2ivw0000vr8v3c92449kh","content":"<p><a href=\"https://www.luogu.com.cn/problem/P6394\">P6394 樱花，还有你</a></p>\n<p>题面好浪漫，<del>可惜我是11月11日写的这题</del>。</p>\n<h1 id=\"题意\"><a href=\"#题意\" class=\"headerlink\" title=\"题意\"></a>题意</h1><p>有 $k$ 棵树，每棵树上有 $s_i$ 朵花，有几种方案能恰好取 $n$ 朵花，若收集不到 $n$ 朵花，输出<strong>impossible</strong>。</p>\n<p><strong>注意</strong>：用 $(a_1,a_2,⋯)$ 表示一种方案，则 $(1,1,1)$ 和 $(1,1,1,0)$ 是两种不同的方案。</p>\n<h1 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h1><h2 id=\"Subtask-1\"><a href=\"#Subtask-1\" class=\"headerlink\" title=\"Subtask 1\"></a>Subtask 1</h2><p>$\\sum s_i&lt;n$</p>\n<p>白给，直接输出<strong>impossible</strong>即可。</p>\n<h2 id=\"Subtask-2-amp-3\"><a href=\"#Subtask-2-amp-3\" class=\"headerlink\" title=\"Subtask 2&amp;3\"></a>Subtask 2&amp;3</h2><p>$n,k \\le 5\\times10^2$</p>\n<p>定义 $f(i,j)$ 表示前 $i$ 棵树收集 $j$ 朵花的方案数。</p>\n<p>显然有状态转移方程：</p>\n<script type=\"math/tex; mode=display\">f(i,j)=\\sum\\limits_{x=0}^{\\min(j,s_i)}f(i-1,j-x)</script><p>最终答案为 $\\sum_{i=1}^{k}f(i,n)$。</p>\n<p>时间复杂度：$O(n^2k)$，空间复杂度：$O(nk)$。</p>\n<h2 id=\"Subtask-4\"><a href=\"#Subtask-4\" class=\"headerlink\" title=\"Subtask 4\"></a>Subtask 4</h2><p>$n,k \\le 5\\times10^3$</p>\n<p>$O(n^2k)$ 的复杂度会超时，需要优化。</p>\n<p>发现可以用前缀和优化掉最里面一层循环。</p>\n<p>定义 $sum(i,j)=\\sum_{x=0}^j f(i,x)$。</p>\n<p>所以</p>\n<script type=\"math/tex; mode=display\">f(i,j)=sum(i-1,j)-sum(i-1,j-\\min(j,s_i)-1)</script><p>为了避免数组下标为负数，应改为</p>\n<script type=\"math/tex; mode=display\">f(i,j)=sum(i-1,j)-sum(i-1,j-\\min(j,s_i))+f(i-1,j-\\min(j,s_i)</script><p>时间复杂度：$O(nk)$。</p>\n<p>这时候发现<del>无耻</del>出题人只给了 $64MB$，内存会炸。</p>\n<p>观察上述转移方程，发现 $f$ 数组和 $sum$ 数组只用到了这一层和上一层，所以只存这两层就好。</p>\n<p>空间复杂度：$O(n)$。</p>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><pre><code class=\"lang-cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int mn=5e3+7,mod=10086001;\nint s[mn],f[2][mn],sum[2][mn];\nint now;  //now为当前这一层，now^1为上一层 \nint min1(int x,int y)\n&#123;\n    return x&lt;y?x:y;\n&#125;\nint main()\n&#123;\n    int n,k,cnt=0;\n    cin&gt;&gt;n&gt;&gt;k;\n    f[0][0]=sum[0][0]=f[1][0]=sum[1][0]=1;\n    for(int i=1;i&lt;=k;++i)\n      scanf(&quot;%d&quot;,&amp;s[i]),cnt+=s[i];\n    if(cnt&lt;n)\n    &#123;\n        cout&lt;&lt;&quot;impossible&quot;;\n        return 0;\n    &#125;\n    int ans=0;\n    for(int i=1;i&lt;=k;++i)\n    &#123;\n        now=i&amp;1;  //相当于now=i%2 \n        for(int j=1;j&lt;=n;++j)\n        &#123;\n            sum[now^1][j]=(sum[now^1][j-1]+f[now^1][j])%mod;\n            f[now][j]=(sum[now^1][j]-sum[now^1][j-min1(j,s[i])]+f[now^1][j-min1(j,s[i])])%mod;\n            while(f[now][j]&lt;0)  f[now][j]+=mod;  //取模后相减有可能出现负数 \n        &#125;\n        ans=(ans+f[now][n])%mod;\n    &#125;\n    cout&lt;&lt;ans;\n    return 0;\n&#125;\n</code></pre>\n<link rel=\"stylesheet\" href=\"/css/spoiler.css\" type=\"text/css\"><script src=\"/js/spoiler.js\" type=\"text/javascript\" async></script>","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://www.luogu.com.cn/problem/P6394\">P6394 樱花，还有你</a></p>\n<p>题面好浪漫，<del>可惜我是11月11日写的这题</del>。</p>\n<h1 id=\"题意\"><a href=\"#题意\" class=\"headerlink\" title=\"题意\"></a>题意</h1><p>有 $k$ 棵树，每棵树上有 $s_i$ 朵花，有几种方案能恰好取 $n$ 朵花，若收集不到 $n$ 朵花，输出<strong>impossible</strong>。</p>\n<p><strong>注意</strong>：用 $(a_1,a_2,⋯)$ 表示一种方案，则 $(1,1,1)$ 和 $(1,1,1,0)$ 是两种不同的方案。</p>\n<h1 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h1><h2 id=\"Subtask-1\"><a href=\"#Subtask-1\" class=\"headerlink\" title=\"Subtask 1\"></a>Subtask 1</h2><p>$\\sum s_i&lt;n$</p>\n<p>白给，直接输出<strong>impossible</strong>即可。</p>\n<h2 id=\"Subtask-2-amp-3\"><a href=\"#Subtask-2-amp-3\" class=\"headerlink\" title=\"Subtask 2&amp;3\"></a>Subtask 2&amp;3</h2><p>$n,k \\le 5\\times10^2$</p>\n<p>定义 $f(i,j)$ 表示前 $i$ 棵树收集 $j$ 朵花的方案数。</p>\n<p>显然有状态转移方程：</p>\n<script type=\"math/tex; mode=display\">f(i,j)=\\sum\\limits_{x=0}^{\\min(j,s_i)}f(i-1,j-x)</script><p>最终答案为 $\\sum_{i=1}^{k}f(i,n)$。</p>\n<p>时间复杂度：$O(n^2k)$，空间复杂度：$O(nk)$。</p>\n<h2 id=\"Subtask-4\"><a href=\"#Subtask-4\" class=\"headerlink\" title=\"Subtask 4\"></a>Subtask 4</h2><p>$n,k \\le 5\\times10^3$</p>\n<p>$O(n^2k)$ 的复杂度会超时，需要优化。</p>\n<p>发现可以用前缀和优化掉最里面一层循环。</p>\n<p>定义 $sum(i,j)=\\sum_{x=0}^j f(i,x)$。</p>\n<p>所以</p>\n<script type=\"math/tex; mode=display\">f(i,j)=sum(i-1,j)-sum(i-1,j-\\min(j,s_i)-1)</script><p>为了避免数组下标为负数，应改为</p>\n<script type=\"math/tex; mode=display\">f(i,j)=sum(i-1,j)-sum(i-1,j-\\min(j,s_i))+f(i-1,j-\\min(j,s_i)</script><p>时间复杂度：$O(nk)$。</p>\n<p>这时候发现<del>无耻</del>出题人只给了 $64MB$，内存会炸。</p>\n<p>观察上述转移方程，发现 $f$ 数组和 $sum$ 数组只用到了这一层和上一层，所以只存这两层就好。</p>\n<p>空间复杂度：$O(n)$。</p>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><pre><code class=\"lang-cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int mn=5e3+7,mod=10086001;\nint s[mn],f[2][mn],sum[2][mn];\nint now;  //now为当前这一层，now^1为上一层 \nint min1(int x,int y)\n&#123;\n    return x&lt;y?x:y;\n&#125;\nint main()\n&#123;\n    int n,k,cnt=0;\n    cin&gt;&gt;n&gt;&gt;k;\n    f[0][0]=sum[0][0]=f[1][0]=sum[1][0]=1;\n    for(int i=1;i&lt;=k;++i)\n      scanf(&quot;%d&quot;,&amp;s[i]),cnt+=s[i];\n    if(cnt&lt;n)\n    &#123;\n        cout&lt;&lt;&quot;impossible&quot;;\n        return 0;\n    &#125;\n    int ans=0;\n    for(int i=1;i&lt;=k;++i)\n    &#123;\n        now=i&amp;1;  //相当于now=i%2 \n        for(int j=1;j&lt;=n;++j)\n        &#123;\n            sum[now^1][j]=(sum[now^1][j-1]+f[now^1][j])%mod;\n            f[now][j]=(sum[now^1][j]-sum[now^1][j-min1(j,s[i])]+f[now^1][j-min1(j,s[i])])%mod;\n            while(f[now][j]&lt;0)  f[now][j]+=mod;  //取模后相减有可能出现负数 \n        &#125;\n        ans=(ans+f[now][n])%mod;\n    &#125;\n    cout&lt;&lt;ans;\n    return 0;\n&#125;\n</code></pre>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cloo2ivvq0009r8v3dudr41ca","category_id":"cloo2ivvm0004r8v3bb7k038x","_id":"cloo2ivvv000jr8v3a2d036ps"},{"post_id":"cloo2ivvh0001r8v3682obepe","category_id":"cloo2ivvm0004r8v3bb7k038x","_id":"cloo2ivvy000or8v3fwiyg0ec"},{"post_id":"cloo2ivvs000br8v3bcac6oz2","category_id":"cloo2ivvm0004r8v3bb7k038x","_id":"cloo2ivvz000sr8v3a68afm75"},{"post_id":"cloo2ivvu000gr8v36ik8azbw","category_id":"cloo2ivvm0004r8v3bb7k038x","_id":"cloo2ivw1000wr8v33izs60zf"},{"post_id":"cloo2ivvk0003r8v3e574fukl","category_id":"cloo2ivvs000cr8v3eg6vhb37","_id":"cloo2ivw1000zr8v32m3282vs"},{"post_id":"cloo2ivvv000ir8v31s8i2ic5","category_id":"cloo2ivvm0004r8v3bb7k038x","_id":"cloo2ivw20013r8v3fij5d4fn"},{"post_id":"cloo2ivvx000nr8v347tm0fyg","category_id":"cloo2ivvm0004r8v3bb7k038x","_id":"cloo2ivw30016r8v36mw64kga"},{"post_id":"cloo2ivvp0007r8v312upbu62","category_id":"cloo2ivvm0004r8v3bb7k038x","_id":"cloo2ivw30018r8v37k7a724b"},{"post_id":"cloo2ivvy000rr8v35cpr66j1","category_id":"cloo2ivvm0004r8v3bb7k038x","_id":"cloo2ivw4001ar8v3b9bb4yaq"},{"post_id":"cloo2ivw0000vr8v3c92449kh","category_id":"cloo2ivvm0004r8v3bb7k038x","_id":"cloo2ivw4001br8v31y9qe6ze"}],"PostTag":[{"post_id":"cloo2ivvh0001r8v3682obepe","tag_id":"cloo2ivvo0005r8v3cj887pha","_id":"cloo2ivvt000er8v333yy457z"},{"post_id":"cloo2ivvk0003r8v3e574fukl","tag_id":"cloo2ivvs000dr8v39br67v5j","_id":"cloo2ivvy000pr8v3281h5o2j"},{"post_id":"cloo2ivvp0007r8v312upbu62","tag_id":"cloo2ivvv000lr8v3alb7010s","_id":"cloo2ivw1000xr8v3a9tabu8v"},{"post_id":"cloo2ivw0000vr8v3c92449kh","tag_id":"cloo2ivvz000tr8v35c8404y7","_id":"cloo2ivw20010r8v38o3z7b4w"},{"post_id":"cloo2ivvq0009r8v3dudr41ca","tag_id":"cloo2ivvz000tr8v35c8404y7","_id":"cloo2ivw30014r8v3eqkygsz6"},{"post_id":"cloo2ivvs000br8v3bcac6oz2","tag_id":"cloo2ivvs000dr8v39br67v5j","_id":"cloo2ivw30019r8v3dkk7fcrr"},{"post_id":"cloo2ivvu000gr8v36ik8azbw","tag_id":"cloo2ivw30017r8v313qxddp2","_id":"cloo2ivw4001dr8v37sitam7a"},{"post_id":"cloo2ivvv000ir8v31s8i2ic5","tag_id":"cloo2ivw4001cr8v3fyu6bag7","_id":"cloo2ivw5001gr8v38utn6mr0"},{"post_id":"cloo2ivvv000ir8v31s8i2ic5","tag_id":"cloo2ivw4001er8v33cmi27h3","_id":"cloo2ivw5001hr8v3gbhl72pd"},{"post_id":"cloo2ivvx000nr8v347tm0fyg","tag_id":"cloo2ivw4001fr8v3gzy97ru2","_id":"cloo2ivw5001jr8v336qr8edo"},{"post_id":"cloo2ivvy000rr8v35cpr66j1","tag_id":"cloo2ivw5001ir8v3a12w5idm","_id":"cloo2ivw5001kr8v37umhhah7"}],"Tag":[{"name":"做题记录","_id":"cloo2ivvo0005r8v3cj887pha"},{"name":"模拟退火","_id":"cloo2ivvs000dr8v39br67v5j"},{"name":"网络流","_id":"cloo2ivvv000lr8v3alb7010s"},{"name":"DP","_id":"cloo2ivvz000tr8v35c8404y7"},{"name":"树","_id":"cloo2ivw30017r8v313qxddp2"},{"name":"字符串","_id":"cloo2ivw4001cr8v3fyu6bag7"},{"name":"后缀自动机-SAM","_id":"cloo2ivw4001er8v33cmi27h3"},{"name":"贪心","_id":"cloo2ivw4001fr8v3gzy97ru2"},{"name":"Kruskal重构树","_id":"cloo2ivw5001ir8v3a12w5idm"}]}}